<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Android WindowManager</title>
<!-- 2014-01-30 Thu 13:23 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Android WindowManager</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. WindowManager</a>
<ul>
<li><a href="#sec-1-1">1.1. Client side</a></li>
<li><a href="#sec-1-2">1.2. Server side</a></li>
<li><a href="#sec-1-3">1.3. Topics</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> WindowManager</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Client side</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> View</h4>
<div class="outline-text-4" id="text-1-1-1">
</div><div id="outline-container-sec-1-1-1-1" class="outline-5">
<h5 id="sec-1-1-1-1"><span class="section-number-5">1.1.1.1</span> padding vs. margin</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<p>
padding = 内边距
margin =  外边距
内,外是相对于容器(盒子)的边界而言, 以Button为例,Button可以看作一个盒子,设置button.padding会影响Button里的文字或图片与Button边界的距离,例如:
</p>

<p>
Button
</p>
<pre class="example">
-+---------------+
 |[padding] click|
-+---------------+
</pre>

<p>
而button.margin会影响button与其更外层盒子(如layout)的边界
</p>

<p>
LinearLayout
</p>
<pre class="example">
-+-------------------+
 | [top margin] 	    |
 |+-------------+    |
 || button      |    |
 |+-------------+    |
-+-------------------+
</pre>

<p>
需要注意的一点是,android中view是没有margin属性的,只有 ViewGroup 才有margin属性, 所以,如果想达到上图的效果,不可能直接设置button的margin,而是需在将button
放在一个 ViewGroup 中,然后设置该 ViewGroup 的margin.
</p>
</div>
</div>
<div id="outline-container-sec-1-1-1-2" class="outline-5">
<h5 id="sec-1-1-1-2"><span class="section-number-5">1.1.1.2</span> DecorView</h5>
</div>
<div id="outline-container-sec-1-1-1-3" class="outline-5">
<h5 id="sec-1-1-1-3"><span class="section-number-5">1.1.1.3</span> drawing cache</h5>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> ViewGroup</h4>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> Window</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
对于 activity 和 dialog 来说, 其 DecorView 与一个 PhoneWindow 一一对应,
有一些和 `Window` 相关的操作, 如:
</p>

<ul class="org-ul">
<li>panel 的处理
</li>
<li>处理 window title, window icon &#x2026;
</li>
<li>从WMS来的一些事件如何通知给Activity,Dialog, 例如onBackPressed()
</li>
</ul>

<p>
因此, 提供了一个Window类, 用来处理这些和`Window`有关的操作. 一个Window
对应一个 DecorView 及 ViewRoot (例如 activity 或 dialog 的 DecorView),
但因为 window 会管理各种 panel, 所以它也会管理着 panel 的 ViewRoot 及顶
层 view. 
</p>

<p>
只有DecorView能和Window关联,来处理`Window`相关操作 (因为DecorView是
Window的inner class), 所以只有Activity,Dialog有window的概念
</p>

<p>
在 WMS 一侧也有一个 `window` 的概念, 因为它是 `WindowManager` 嘛, 不过
WMS 的 `window` 是叫 WindowState, 对应于 ViewRoot 和 DecorView, 而不是
PhoneWindow, 它侧重的是Window 的管理, 例如:
</p>

<ol class="org-ol">
<li>LayoutParams
<ol class="org-ol">
<li>Window 的类型: 应用的 window, 系统的 window, 输入法的, statusbar 的, &#x2026;.
</li>
<li>x,y,heigth,width,&#x2026;
</li>
<li>一些特殊的 flag, 例如 FLAG<sub>KEEP</sub><sub>SCREEN</sub><sub>ON</sub>, FLAG<sub>FULLSCREEN</sub>
</li>
</ol>
</li>
<li>window 的 z-order
</li>
<li>window 所属的 Activity (AppWindowToken)
</li>
<li>window 对应的 ViewRoot (WindowToken)
</li>
</ol>

<p>
对 WMS 来说, 每个 Window 对应一个 ViewRoot 以及一个 Surface, 有
z-order 的区别, 但对于 ViewRoot 来说, 其管理的 View 都画在一个
Surface 上, 没有 z-order 的区别.
</p>
</div>

<div id="outline-container-sec-1-1-3-1" class="outline-5">
<h5 id="sec-1-1-3-1"><span class="section-number-5">1.1.3.1</span> PhoneWindow</h5>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> ViewRoot</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
ViewRoot 的几点功能:
</p>

<ol class="org-ol">
<li>通过 IWindowSession 与 WMS 联系
</li>
<li>WMS 通过 ViewrRoot 提共的 IWindow 与 ViewRoot 通信.
</li>
<li>ViewRoot 维护了一个 Surface, 可以供各个 view 进行 draw
</li>
<li>ViewRoot 维护一个 InputChannel, 进行 event dispatching.
</li>
</ol>

<p>
总之, ViewRoot 是应用进程中除 ActivityThread 外最重要的一个东西, 它负
责与 WMS 交互, 并维护 Surface 和 InputChannel.
</p>
</div>
</div>
<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> WindowManagerImpl</h4>
</div>
<div id="outline-container-sec-1-1-6" class="outline-4">
<h4 id="sec-1-1-6"><span class="section-number-4">1.1.6</span> To summarize</h4>
<div class="outline-text-4" id="text-1-1-6">
</div><div id="outline-container-sec-1-1-6-1" class="outline-5">
<h5 id="sec-1-1-6-1"><span class="section-number-5">1.1.6.1</span> ViewRoot, View (DecorView) and Window</h5>
<div class="outline-text-5" id="text-1-1-6-1">
<ul class="org-ul">
<li>与WMS直接打交道的是ViewRoot,WMS能直接看到的只有ViewRoot (通过ViewRoot注册到WMS的IWindow mClient)
</li>

<li>ViewRoot直接管理其顶层View (对于Actity,Dialog, 即DecorView. 对于

<p>
PopupWindow及手动通过WindowManagerImpl.addView添加的view, 其顶层view只是普
通的view), 所以一个进程可以有多个ViewRoot
</p>
</li>

<li>Window是和DecorView一一对应的.

<p>
因为Activity, Dialog项层view是DecorView, 所以有window的概念, 可以通
过Window来控制ContextMenu, 调用Window.Callback等;
</p>
</li>

<li>Window与Activity,Dialog对应

<p>
通过Window.Callback, 可以和Activity和Dialog联系起来,因为它们都实际了
Window.Callback接口.而PopupWindow顶层只是普通view,所以没有Window的概念
</p>
</li>
</ul>

<p>
综上:
</p>
<ul class="org-ul">
<li>WMS&lt;&#x2013;&gt;ViewRoot
</li>
<li>ViewRoot&lt;&#x2013;&gt;DecorView
</li>
<li>DecorView&lt;&#x2013;&gt;Window&lt;&#x2013;&gt;Activity,Dialog
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Server side</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> WindowManagerService</h4>
<div class="outline-text-4" id="text-1-2-1">
</div><div id="outline-container-sec-1-2-1-1" class="outline-5">
<h5 id="sec-1-2-1-1"><span class="section-number-5">1.2.1.1</span> WindowState</h5>
<div class="outline-text-5" id="text-1-2-1-1">
</div><ol class="org-ol"><li>mClient<br  /><div class="outline-text-6" id="text-1-2-1-1-1">
<p>
IWindow as the mClient
</p>
</div>
</li>

<li>WindowToken<br  /></li>
<li>AppWindowToken<br  /><div class="outline-text-6" id="text-1-2-1-1-3">
<p>
AppWindowToken 由 WMS 初始化, 并维护在一个 mTokenMap 中, mTokenMap 的
key 是 AMS 生成的 Token 对象, 这个 Token 对象是由 AMS 在启动 Activity
时初始化, 保存在 WMS.ActivityRecord 中, 然后传递给 ActivityThread, 并保
存在 ActivityThread.ActivityClientRecord 中.
</p>

<p>
即: AMS.Token 由 AMS 生成, AppWindowToken 由 WMS 生成.
</p>

<pre class="example">
+----------------------------------------+               +----+-----+           +-------------------------------------+
| WMS.mTokenMap &lt;Token, AppWindowToken &gt; +---------------+   Token  +-----------+ ActivityThread.ActivityClientRecord |
+------------------------------+---------+               +----+-----+           +-------------------------------------+
                               |                              |
                               |                              |
                         +-----+-------+             +--------+-----------+
                         | WindowState |             | AMS.ActivityThread |
                         +-------------+             +--------------------+
                         | WindowState |
                         +-------------+
                         | ...         |
                         +-------------+
</pre>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> WindowManagerPolicy</h4>
<div class="outline-text-4" id="text-1-2-2">
</div><div id="outline-container-sec-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1"><span class="section-number-5">1.2.2.1</span> PhoneWindowManager</h5>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Topics</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> View</h4>
<div class="outline-text-4" id="text-1-3-1">
</div><div id="outline-container-sec-1-3-1-1" class="outline-5">
<h5 id="sec-1-3-1-1"><span class="section-number-5">1.3.1.1</span> init (addView)</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<p>
window.addView() will firstly gen (viewRoot,view,layout<sub>param</sub>) tuple,
then call ViewRoot.setView() to ask WMS to add the view. since
ViewRoot has an IWindowSession, and it will send IWindow to WMS (as
mClient), it can communicate with WMS back and forth.
</p>

<p>
window.addView() will add [new viewroot,decorView] tuple to
WindowManagerImpl.
</p>

<p>
Activity and Dialog will generate decorView automatically, then call
WM.addView(decorView) to window.  but PopupWindow will not generate
decorView since PopupWindow need not to be `decorated`.
</p>
</div>
</div>

<div id="outline-container-sec-1-3-1-2" class="outline-5">
<h5 id="sec-1-3-1-2"><span class="section-number-5">1.3.1.2</span> requestLayout</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<div class="org-src-container">

<pre class="src src-text">View.requestLayout()
  mParent.requestLayout() ;; for a view, mParent is the upper ViewGroup
    mParent.requestLayout() ;; ViewGroup implements View, thus recursive again to the parent
      ...
        top_view.requestLayout()
          ViewRoot.requestLayout() ;; top view's mParent is the ViewRoot
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">ViewRoot.requestLayout()
  ViewRoot.scheduleTraversals()
    ViewRoot.performTraversals() handles the msg
      mView.dispatchAttachedToWindow() ;; mView is the ViewRoot's top view
        ViewGroup.dispatchAttachedToWindow()
          view.dispatchAttachedToWindow() for every child view of the ViewGroup
            view.onAttachedToWindow() ;;  see [[onAttachedToWindow][onAttachedToWindow]]
      mView.measure()
        mView.onMeasure()
          layout.onMeasure() ;; e.g. LinearLayout, FrameLayout
            view.measure() ;; for every child view of the layout, including margin
              view.onMeasure() ;; see [[onMeasure][onMeasure]]
      mView.layout()
        layout.layout() ;; e.g. LinearLayout
          view.layout() ;; it seems that view.layout &amp;&amp; view.onLayout doesn't do something meaningful?  it mainly stores the child's x,y,width,height
                        ;; so that we can, when touch the screen, tell which view is touched
            view.onLayout() ;; see [[onLayout][onLayout]],
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-1-3" class="outline-5">
<h5 id="sec-1-3-1-3"><span class="section-number-5">1.3.1.3</span> invalidate</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
invalidate 不会导致 measure 和 layout, 虽然它也会导致
performTraversals, 但在 traversal 过程中因为 layoutRequested 为false,
导致 measure, layout 都不执行, 只执行最后一步 draw 操作.
</p>

<p>
另外, invalidate 可以指定一个 dirty rect (不指定时 dirty rect 为整个
window), 这样 canvas 在 draw 的过程中可以忽略那个不在这个 dirty rect
中的那些 view (通过 canvas.quickReject), 实现局部刷新.
</p>

<ul class="org-ul">
<li>invalidate 与 requestLayout 的不同
invalidate 只会导致 draw (可能只是 dirty 部分的 draw), 但
requestLayout 会导致整个 windows 的 measure, layout, draw
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-1-4" class="outline-5">
<h5 id="sec-1-3-1-4"><span class="section-number-5">1.3.1.4</span> measure</h5>
</div>
<div id="outline-container-sec-1-3-1-5" class="outline-5">
<h5 id="sec-1-3-1-5"><span class="section-number-5">1.3.1.5</span> layout</h5>
<div class="outline-text-5" id="text-1-3-1-5">
</div><ol class="org-ol"><li>android:layout<sub>gravity</sub> &amp; android:gravity<br  /><div class="outline-text-6" id="text-1-3-1-5-1">
<p>
during onMeasure, view's size is fixed, after-wards, ViewGroup.onLayout will re-position children views and invoke child.onLayout to notify children
for their position.
</p>

<ul class="org-ul">
<li>similar with android:height, only a few views or ViewGroup has the android:gravity property.
e.g. TextView has the android:gravity property, so that the inner text can be positioned to top/bottom/left/right
LinearLayout also has the android:gravity, which control Linear Layout's children's gravity as a whole.
</li>
</ul>
</div>
<ol class="org-ol"><li>How does LinearLayout make use of gravity.<br  /><div class="outline-text-8" id="text-1-3-1-5-1-0-1">
<ul class="org-ul">
<li>for <b>Vertical</b> LinearLayout with layout<sub>height</sub>= <b>fill<sub>parent</sub></b> :
vertical LinearLayout can only set it's android:gravity to `top,bottom,center<sub>vertical`</sub>, which can move the children as a whole in
vertical direction.
vertical LinearLayout's child can set their android:layout<sub>gravity</sub> to `left,right,center<sub>horizontal`</sub>,which can move a single child view
in the horizontal direction.

<p>
that is, if u want to position a view in vertical LinearLayout to right-bottom, u can:
</p>
<ul class="org-ul">
<li>set LinearLayout.android:gravity to bottom
</li>
<li>set view.android:layout<sub>gravity</sub> to right
</li>
</ul>
</li>
</ul>

<pre class="example">
 vertical LinearLayout      	       	      set android:gravity to bottom   		&amp; set view1.layout_gravity to right
-+-----------------------+                -+-----------------------+                -+--------------------------+
 |-+-------------+	    |		      |			      |		       	|		 	   |
 | |	 view1	    |	    |		      |			      |		       	|		 	   |
 | |	      	    |	    |		      |			      |		       	|		 	   |
 |-+-------------+	    |		      |			      |		       	|		 	   |
 | |	 view2	    |	    |		      | 		      |		       	|		 	   |
 | |		    |	    |		      | 		      |		       	|		 	   |
 |-+-------------+	    |		      |-+--------------+      |		       	|  	    -+-----------+ |
 |			    |		      |	|  view1       |      |		       	|  	     |	view1	 | |
 |			    |		      |	|  	       |      |		       	|      	     | 	     	 | |
 |			    |		      |-+--------------+      |		       	| -+---------+--+--------+ |
 |			    |		      |	|  view2       |      |		       	|  |  view2    	|    	   |
 |			    |		      |	|      	       |      |		       	|  |		|    	   |
 |			    |		      |-+--------------+      |		       	| -+------------+  	   |
-+-----------------------+		     -+-----------------------+		       -+--------------------------+
</pre>

<ul class="org-ul">
<li>for horizontal LinearLayout:
vice-versa
</li>
</ul>
</div>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-1-3-1-6" class="outline-5">
<h5 id="sec-1-3-1-6"><span class="section-number-5">1.3.1.6</span> draw</h5>
<div class="outline-text-5" id="text-1-3-1-6">
<p>
see also <i>android graphics</i>
</p>
</div>
</div>

<div id="outline-container-sec-1-3-1-7" class="outline-5">
<h5 id="sec-1-3-1-7"><span class="section-number-5">1.3.1.7</span> focus switching</h5>
<div class="outline-text-5" id="text-1-3-1-7">
<p>
when press 'left' key, how the focus is changed?
</p>

<ol class="org-ol">
<li>when viewRoot got the key event, it will firstly call
'dispatchKeyEventToViewHierachy' to dispatch the key event to it's
correspondingg top level viw (i.e. DecorView)
</li>
<li>If the key event is not handled by the view hierachy, viewRoot will
call 'findFocus' to find next focus in 'handleFinishedEvent'
</li>
<li>If the current focused view has set 'focus:right&#x2026;' properties,
viewRoot will call view.findViewById to find the next focus, or
find the nearest focusable view in a specified rectangle area.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> ViewRoot</h4>
<div class="outline-text-4" id="text-1-3-2">
</div><div id="outline-container-sec-1-3-2-1" class="outline-5">
<h5 id="sec-1-3-2-1"><span class="section-number-5">1.3.2.1</span> init</h5>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> WindowToken, AppWindowToken and WindowState</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService对窗口的组织方式分析</a>
</p>
</div>

<div id="outline-container-sec-1-3-3-1" class="outline-5">
<h5 id="sec-1-3-3-1"><span class="section-number-5">1.3.3.1</span> addWindow</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<p>
Activity, Service, IME 等都可以 addWindow, 但有时 addWindow 会出错, 这
是为何?
</p>

<ol class="org-ol">
<li>对于 sevice 来说, 为何可以显示 toast, 却不可以显示 dialog?
</li>
<li>service 如何显示一个 window ?
</li>
<li>activity 挂掉后再显示一个 window 为何报错?
</li>
<li>IME, wallpaper 的 window 是怎么个情况? 是否受 activity 的生命期的控
制?
</li>
</ol>
</div>

<ol class="org-ol"><li>Activity<br  /><div class="outline-text-6" id="text-1-3-3-1-1">
<div class="org-src-container">

<pre class="src src-text">startActivityLocked()
  mService.mWindowManager.addAppToken(addPos, r.appToken,...)
    mTokenMap.put(token.asBinder(), wtoken);
</pre>
</div>

<p>
即 Activity 启动后, WMS.mTokenMap 中会新增一项对应于该 Activity 的
WindowToken (实际上为 AppWindowToken)
</p>
</div>
</li>
<li>Service<br  /><div class="outline-text-6" id="text-1-3-3-1-2">
<p>
Service 启动时不会于 PMS 添加任何 token
</p>
</div>
</li>
<li>IME<br  /><div class="outline-text-6" id="text-1-3-3-1-3">
<div class="org-src-container">

<pre class="src src-text">InputBindResult startInputInnerLocked()
  mCurToken = new Binder();
  mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
</pre>
</div>
</div>
</li>
<li>addWindow<br  /><div class="outline-text-6" id="text-1-3-3-1-4">
<div class="org-src-container">

<pre class="src src-text">WMS.addWindow(Session session, IWindow client, ...)
  WindowToken token = mTokenMap.get(attrs.token);
  // &#23545;&#20110; Activity &#26469;&#35828;, token &#32943;&#23450;&#19981;&#20026; null, &#24182;&#19988; token &#24212;&#35813;&#26159;
  // &#19968;&#20010; AppWindowToken

  // &#23545;&#20110; Service &#26469;&#35828;, token &#21487;&#33021;&#20026; null (&#22240;&#20026; service &#21551;&#21160;&#26102;&#27809;&#26377;&#27880;&#20876;
  // &#20219;&#20309; token), &#20063;&#21487;&#33021;&#19981;&#20026; null (&#20363;&#22914;&#20043;&#21069; show &#36807; toast, &#35814;&#35265;
  // addToToken &#21464;&#37327;)

  // &#23545;&#20110; IME &#26469;&#35828;, token &#24212;&#35813;&#19981;&#20026; null, &#22240;&#20026; startInputInnerLocked &#20250;
  // &#27880;&#20876;&#19968;&#20010; WindowToken (&#38750; AppWindowToken)

  if (token == null):
    if (attrs.type &gt;= FIRST_APPLICATION_WINDOW
      &amp;&amp; attrs.type &lt;= LAST_APPLICATION_WINDOW):
      error;
      // &#35201;&#26174;&#31034;&#19968;&#20010;&#24212;&#29992; window &#20294; token &#20026; null? &#24847;&#21619;&#30528; activity &#24050;&#32463; destroy
    if (attrs.type == TYPE_INPUT_METHOD):
      error;
      // &#19981;&#21487;&#33021;&#30340;&#24773;&#20917;, &#22240;&#20026; startInputInnerLocked &#20250;&#27880;&#20876;&#19968;&#20010; WindowToken
    else:
      token = new WindowToken(this, attrs.token, -1, false);
      addToToken = true;
      // &#20854;&#20182;&#31867;&#22411;&#30340; window type ? &#20363;&#22914; toast, &#25110;&#31995;&#32479; dialog
      // &#28155;&#21152;&#19968;&#20010;&#26032; token
  elseif attrs.type &gt;= FIRST_APPLICATION_WINDOW
         &amp;&amp; attrs.type &lt;= LAST_APPLICATION_WINDOW):
    // token &#19981;&#20026; null, &#25110; type &#20026;&#24212;&#29992;
    AppWindowToken atoken = token.appWindowToken;
    if (atoken == null):
      // token &#19981;&#26159;&#19968;&#20010; AppWindowToken &#21364;&#35201;&#26174;&#20110;&#19968;&#20010; app window, &#25253;&#38169;
      error;
  elseif (attrs.type == TYPE_INPUT_METHOD):
    if (token.windowType != TYPE_INPUT_METHOD):
      // token &#19981;&#26159; null, token &#30340;&#31867;&#22411;&#19981;&#31526;, &#25253;&#38169;
      error;
   win = new WindowState(this, session, client, token,..)
   if (addToToken):
     mTokenMap.put(attrs.token, token);
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> Activity window size</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
<a href="http://blog.csdn.net/luoshengyang/article/details/8479101">http://blog.csdn.net/luoshengyang/article/details/8479101</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> window z-order</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
<a href="http://blog.csdn.net/luoshengyang/article/details/8570428">Android窗口管理服务WindowManagerService计算窗口Z轴位置的过程分析</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> App Transition</h4>
<div class="outline-text-4" id="text-1-3-6">
</div><div id="outline-container-sec-1-3-6-1" class="outline-5">
<h5 id="sec-1-3-6-1"><span class="section-number-5">1.3.6.1</span> overridePendingTransition</h5>
</div>
</div>

<div id="outline-container-sec-1-3-7" class="outline-4">
<h4 id="sec-1-3-7"><span class="section-number-4">1.3.7</span> Starting Window</h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
WMS.setAppStartingWindow
</p>
</div>
</div>

<div id="outline-container-sec-1-3-8" class="outline-4">
<h4 id="sec-1-3-8"><span class="section-number-4">1.3.8</span> Event Dispatching</h4>
<div class="outline-text-4" id="text-1-3-8">
<p>
see also <i>Android Event Dispatching</i>
</p>
</div>
</div>

<div id="outline-container-sec-1-3-9" class="outline-4">
<h4 id="sec-1-3-9"><span class="section-number-4">1.3.9</span> 从 startActivity 到显示的过程</h4>
<div class="outline-text-4" id="text-1-3-9">

<div class="figure">
<p><img src="start_activity.png" alt="start_activity.png" />
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-01-30 Thu 13:23</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
