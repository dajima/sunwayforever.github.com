<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Visitor Pattern</title>
<!-- 2014-09-26 Fri 10:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Visitor Pattern</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Single/Double/Multiple Dispatching</a>
<ul>
<li><a href="#sec-1-1">1.1. Single Dispatching</a></li>
<li><a href="#sec-1-2">1.2. Double Dispatching / Multiple Dispatching</a></li>
<li><a href="#sec-1-3">1.3. 使用运行时类型识别模拟Double Dispatching</a></li>
<li><a href="#sec-1-4">1.4. 使用Single Dispatching来模拟Double Dispatching</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Visitor Pattern</a>
<ul>
<li><a href="#sec-2-1">2.1. 使用Visitor Pattern模拟Double Dispatching</a></li>
<li><a href="#sec-2-2">2.2. Visitor Pattern</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Visitor Pattern 的应用</a>
<ul>
<li><a href="#sec-3-1">3.1. ASM</a></li>
<li><a href="#sec-3-2">3.2. MultiJava</a></li>
<li><a href="#sec-3-3">3.3. dalvik GC ?</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Single/Double/Multiple Dispatching</h2>
<div class="outline-text-2" id="text-1">
<p>
Dispatching, 指的是调用一个函数时, 因为存在多个同名的函数,仅仅靠函数的
名字无法确定究竟要调用哪个, 这时函数参数的个数和类型就需要被考虑;
Dispatching就是指: 根据函数的参数的个数和类型选择具体要执行的函数.
</p>

<p>
看起来 Dispatching 和 Overloading 很像, 实际上从我个人的理解来看, 这里
讨论的Dispatching属于 <b>运行时行为</b>, 则 Overloading 属于 <b>编译时行为</b> ,
所以两者并没有关系.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Single Dispatching</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Single Dispatching, 即只能根据函数的某一个参数进行dispatch, 多态就是一
个single Dispatching, 因为每一个虚函数都隐含着一个 this 参数, 程序在运
行时可以根据 this 具体类型的不同, 选择不同的函数.
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Double Dispatching / Multiple Dispatching</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Double Dispatching 和 Multiple Dispatching, 顾名思义, 就是根据函数的两
个或多个参数的运行时类型进行dispatch.大部分编译型的面向对象的语言,如
C++,Java, 都不支持Multiple/Double Dispatching, 例如:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">Test</span> {
    <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">foo</span> (<span style="color: #b58900;">Throwable</span> <span style="color: #268bd2;">e</span>) {

    }
    <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">foo</span> (<span style="color: #b58900;">Error</span> <span style="color: #268bd2;">e</span>) {

    }
    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #b58900;">Throwable</span> <span style="color: #268bd2;">e</span>=<span style="color: #859900;">new</span> <span style="color: #b58900;">Error</span> ();
        foo (e);
    }
}
</pre>
</div>

<p>
对应的byte code:
</p>

<div class="org-src-container">

<pre class="src src-TEXT">  public static void main(java.lang.String[]);
  Code:
   Stack=2, Locals=2, Args_size=1
   0:   new     #2; //class java/lang/Error
   3:   dup
   4:   invokespecial   #3; //Method java/lang/Error."&lt;init&gt;":()V
   7:   astore_1
   8:   aload_1
        // 编译时就确定为使用 Method foo:(Ljava/lang/Throwable;)V  
   9:   invokestatic    #4; //Method foo:(Ljava/lang/Throwable;)V  
   12:  return
}
</pre>
</div>

<p>
在编译时 foo(e)就已经被确定为 foo(Throwable e) 这个函数, 而不会在运行时
根据e的具体类型选择 foo(Error). 所以函数重载不是Multiple Dispatching
</p>

<p>
虽然C++,Java等不支持Multiple/Double Dispatching, 但可以使用其他方法来模
拟,因为C++和Java都支持Single Dispatching和运行时类型识别 (C++的RTTI和
Java的Reflection)
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 使用运行时类型识别模拟Double Dispatching</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">Test</span> {
   <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">foo</span> (<span style="color: #b58900;">Throwable</span> <span style="color: #268bd2;">e</span>) {
     <span style="color: #859900;">if</span> (e <span style="color: #859900;">instanceof</span> Exception) {

     } <span style="color: #859900;">else</span> <span style="color: #859900;">if</span> (e <span style="color: #859900;">instanceof</span> Error) {

     }
   }
   <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
     <span style="color: #b58900;">Throwable</span> <span style="color: #268bd2;">e</span>=<span style="color: #859900;">new</span> <span style="color: #b58900;">Error</span> ();
     foo (e);
   }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 使用Single Dispatching来模拟Double Dispatching</h3>
<div class="outline-text-3" id="text-1-4">
<p>
见 Visitor Pattern
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Visitor Pattern</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 使用Visitor Pattern模拟Double Dispatching</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Visitor Pattern定义了两类对象: Element和Visitor, 其中Element需要定义一
个accept方法, 而visitor需要定义一个visit方法.
</p>

<p>
一个简单的Visitor Pattern的例子:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">interface</span> <span style="color: #b58900;">Element</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span> (<span style="color: #b58900;">Visitor</span> <span style="color: #268bd2;">v</span>);
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">AElement</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Element</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span> (<span style="color: #b58900;">Visitor</span> <span style="color: #268bd2;">v</span>) {
        v.visit (<span style="color: #859900;">this</span>);
    }
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">BElement</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Element</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span> (<span style="color: #b58900;">Visitor</span> <span style="color: #268bd2;">v</span>) {
        v.visit (<span style="color: #859900;">this</span>);
    }
}

<span style="color: #859900;">interface</span> <span style="color: #b58900;">Visitor</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span> (<span style="color: #b58900;">AElement</span> <span style="color: #268bd2;">e</span>);
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span> (<span style="color: #b58900;">BElement</span> <span style="color: #268bd2;">e</span>);
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">AVisitor</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Visitor</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span> (<span style="color: #b58900;">AElement</span> <span style="color: #268bd2;">ae</span>) {
        System.out.println(<span style="color: #2aa198;">"AVisitor visit AElement"</span>);
    }
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span> (<span style="color: #b58900;">BElement</span> <span style="color: #268bd2;">ae</span>) {
        System.out.println(<span style="color: #2aa198;">"AVisitor visit BElement"</span>);
    }
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">BVisitor</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Visitor</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span> (<span style="color: #b58900;">AElement</span> <span style="color: #268bd2;">ae</span>) {
        System.out.println(<span style="color: #2aa198;">"BVisitor visit AElement"</span>);
    }
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span> (<span style="color: #b58900;">BElement</span> <span style="color: #268bd2;">ae</span>) {
        System.out.println(<span style="color: #2aa198;">"BVisitor visit BElement"</span>);
    }
}

<span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">Test</span> {
    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #b58900;">Element</span> <span style="color: #268bd2;">ae</span>=<span style="color: #859900;">new</span> <span style="color: #b58900;">BElement</span> ();
        <span style="color: #b58900;">Visitor</span> <span style="color: #268bd2;">av</span>=<span style="color: #859900;">new</span> <span style="color: #b58900;">AVisitor</span> ();
        ae.accept (av);
    }
}
</pre>
</div>

<p>
这个例子模拟了 Double Dispatching, 因为对于 Visitor 来说, 首先, 根据
Visitor的具体类型 (AVisitor) 找到 Avisitor 的方法, 然后 AVisitor 又根据
Element的具体类型(BElement)找到了最终的 AVisitor.visit(BElement) 方法.
</p>

<p>
这里的关键有两点:
</p>
<ol class="org-ol">
<li>借助了 Element 类对自己的 accept 方法的 Single Dispatching.
</li>
<li>借助了 Overloading 
</li>
</ol>
<p>
其中第一点是主要的,第二点可有可无, 大不了将程序改成这样:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">class</span> <span style="color: #b58900;">AElement</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Element</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span> (<span style="color: #b58900;">Visitor</span> <span style="color: #268bd2;">v</span>) {
        v.visitAElement (<span style="color: #859900;">this</span>);
    }
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">BElement</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Element</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span> (<span style="color: #b58900;">Visitor</span> <span style="color: #268bd2;">v</span>) {
        v.visitBElement (<span style="color: #859900;">this</span>);
    }
}

<span style="color: #859900;">interface</span> <span style="color: #b58900;">Visitor</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visitAElement</span> (<span style="color: #b58900;">AElement</span> <span style="color: #268bd2;">e</span>);
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visitBElement</span> (<span style="color: #b58900;">BElement</span> <span style="color: #268bd2;">e</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Visitor Pattern</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Visitor Pattern的目的是将数据结构与算法分离, 当需要对对象添加新的方法时,
不需要修改对象, 只需要修改算法. 在上面的例子中, Element指数据结构,
Visitor指算法.
</p>

<p>
举例来说, 动物这类对象做为Element, 其子类包括阿猫阿狗之类；动物能做的具
体的动作做为Visitor, 例如叫,跑,被人吃掉&#x2026;
</p>

<p>
最传统的实现方法是:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">interface</span> <span style="color: #b58900;">Animal</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">run</span> () 
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">Dog</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Animal</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">run</span> () {
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">concrete implmentation</span>
    }
}
</pre>
</div>

<p>
但这种实现方法带来的问题是: 具体的算法 (如run) 和对象是绑定在一起的, 而
且如果要添加一个新的 bark 方法,必须修改接口类和实现类, 而修改接口类是不
可接受的.
</p>

<p>
若使用 Visitor Pattern, 则可以把 run 方法封装到的一个 RunVisitor 类中,
然后调用 Animal.accept(runVisitor()) 即可, 所有的算法都只包含在各个
Visitor 中.
</p>

<p>
如果要添加一个 bark 方法,只需要实现一个 BarkVisitor 即可.
</p>

<p>
可见, Visitor Pattern 最大的威力在于: 可以在不修改 Element 接口的前提
下给 Element 增加虚方法. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Visitor Pattern 的应用</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> ASM</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<a href="http://asm.ow2.org">ASM Homepage</a>
</p>

<p>
ASM (一个动态生成或修改java class的库) 使用 Visitor Pattern 来实现其基
于事件的模型.
</p>

<p>
它在解析class时会触发一系列事件, 如解析到一个class, 解析到一个method等,
这些事件被做为Element; 对这些事件的处理, 如打印log, 保存到目标class等被
做为Visitor. 在ASM中, Element被看作是事件的提供者, 而Visitor被看作事件
的处理者.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> MultiJava</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<a href="http://multijava.sf.net">MultiJava Homepage</a>
</p>

<blockquote>
<p>
MultiJava is an extension to the Java programming language that adds open classes
and symmetric multiple dispatch. Multiple dispatch allows the code invoked by a 
method call to depend on the run-time type of all the arguments, instead of just
the receiver, this is useful for event handlers and for binary methods, like
equals in Java.
</p>

<p>
The MultiJava project provides `mjc`, a MultiJava compiler, that translate MultiJava
programs to regular Java bytecode. 
</p>
</blockquote>

<p>
使用MultiJava进行event dispatching的例子:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">interface</span> <span style="color: #b58900;">Event</span> {
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">Event1</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Event</span> {
};

<span style="color: #859900;">class</span> <span style="color: #b58900;">Event2</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">Event</span> {
};

<span style="color: #859900;">public</span> <span style="color: #859900;">abstract</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">AbstractHandler</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent</span> (<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>) {
    }
}

<span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">MyJavaHandler</span> <span style="color: #859900;">extends</span> <span style="color: #b58900;">AbstractHandler</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent</span> (<span style="color: #b58900;">Event@Event1</span> <span style="color: #268bd2;">e</span>) {
        System.out.println(<span style="color: #2aa198;">"event1"</span>);
    }
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent</span> (<span style="color: #b58900;">Event@Event2</span> <span style="color: #268bd2;">e</span>) {
        System.out.println(<span style="color: #2aa198;">"event2"</span>);
    }
    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span> [] <span style="color: #268bd2;">args</span>) {
        <span style="color: #b58900;">MyJavaHandler</span> <span style="color: #268bd2;">handler</span> = <span style="color: #859900;">new</span> <span style="color: #b58900;">MyJavaHandler</span>();
        <span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span> =  <span style="color: #859900;">new</span> <span style="color: #b58900;">Event1</span>();
        handler.handleEvent(e);
    }
}
</pre>
</div>

<p>
因为`Event@Event1`不是合法的Java语法,所以MultiJava需要使用`mjc`工具对源
码进来转换,转换的过程实际就是解析这种`Event@Event1`, 然后使用Visitor
Pattern生成相应的Element和Visitor
</p>

<p>
最终 mjc 可能会生成类似的代码:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">abstract</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">AbstractHandler</span> {
    <span style="color: #859900;">public</span> <span style="color: #859900;">abstract</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent</span> (<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>);
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">Event1</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span>(<span style="color: #b58900;">MyJavaHandler</span> <span style="color: #268bd2;">visitor</span>) {
        visitor.visit(<span style="color: #859900;">this</span>);
    }
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">Event2</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">accept</span>(<span style="color: #b58900;">MyJavaHandler</span> <span style="color: #268bd2;">visitor</span>) {
        visitor.visit(<span style="color: #859900;">this</span>);
    }
}

<span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">MyJavaHandler</span> <span style="color: #859900;">extends</span> <span style="color: #b58900;">AbstractHandler</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span>(<span style="color: #b58900;">Event1</span> <span style="color: #268bd2;">e</span>) {
        handleEvent_1(Event@Event1);    
    }
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">visit</span>(<span style="color: #b58900;">Event2</span> <span style="color: #268bd2;">e</span>) {
        handleEvent_2(Event@Event2);
    }
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent</span>(<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>) {
        e.accept(<span style="color: #859900;">this</span>);
    }
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent_1</span> (<span style="color: #b58900;">Event1</span> <span style="color: #268bd2;">e</span>) {
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">handle Event1</span>
    }
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">handleEvent_2</span> (<span style="color: #b58900;">Event2</span> <span style="color: #268bd2;">e</span>) {
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">handle Event2</span>
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> dalvik GC ?</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">dvmHeapMarkRootSet</span>() {
    GcHeap *gcHeap = gDvm.gcHeap;
    dvmMarkImmuneObjects(gcHeap-&gt;markContext.immuneLimit);
    dvmVisitRoots(rootMarkObjectVisitor, &amp;gcHeap-&gt;markContext);
}
</pre>
</div>

<p>
这并不算是 Visitor Pattern: 它并没有利用 double dispatching, 这里的
rootMarkObjectVisitor 更类似于 strategy pattern.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-09-26 Fri 10:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.50.4 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
