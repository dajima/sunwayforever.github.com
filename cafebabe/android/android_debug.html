<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Android Debug</title>
<!-- 2014-09-26 Fri 10:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Android Debug</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Android Debug</a>
<ul>
<li><a href="#sec-1-1">1.1. hierachyviewer</a></li>
<li><a href="#sec-1-2">1.2. ddms</a></li>
<li><a href="#sec-1-3">1.3. adb</a></li>
<li><a href="#sec-1-4">1.4. monkey</a></li>
<li><a href="#sec-1-5">1.5. uiautomator</a></li>
<li><a href="#sec-1-6">1.6. tombstone / debuggerd</a></li>
<li><a href="#sec-1-7">1.7. watchdog</a></li>
<li><a href="#sec-1-8">1.8. anr trace</a></li>
<li><a href="#sec-1-9">1.9. UncaughtHandler 打印的 trace</a></li>
<li><a href="#sec-1-10">1.10. 程序中生成 c++ trace</a></li>
<li><a href="#sec-1-11">1.11. 程序中使用 libcorkscrew 生成 c trace</a></li>
<li><a href="#sec-1-12">1.12. debuggerd</a></li>
<li><a href="#sec-1-13">1.13. valgrind</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Android Debug</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> hierachyviewer</h3>
<div class="outline-text-3" id="text-1-1">
<p>
hierachyviewer 在 host 端通过 socket 与手机端的 ViewServer 通信.
ViewServer 并非开机启动, 而是需要由 host 端的 hierachyviewer 的
startViewServer 通过 "adb shell service call window 1 i32 port" 调用
WMS 的 startViewServer 来启动,
</p>

<p>
ViewServer 会负责调用 ViewDebug 的相关方法来 DUMP 或 CAPTURE 等
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> ddms</h3>
<div class="outline-text-3" id="text-1-2">
<p>
ddms 通过 jdwp 控制 java 进程
</p>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> method tracing</h4>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> hprof</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>在代码中生成
Debug.dumpHprofData()
</li>
<li>使用信号on-demand生成
</li>
<li>为了能让MAT识别android的hprof格式,需要用hprof-conv转换一下
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> gc</h4>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> adb</h3>
<div class="outline-text-3" id="text-1-3">
<p>
adb 通过 host 上的 adb 与手机端的 adbd 通信
</p>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> logcat</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
adb shell setprop log.tag.mytag verbose
</p>
</div>
<div id="outline-container-sec-1-3-1-1" class="outline-5">
<h5 id="sec-1-3-1-1"><span class="section-number-5">1.3.1.1</span> events log</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<ul class="org-ul">
<li>content<sub>query</sub><sub>sample</sub>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> logwrapper</h4>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> am</h4>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> pm</h4>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> dumpsys</h4>
</div>
<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> input</h4>
</div>
<div id="outline-container-sec-1-3-7" class="outline-4">
<h4 id="sec-1-3-7"><span class="section-number-4">1.3.7</span> procrank</h4>
</div>
<div id="outline-container-sec-1-3-8" class="outline-4">
<h4 id="sec-1-3-8"><span class="section-number-4">1.3.8</span> procmem</h4>
</div>
<div id="outline-container-sec-1-3-9" class="outline-4">
<h4 id="sec-1-3-9"><span class="section-number-4">1.3.9</span> librank</h4>
</div>
<div id="outline-container-sec-1-3-10" class="outline-4">
<h4 id="sec-1-3-10"><span class="section-number-4">1.3.10</span> getprop</h4>
</div>
<div id="outline-container-sec-1-3-11" class="outline-4">
<h4 id="sec-1-3-11"><span class="section-number-4">1.3.11</span> dumpstate</h4>
</div>
<div id="outline-container-sec-1-3-12" class="outline-4">
<h4 id="sec-1-3-12"><span class="section-number-4">1.3.12</span> setprop</h4>
</div>
<div id="outline-container-sec-1-3-13" class="outline-4">
<h4 id="sec-1-3-13"><span class="section-number-4">1.3.13</span> service</h4>
<div class="outline-text-4" id="text-1-3-13">
<p>
例如 hierachyviewer 启动 ViewServer 就是使用 "service call window 1
i32 port" 命令
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> monkey</h3>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> uiautomator</h3>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> tombstone / debuggerd</h3>
<div class="outline-text-3" id="text-1-6">
<p>
tombstone 主要包含以下信息:
</p>
<ol class="org-ol">
<li>stack trace
</li>
<li>部分内存和寄存器的值
</li>
</ol>

<p>
但不包含 coredump 文件 (coredump 是由 kernel 自动生成的, 和 debuggerd
或 tombstone 无关)
</p>

<p>
tombstone 的生成由两方面配合: 
</p>
<ol class="org-ol">
<li>一个 stand-alone 的基于 local socket 的 server: debuggerd.c
</li>
<li>bionic 中通过 linker 嵌入到每一个可执行程序的代码: debugger.cpp
</li>
</ol>
</div>

<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> debuggerd.c</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
debuggerd 由 init 启动, 在一个 local socket 上监听, 每一个进程当收到
SIG<sub>ABORT</sub> 等信号时, 会因为 debugger.c 的原因向 debuggerd.c 发送通知,
debuggerd.c 负责 dump tombstone 文件, dump 完成后向原进程再次发送同样
的信号, 这时进程才真正退出. 
</p>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> debugger.cpp</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
debugger.cpp 由 bionic 的 linker 负责嵌入到每一个 elf 文件的 _start 段,
所以每一个进程都会自动执行该代码. 它的作用主要是 catch 住所有会导致退
出的信号, 例如 SIG<sub>ABRT</sub>, SIG<sub>SEGV</sub> 等 (但不包括 SIG<sub>KILL</sub>). 对应的
signal handler 就是向 debuggerd.c 发送消息, 请求 dump tombstone, 同时,
为了收到 debuggerd 再次发送的信号能退出, debugger.c 会把这些信号的
handler 置为 default.
</p>

<p>
因为 SIG<sub>KILL</sub> 无法被 catch, 所以 tombstone 无法处理 java crash, 因为
java crash 是通过 dalvik 向自己发送 SIG<sub>KILL</sub> 实现的.
</p>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> 手动生成 tombstone</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
通过 debuggerd -b &lt;pid&gt; 可以直接生成 pid 对应进程的 tombstone
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> watchdog</h3>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> anr trace</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> AMS 发送 SIGQUIT (3)</h4>
<div class="outline-text-4" id="text-1-8-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #2aa198;">AMS</span>:<span style="color: #b58900;">appNotResponding</span>
  <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">for the pid, or other related pids, send SIG_QUIT (3)</span>
  Process.<span style="color: #268bd2;">sendSignal</span>(<span style="color: #b58900;">pid</span>, <span style="color: #2aa198;">Process</span>.<span style="color: #b58900;">SIGNAL_QUIT</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> SignalCatcher Thread</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
每个 java 进程初始时会启动一个 SignalCatcher Thread, 用来接收 SIG<sub>QUIT</sub>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">start signal catcher thread that dumps stacks on SIGQUIT */</span>
<span style="color: #859900;">if</span> (<span style="color: #dc322f;">!</span>gDvm.reduceSignals &amp;&amp; <span style="color: #dc322f;">!</span>gDvm.noQuitHandler) {
    <span style="color: #859900;">if</span> (<span style="color: #dc322f;">!</span>dvmSignalCatcherStartup())
        <span style="color: #859900;">return</span> <span style="color: #2aa198;">false</span>;
}
</pre>
</div>

<p>
SIG<sub>QUIT</sub> 的 handler 如下:
</p>

<div class="org-src-container">

<pre class="src src-java">dvmSuspendAllThreads(SUSPEND_FOR_STACK_DUMP);
dvmDumpLoaderStats(<span style="color: #2aa198;">"sig"</span>);
dvmDumpJniStats(&amp;target);
dvmDumpAllThreadsEx(&amp;target, <span style="color: #2aa198;">true</span>);
</pre>
</div>

<p>
参考: dalvik thread suspend
</p>
</div>
</div>

<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3"><span class="section-number-4">1.8.3</span> 手动生成 trace</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
kill -3 &lt;pid&gt;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> UncaughtHandler 打印的 trace</h3>
<div class="outline-text-3" id="text-1-9">
<p>
除了 debuggerd/anr trace 外, java 程序因为 UncaughtHandler 退出时也会
打印 trace
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">try</span> {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Bring up crash dialog, wait for it to be dismissed</span>
    ActivityManagerNative.getDefault().handleApplicationCrash(
        mApplicationObject, <span style="color: #859900;">new</span> <span style="color: #2aa198;">ApplicationErrorReport</span>.<span style="color: #b58900;">CrashInfo</span>(e));
} <span style="color: #859900;">catch</span> (<span style="color: #b58900;">Throwable</span> <span style="color: #268bd2;">t2</span>) {

} <span style="color: #859900;">finally</span> {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Try everything to make sure this process goes away.</span>
    Process.killProcess(Process.myPid());
    System.exit(10);
}
</pre>
</div>
<p>
可见, 在 killProcess 之前, AMS.handleApplicationCrash 会被调用, 而
handleApplicationCrash 会调用某些 controller 例如 monkey 的相应代码,
在进程被 kill 之前打印出异常的信息. 
</p>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> 程序中生成 c++ trace</h3>
<div class="outline-text-3" id="text-1-10">
<p>
C++也是支持异常处理的，异常处理库中，已经包含了获取backtrace的接口，
Android也是利用这个接口来打印堆栈信息的。在Android的C++中，已经集成了一
个工具类CallStack，在libutils.so中。使用方法：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #cb4b16;">#include</span> <span style="color: #2aa198;">&lt;utils/CallStack.h&gt;</span>  
<span style="color: #b58900;">CallStack</span> <span style="color: #268bd2;">stack</span>;  
stack.update();  
stack.dump();
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> 程序中使用 libcorkscrew 生成 c trace</h3>
<div class="outline-text-3" id="text-1-11">
<p>
<a href="http://blog.csdn.net/freshui/article/details/9456889">http://blog.csdn.net/freshui/article/details/9456889</a>
</p>

<p>
实际上 debuggerd 就是用 libcorkscrew 生成的 c trace
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #cb4b16;">#define</span> <span style="color: #268bd2;">MAX_DEPTH</span>                       31  
<span style="color: #cb4b16;">#define</span> <span style="color: #268bd2;">MAX_BACKTRACE_LINE_LENGTH</span>   800  
<span style="color: #cb4b16;">#define</span> <span style="color: #268bd2;">PATH</span> <span style="color: #2aa198;">"/system/lib/libcorkscrew.so"</span>  

<span style="color: #859900;">typedef</span> <span style="color: #b58900;">ssize_t</span> (*<span style="color: #b58900;">unwindFn</span>)(<span style="color: #b58900;">backtrace_frame_t</span>*, <span style="color: #b58900;">size_t</span>, <span style="color: #b58900;">size_t</span>);  
<span style="color: #859900;">typedef</span> <span style="color: #b58900;">void</span> (*<span style="color: #b58900;">unwindSymbFn</span>)(<span style="color: #859900;">const</span> <span style="color: #b58900;">backtrace_frame_t</span>*, <span style="color: #b58900;">size_t</span>, <span style="color: #b58900;">backtrace_symbol_t</span>*);  
<span style="color: #859900;">typedef</span> <span style="color: #b58900;">void</span> (*<span style="color: #b58900;">unwindSymbFreeFn</span>)(<span style="color: #b58900;">backtrace_symbol_t</span>*, <span style="color: #b58900;">size_t</span>);  

<span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">gHandle</span> = <span style="color: #2aa198;">NULL</span>;  

<span style="color: #859900;">static</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">getCallStack</span>(<span style="color: #b58900;">void</span>){  
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">i</span> = 0;  
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">result</span> = 0;  
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">count</span>;  
    <span style="color: #b58900;">backtrace_frame_t</span> <span style="color: #268bd2;">mStack</span>[MAX_DEPTH];  
    <span style="color: #b58900;">backtrace_symbol_t</span> <span style="color: #268bd2;">symbols</span>[MAX_DEPTH];  

    <span style="color: #b58900;">unwindFn</span> <span style="color: #268bd2;">unwind_backtrace</span> = <span style="color: #2aa198;">NULL</span>;  
    <span style="color: #b58900;">unwindSymbFn</span> <span style="color: #268bd2;">get_backtrace_symbols</span> = <span style="color: #2aa198;">NULL</span>;  
    <span style="color: #b58900;">unwindSymbFreeFn</span> <span style="color: #268bd2;">free_backtrace_symbols</span> = <span style="color: #2aa198;">NULL</span>;  

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">open the so.  </span>
    <span style="color: #859900;">if</span>(gHandle == <span style="color: #2aa198;">NULL</span>) gHandle = dlopen(PATH, RTLD_NOW);  

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">get the interface for unwind and symbol analyse  </span>
    <span style="color: #859900;">if</span>(gHandle != <span style="color: #2aa198;">NULL</span>) unwind_backtrace = (<span style="color: #b58900;">unwindFn</span>)dlsym(gHandle, <span style="color: #2aa198;">"unwind_backtrace"</span>);  
    <span style="color: #859900;">if</span>(gHandle != <span style="color: #2aa198;">NULL</span>) get_backtrace_symbols = (<span style="color: #b58900;">unwindSymbFn</span>)dlsym(gHandle, <span style="color: #2aa198;">"get_backtrace_symbols"</span>);  
    <span style="color: #859900;">if</span>(gHandle != <span style="color: #2aa198;">NULL</span>) free_backtrace_symbols = (<span style="color: #b58900;">unwindSymbFreeFn</span>)dlsym(gHandle, <span style="color: #2aa198;">"free_backtrace_symbols"</span>);  

    <span style="color: #859900;">if</span>(<span style="color: #dc322f;">!</span>gHandle ||<span style="color: #dc322f;">!</span>unwind_backtrace ||<span style="color: #dc322f;">!</span>get_backtrace_symbols || <span style="color: #dc322f;">!</span>free_backtrace_symbols  ){  
        ALOGE(<span style="color: #2aa198;">"Error! cannot get unwind info: handle:%p %p %p %p"</span>,  
              gHandle, unwind_backtrace, get_backtrace_symbols, free_backtrace_symbols );  
        <span style="color: #859900;">return</span> result;  
    }  

    count= unwind_backtrace(mStack, 1, MAX_DEPTH);  
    get_backtrace_symbols(mStack, count, symbols);  

    <span style="color: #859900;">for</span> (i = 0; i &lt; count; i++) {  
        <span style="color: #b58900;">char</span> <span style="color: #268bd2;">line</span>[MAX_BACKTRACE_LINE_LENGTH];  

        <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">mapName</span> = symbols[i].map_name ? symbols[i].map_name : <span style="color: #2aa198;">"&lt;unknown&gt;"</span>;  
        <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">symbolName</span> =symbols[i].demangled_name ? symbols[i].demangled_name : symbols[i].symbol_name;  
        <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">fieldWidth</span> = (MAX_BACKTRACE_LINE_LENGTH - 80) / 2;  

        <span style="color: #859900;">if</span> (symbolName) {  
            <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">pc_offset</span> = symbols[i].relative_pc - symbols[i].relative_symbol_addr;  
            <span style="color: #859900;">if</span> (pc_offset) {  
                snprintf(line, MAX_BACKTRACE_LINE_LENGTH, <span style="color: #2aa198;">"#%02d  pc %08x  %.*s (%.*s+%u)"</span>,  
                         i, symbols[i].relative_pc, fieldWidth, mapName,  
                         fieldWidth, symbolName, pc_offset);  
            } <span style="color: #859900;">else</span> {  
                snprintf(line, MAX_BACKTRACE_LINE_LENGTH, <span style="color: #2aa198;">"#%02d  pc %08x  %.*s (%.*s)"</span>,  
                         i, symbols[i].relative_pc, fieldWidth, mapName,  
                         fieldWidth, symbolName);  
            }  
        } <span style="color: #859900;">else</span> {  
            snprintf(line, MAX_BACKTRACE_LINE_LENGTH, <span style="color: #2aa198;">"#%02d  pc %08x  %.*s"</span>,  
                     i, symbols[i].relative_pc, fieldWidth, mapName);  
        }  

        ALOGD(<span style="color: #2aa198;">"%s"</span>, line);  
    }  

    free_backtrace_symbols(symbols, count);  

    <span style="color: #859900;">return</span> result;  
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> debuggerd</h3>
<div class="outline-text-3" id="text-1-12">
<p>
以 abort 和 segment fault 为例, 说明 debuggerd 的工作过程.
</p>
</div>
<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1"><span class="section-number-4">1.12.1</span> segment fault</h4>
<div class="outline-text-4" id="text-1-12-1">
<ol class="org-ol">
<li>当程序中执行到类似于 <b>((char</b>)0) = 'a' 的指令时, 会发生 SIG<sub>SEGV</sub> 信号
</li>
<li>debuggerd.cpp 中的 debuggerd<sub>signal</sub><sub>handler</sub> 负责拦截这个信号, 并向
debuggerd 发送 request, request 中包括以下内容:
<ol class="org-ol">
<li>当前线程的 tid, 表示哪个线程发生了异常, 后续 debuggerd 会通过
ptrace  attach 到这个 tid 上来打印该 tid 相关的信息 (tombstone)
</li>
<li>request 的类型, 此处为 DEBUGGER<sub>ACTION</sub><sub>CRASH</sub>
</li>
<li>abortMessage ()
</li>
</ol>
<p>
值得注意的是这里并不包括 signal 号, 而且 request 中虽然不包括 pid,
uid 信息, 但 debuggerd 可能通过 socket 的 getsockopt 获得 pid, uid.
</p>
</li>
<li>debuggerd 发送完 request 后, 在 socket 上通过 read 阻塞, 等待
debuggerd 的反馈.
</li>
<li>debuggerd 通过 handle<sub>request</sub> 以及 read<sub>request</sub> 获得 request 信息.
</li>
<li>debuggerd 通过 ptrace(PTRACE<sub>ATTACH</sub>, request.tid, 0, 0) attach 到
tid 上.  tid 被 attach 后, 还会正常执行 (不会暂停), 但当它调用系统调
用前会先通知 debuggerd, 或收到信号时也会通知 debuggerd, 而不会再对这
些信号进行进行处理 (exit, core , 忽略或任何自定义动作), ptrace 本身
会对 pid 发送一个 SIG<sub>STOP</sub> 信号
</li>
<li>debuggerd 通过 write(fd, "\0", 1) 使 tid 的 signal handler 继续执行
</li>
<li>tid 收到 debuggerd 的反馈后会调用 signal(n, SIG<sub>DFL</sub>). 然后对于
SIG<sub>ABRT</sub> 等信号, 会重新发送一次. 但对于 SIG<sub>SEGV</sub> 没有重新发送.
</li>
<li>debuggerd 通过 wait<sub>for</sub><sub>signal</sub> 等待 tid 上报一个信号.
</li>
<li>debuggerd 会收到第 5 步 ptrace attach 中发送的 SIG<sub>STOP</sub> 信号. 通过
这个信号, debuggerd 可以确保 tid 已经被 attach.
</li>
<li>debuggerd 通过 ptrace(PTRACE<sub>CONT</sub>, request.tid, 0, 0) 使 tid 继续
执行.
</li>
<li>因为之前的 SIG<sub>SEGV</sub> 被拦截, 导致 tid 继续执行时会再次发出 SIG<sub>SEGV</sub>
</li>
<li>第 8 步的 wait<sub>for</sub><sub>signal</sub> 收到第二次的 SIG<sub>SEGV</sub> 信号, 开始 dump
tombstone 信息
</li>
<li>dump 完成后, debuggerd 通过 ptrace(PTRACE<sub>DETACH</sub>) 从 tid detach,
tid 继续运行, debuggerd 部分功能到底结束.
</li>
<li>tid 继续运行, 会第三次发出 SIG<sub>SEGV</sub>, 这个信息会最终导致 coredump
及进程退出. 
</li>
</ol>

<p>
总结:
发生 SIG<sub>SEGV</sub> 时, 需要应用程序一共发生三次 SIG<sub>SEGV</sub> 才能最终退出. 
</p>
<ol class="org-ol">
<li>第一次, 通知 debuggerd
</li>
<li>第二次, 通知 debuggerd 的 wait<sub>for</sub><sub>signal</sub>, 进行 tombstone 的 dump
</li>
<li>第三次导致应用异常退出
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-12-2" class="outline-4">
<h4 id="sec-1-12-2"><span class="section-number-4">1.12.2</span> abort</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
abort 与 segment fault 不同, 它不是由于执行了非法指令导致的, 所以它不
会像 segment fault 那样重复的发出 SIG<sub>SEGV</sub> 信号. 
</p>

<p>
abort() 是 libc 中的一个函数, 它的实现大约是这样的:
</p>
<div class="org-src-container">

<pre class="src src-text">kill(pid, SIG_ABRT);
signal(SIG_ABRT, SIG_DFL);
kill(pid, SIG_ABRT);
</pre>
</div>
<p>
即它会发两次 SIG<sub>ABRT</sub> 而且第二次会强制的忽略任何 signal handler.
</p>

<p>
abort 与 segment fault 不同的地方在于:
</p>
<ol class="org-ol">
<li>第七步中, debugger.cpp 会再发一次 SIG<sub>ABRT</sub>, 这个信号的作用相当于第二次 SIG<sub>SEGV</sub>
</li>
<li>第十四步中, abort 函数会发出第二次 SIG<sub>ABRT</sub> (相当于第三次 SIG<sub>SEGV</sub>), 导致进程退出.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> valgrind</h3>
<div class="outline-text-3" id="text-1-13">
<p>
android 中可以使用 valgrind 启动 apk 应用, 进而检查 memory leak, call
graph 等.
</p>

<p>
但是 apk 应用都是通过 zygote 启动的, valgrind 如何能起作用? 
</p>

<p>
答案就是当 zygote 收到 apk 启动的请求后, 会直接用 exec 启动 valgrind,
然后在 valgrind 中再启动一个新的 app<sub>process</sub> 来启动 apk 应用. 
</p>

<p>
所以通过 valgrind 启动的应用实际上与 zygote 没有任何关联了, 也无法利用
zygote 带来的好处, 例如 preload.
</p>
</div>

<div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1"><span class="section-number-4">1.13.1</span> WrapperInit</h4>
<div class="outline-text-4" id="text-1-13-1">
<p>
上面提到的逻辑主要包含在 WrapperInit.java 及 ZygoteConnection.java 中,
这两个配合以解决 apk 应用由 zygote fork 导致无法启动 valgrind 的问题. 
</p>

<p>
如果要测试的程序完全是一个可以通过 dalvikvm 或 app<sub>process</sub> 启动的 java
程序, 则直接在 shell 中通过 valgrind 启动就行了, 不用麻烦 WrapperInit
和 ZygoteConnection.
</p>
</div>
</div>
<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2"><span class="section-number-4">1.13.2</span> 脚本</h4>
<div class="outline-text-4" id="text-1-13-2">
<p>
start<sub>valgrind</sub>.sh
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">!/system/bin/</span><span style="color: #859900;">sh</span>

<span style="color: #268bd2;">PACKAGE</span>=<span style="color: #2aa198;">"com.android.calendar"</span>

<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Callgrind tool</span>
<span style="color: #268bd2;">VGPARAMS</span>=<span style="color: #2aa198;">'-v --error-limit=no --trace-children=yes --log-file=/sdcard/valgrind.log.%p --tool=callgrind --callgrind-out-file=/sdcard/callgrind.out.%p'</span>

<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Memcheck tool</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">VGPARAMS='-v --error-limit=no --trace-children=yes --log-file=/sdcard/valgrind.log.%p --tool=memcheck --leak-check=full --show-reachable=yes'</span>

<span style="color: #859900;">export</span> <span style="color: #268bd2;">TMPDIR</span>=/data/data/$<span style="color: #268bd2;">PACKAGE</span>

<span style="color: #859900;">exec</span> /system/bin/valgrind $<span style="color: #268bd2;">VGPARAMS</span> $<span style="color: #268bd2;">*</span>
</pre>
</div>

<p>
valgrind<sub>calendar</sub>.sh
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">!/usr/bin/</span><span style="color: #859900;">env</span><span style="color: #586e75; font-style: italic;"> bash</span>

<span style="color: #268bd2;">PACKAGE</span>=<span style="color: #2aa198;">"com.android.calendar"</span>

adb push start_valgrind.sh /data/local/
adb shell chmod 777 /data/local/start_valgrind.sh 

adb root
adb shell setprop wrap.$<span style="color: #268bd2;">PACKAGE</span> <span style="color: #2aa198;">"/data/local/start_valgrind.sh"</span>

<span style="color: #859900;">echo</span> <span style="color: #2aa198;">"wrap.$PACKAGE: $(</span><span style="color: #fa8072;">adb</span><span style="color: #2aa198;"> shell getprop wrap.$PACKAGE)"</span>

adb shell am force-stop $<span style="color: #268bd2;">PACKAGE</span>
adb shell am start -a android.intent.action.MAIN -n $<span style="color: #268bd2;">PACKAGE</span>/.AllInOneActivity
</pre>
</div>

<p>
测试是执行 valgrind<sub>calendar</sub>.sh 来测试 com.android.calendar 这个
apk. 
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-09-26 Fri 10:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.50.4 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
