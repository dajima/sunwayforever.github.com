<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ActivityManagerService</title>
<!-- 2014-01-30 Thu 13:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ActivityManagerService</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. ActivityManagerService</a>
<ul>
<li><a href="#sec-1-1">1.1. Intent and IntentFilter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="intent">intent</span></span></a></li>
<li><a href="#sec-1-2">1.2. Activity&#xa0;&#xa0;&#xa0;<span class="tag"><span class="activity">activity</span></span></a></li>
<li><a href="#sec-1-3">1.3. Service&#xa0;&#xa0;&#xa0;<span class="tag"><span class="service">service</span></span></a></li>
<li><a href="#sec-1-4">1.4. Broadcast&#xa0;&#xa0;&#xa0;<span class="tag"><span class="broadcast">broadcast</span></span></a></li>
<li><a href="#sec-1-5">1.5. ProcessRecord</a></li>
<li><a href="#sec-1-6">1.6. AppDeathRecipient</a></li>
<li><a href="#sec-1-7">1.7. ActivityThread</a></li>
<li><a href="#sec-1-8">1.8. misc</a></li>
<li><a href="#sec-1-9">1.9. What's the `system` process?</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> ActivityManagerService</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Intent and IntentFilter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="intent">intent</span></span></h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Intent.setPackage(pkg)</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
only match Activities in this `pkg`
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Intent.component</h4>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> IntentFilter.priority</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
candidates ARE sorted by IntentFilter.priority when resolving intent, but
</p>
<ul class="org-ul">
<li>when resolve activity, ResolveActivity will reorder candidates in alphabet order&#x2026;.so nothing
</li>
<li>when resolve service, only candidate with the highest priority are selected
</li>
<li>when resolve broadcast, candidate priority are considered for OrderedBroadcast
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> IntentFilter matching</h4>
<div class="outline-text-4" id="text-1-1-4">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2011-01-19 Wed 16:07]</span></span>
</li>
</ul>
<p>
how startActivity(or startService, sendBrocast) use Intent.{category,action,data} to find the correct intent receiver?
AMS use <i>PackageManager</i> to resolve intent to get intent's component
</p>
</div>
<div id="outline-container-sec-1-1-4-1" class="outline-5">
<h5 id="sec-1-1-4-1"><span class="section-number-5">1.1.4.1</span> startActivity</h5>
<div class="outline-text-5" id="text-1-1-4-1">
<div class="org-src-container">

<pre class="src src-text">AMS:startActivity()
    AMS:startActivityMayWait()
        PM:resolveIntent()
            PM:queryIntentActivities()
                // explicit intent
                if (intent.getCommponent())
                    return the component
                // implicit intent
                if (intent.getPackage()==null)
                    PM:mActivities.queryIntent()
                        foreach activity:
                          buildResolveList()
                             foreach IntentFilter:
                               filter.match()
                               make sure filter has DEFAULT category
                else
                    PM:mActivities.queryIntentForPackage()
                      foreach activity:
                          buildResolveList()
                             foreach IntentFilter:
                               filter.match()
                               make sure filter has DEFAULT category
            PM:chooseBestActivity()
                // candidates here are sorted by [[IntentFilter.priority][IntentFilter.priority]]
                if (candidates.size() == 1)
                    return it;
                if we have saved a preference for a preferred activity
                    return findPreferredActivity()
                else
                    return ResolverActivity // although candidates are sorted by IntentFilter.priority, ResolverActivity will
                                            // reorder them in alphabet order...weired~~
        Intent.setComponent()
        AMS:startActivityLocked()
          checkComponentPermission();
        ...
</pre>
</div>
<ul class="org-ul">
<li>PM:resolveIntent
when PackagetManager need to detect whether there are activities in a certain package matching the Intent, it will resolve the inent as:
<ol class="org-ol">
<li>PM calls queryIntentForPackage, which will take a List of activities in the package as param
</li>
<li>for every activity, call buildResolveList, which take a List of all IntentFilters of the activity as param
</li>
<li>for every IntentFilter, call filter.match( intent.getAction(), resolvedType, scheme, intent.getData(), categories, TAG); to determine whether
the IntentFilter matches the Intent, if so, add the activity to the candidates.  Note that categories is a list of Category in the intent, since
intent can call addCategory() to add serveral categories requirement
</li>
<li>filter.match() will check
<ol class="org-ol">
<li>action
intent action mustn't be null and must be in the IntentFilter's actions list
</li>
<li>data
data must be a subset of IntentFilter's data list
</li>
<li>category
if intent's categories is a subset of filter's categories, or intent's category is null , return ok
</li>
</ol>
</li>
<li>if filter.match() match, there is still one last check:
<ol class="org-ol">
<li>if the defaultOnly flag is set (in fact, startActivity will always set the flag when resolveIntent), and the candidate intentFilter also
has the DEFAULT category, returns ok.  this is just as if the Intent has added the DEFAULT category by default. BUT, since it is restriction
imposed by AMS, we can't override the behaviour by calling intent.removeCategory(DEFAULT)
</li>
<li>note: the DEFAULT<sub>ONLY</sub> flag and intentFilter's default category is mainly used by startActivity, use PM standalone (e.g. resolveActivity) doesn't
impose this restriction.
</li>
</ol>
</li>
</ol>
</li>
<li>PM:chooseBestActivity
after PM:resolveIntent, a list of candidates are available, PM will choose the best activity
<ol class="org-ol">
<li>if there is only ONE candidates, return it
</li>
<li>else, call findPreferredActivity to find if we have saved a preference for a preferred activity for this intent
</li>
<li>else, return a ResolverActivity, which will show a ResolverActivity and promp user for the prefered activity. ResolverActivity will sort candidates
in alphabet order, regardless of IntentFilter's priority.
</li>
</ol>
</li>
<li>At last, if PM returns a ResolverActivity, AMS will actually start ResolverActivity, ResolverActivity's onClick will call startActivity() to start the real user prefered activity.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-4-2" class="outline-5">
<h5 id="sec-1-1-4-2"><span class="section-number-5">1.1.4.2</span> startService</h5>
<div class="outline-text-5" id="text-1-1-4-2">
<pre class="example">
AMS:startServiceLocked()
  AMS:retrieveServiceLocked()
      if ret=mServicesByIntent.get(intent)
          return ret; //      * All currently running services indexed by the Intent used to start them.
      else
          PM:resolveService()  // just like resolveActivity
              PM:queryIntentServices()
                  if intent.getComponent()
                      use it;
                  else
                      PM:queryIntent() // return a list of candidates, note that the list is sorted according to [[IntentFilter.priority][IntentFilter.priority]]
              if candidates&gt;1      // more than ONE candidate
                  use candidate.get(0)  // pick the first one. because the candidates are sorted according
                                           // to IntentFilter.priority, so the candidate with the highest priority is selected.
      checkComponentPermission()
</pre>
</div>
</div>
<div id="outline-container-sec-1-1-4-3" class="outline-5">
<h5 id="sec-1-1-4-3"><span class="section-number-5">1.1.4.3</span> sendBroadcast</h5>
<div class="outline-text-5" id="text-1-1-4-3">
<p>
just as startService, priority are considered, and a list of all candidates are return to support OrderedBroadcast
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Activity&#xa0;&#xa0;&#xa0;<span class="tag"><span class="activity">activity</span></span></h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> AMS side</h4>
<div class="outline-text-4" id="text-1-2-1">
</div><div id="outline-container-sec-1-2-1-1" class="outline-5">
<h5 id="sec-1-2-1-1"><span class="section-number-5">1.2.1.1</span> finishedActivityLocked</h5>
<div class="outline-text-5" id="text-1-2-1-1">
<p>
finishCurrentActivity eventually will not stop and destroy activity at
once, it will pose it in an array, when idle, it will call
activityIdle to purge the activities.
</p>

<p>
When is idle? There are 2 scen:
</p>
<ol class="org-ol">
<li>thread.scheduleResumeActivity will pose one 'Idler' in the msg queue after onResume is finished. Idler will invoke AMS.activityIdle
</li>
</ol>
<p>
2)AMS is smart enough to pose on one delayed IDLE<sub>TIMEOUT</sub><sub>MSG</sub> to the handler in case there is no Idler since onResume hangs. The delayed timeout is 10s.
</p>

<p>
That is, onStop and onDestroy may be delayed for 10s after another activity's onResume is called.
11/23/10 11:40 am
finishActivityLocked
startPausing
</p>

<p>
&#x2026;
</p>

<p>
activityPaused
finishCurrentActivity &#x2013;&gt; mark the activity for destroy
resumeTopActivity
&#x2026;
activity resumed &#x2013;&gt; pose idler timer to destroy activity marked befored
</p>

<p>
11/17/10 6:46 pm
assume that when A is finished and B will be resumed: first, A is paused, then B is resumed, and A is stopped and destroyed at last
</p>


<p>
11/17/10 6:37 pm
To prevent if activity.onPause doesn't return in a period of time(500ms), AMS will call sendMessageDelayed() in startPausingLocked() to send itself one PAUSE<sub>TIMEOUT</sub> msg to force itself call activityPaused().
</p>

<p>
That is, although activity.onPause() may block, AMS is assured to resume        next activity in 500ms.
</p>


<ol class="org-ol">
<li>activity.finish() will call AMS's finishActivity() through
AIDL, providing activity's IBinder as parameter so that AMS
can recognize the corresponding HistoryRecord in AMS.
</li>

<li>AMS calls
</li>
</ol>
<p>
finishActivityLocked()
startPausingLocked()
thread.schedulePauseActivity()
</p>

<ol class="org-ol">
<li>thread.schedulePauseActivity() will call activity.onPause(),
then notify AMS that activity is paused through
AMS.activityPaused()
</li>

<li>activityPaused()
</li>
</ol>
<p>
completePauseActivity()
mark activity for stop when idle
resumeTopActivity()
</p>
</div>
</div>
<div id="outline-container-sec-1-2-1-2" class="outline-5">
<h5 id="sec-1-2-1-2"><span class="section-number-5">1.2.1.2</span> attachApplication</h5>
<div class="outline-text-5" id="text-1-2-1-2">
<p>
attachApplication is the 3rd step to start a new
activity. (1. startPausing, 2. activityPaused.)
</p>

<p>
When one new activityThread is created, after calling onCreate,
activityThread will invoke AMS.attachApplication to notify AMS that
process is OK, then AMS can call realStartActivity to launch the
activity.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-1-3" class="outline-5">
<h5 id="sec-1-2-1-3"><span class="section-number-5">1.2.1.3</span> bindApplication</h5>
<div class="outline-text-5" id="text-1-2-1-3">
<p>
AMS 使用 thread.bindApplication 告诉新建立的 activityThread 应该 "bind"
到哪个 application. 任何一个 ActivityThread 在刚启动时(通过 main) 时并
不知道它和哪个 application (apk) 相关的, 只有
AMS::thread.bindApplication 之后, ActivityThread 才和某个 app 相关, 通
过 ps 或 ddms 看这个进程的名字都会显示 app 相关的名字.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-1-4" class="outline-5">
<h5 id="sec-1-2-1-4"><span class="section-number-5">1.2.1.4</span> activityPaused</h5>
<div class="outline-text-5" id="text-1-2-1-4">
<p>
activityPaused is called by ActivityThread to notity AMS that the
mResumed activity is paused(or onPause is timeout)
</p>

<p>
after that, if prev should be finished (when finish activity), it will
call finishCurrentActivity to finish prev activity. Then
resumeTopActivity will be called again to really resume another
activity.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-1-5" class="outline-5">
<h5 id="sec-1-2-1-5"><span class="section-number-5">1.2.1.5</span> startActivityLocked</h5>
<div class="outline-text-5" id="text-1-2-1-5">
<p>
11/22/10 2:08 pm
AMS.startActivityLocked() is the very begining  entry to start activity.
</p>

<p>
Stack trace:
AMS side:
</p>
<pre class="example">
startActivity
  startActivityUnchecked
     moveTaskToFront
        finishTaskMoved
            resumeTopActivity
</pre>

<p>
when resumeTopActivity, it will firstly call startPausing to pause mResumedActivity A.
</p>

<p>
after A's onPause return, ActivityThread will notify AMS through AMS.ActivityPaused, which will then call resumeTopActivity again to resume  activity.
</p>

<p>
When invoked for the 2nd time, it will try call r.app.thread.scheduleResumeActivity to resume our activity,  then return. but before calling onResume, AMS
will firstly invoke mWindowManager.setAppVisibility(next, true) if the activity is invisible, which will call onRestart and onStart before onResume.
</p>

<p>
If exception occurs, it means the activity is already finished, or it's process is not started at all, it will call
</p>
<pre class="example">
startSpecificActivityLocked,
  realStartActivityLocked
    thread.scheduleLaunchActivity

or
startSpecificActivityLocked,
  startProcessLocked
</pre>

<p>
for the 2nd scenero, when activityThread is started in
startProcessLocked, it will call AMS.attachApplication to notify AMS
that the process is ready, attachApplication will then call
realStartActivity again to real kaunch the activity.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-1-6" class="outline-5">
<h5 id="sec-1-2-1-6"><span class="section-number-5">1.2.1.6</span> resumeTopActivityLocked</h5>
<div class="outline-text-5" id="text-1-2-1-6">
<p>
resumeTopActivity will firstly call startPausing to pause the
mResumedActivity, then return directory.
</p>

<p>
When mResumedActivity is paused or timeout (500ms), AMS.activityPaused
will be called, which will invoke resumeTopActivity again to finally
resume(or launch) the activity.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-1-7" class="outline-5">
<h5 id="sec-1-2-1-7"><span class="section-number-5">1.2.1.7</span> Timeout</h5>
<div class="outline-text-5" id="text-1-2-1-7">
</div><ol class="org-ol"><li>Pause timeout<br  /></li>
<li>Idle timeout<br  /><div class="outline-text-6" id="text-1-2-1-7-2">
<p>
idle timeout is the timeout to stop and destroy activity A after
activity B is resumed. in the normal case, B's scheduleResumeActivity
will pose an Idler after onResume to ensure that A will be finish via
activityIdle. Howerer, if B's onResume hangs, a delay IDLE<sub>TIMEOUT</sub><sub>MSG</sub>
is a must for AMS to make sure A will be finished in 10s.
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-2-1-8" class="outline-5">
<h5 id="sec-1-2-1-8"><span class="section-number-5">1.2.1.8</span> HistoryRecord</h5>
<div class="outline-text-5" id="text-1-2-1-8">
<p>
HistoryRecord is used in two ways:
</p>
<ul class="org-ul">
<li>it is the shadow structure of `Activity` in AMS
</li>
<li>it is used as a IBinder token by AMS, e.g. when AMS want to resume activity, it will send the activity's corresponding HistoryRecord as a token to
ActivityThread, so that ActivityThread knows which activity to resume.
<ul class="org-ul">
<li>r.app.thread
</li>
<li>r.resultRecord
</li>
<li>r.sourceRecord
</li>
<li>r.intent
</li>
</ul>
</li>
</ul>
</div>
<ol class="org-ol"><li>AMS.mHistory stores all the HistoryRecord of AMS.<br  /></li></ol>
</div>

<div id="outline-container-sec-1-2-1-9" class="outline-5">
<h5 id="sec-1-2-1-9"><span class="section-number-5">1.2.1.9</span> startPausingLocked</h5>
<div class="outline-text-5" id="text-1-2-1-9">
<p>
11/22/10 6:43 pm
startPausing is called in resumeTopActivity to pause the mResumed activity before resume or launch the target activity
</p>
</div>
</div>

<div id="outline-container-sec-1-2-1-10" class="outline-5">
<h5 id="sec-1-2-1-10"><span class="section-number-5">1.2.1.10</span> startSpecificActivity</h5>
<div class="outline-text-5" id="text-1-2-1-10">
<p>
11/23/10 1:06 pm
it is called when resumeTopActivity (2nd time when prev is paused) to start (instead of resume) target activity.
</p>

<p>
It may call realStartActivity to start the activity or call startProcess to start a new process.
</p>
</div>
<ol class="org-ol"><li>startProcess<br  /></li>
<li>realStartActiviry<br  /><div class="outline-text-6" id="text-1-2-1-10-2">
<p>
11/23/10 1:10 pm
real start an activity instead of resume or start a new process.
</p>

<p>
This is called in 2 scen:
</p>
<ol class="org-ol">
<li>startSpecificActivity in resumeTopActivity
</li>
<li>attachApplication, since when attachApplication, the process
definitly exist and activity is surely not started
yet. resumeTopActivity is redunctant, calling realStartActivity is
enough.
</li>
</ol>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> ActivityThread side</h4>
<div class="outline-text-4" id="text-1-2-2">
</div><div id="outline-container-sec-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1"><span class="section-number-5">1.2.2.1</span> ActivityRecord</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<p>
ActivityRecord will save the real Activity instance and some other
info.  It corresponds to AMS::HistoryRecord. ActivityRecord use one
Map&lt;IBinder,ActivityRecord&gt; to save process's all activities.
</p>

<p>
Evey ActivityThread.scheduleXxx () takes an 'Token' (an IBinder) as
para so that ActivityThread can get the corres ActivityRecord from the
map.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-2-2" class="outline-5">
<h5 id="sec-1-2-2-2"><span class="section-number-5">1.2.2.2</span> IApplicationThread</h5>
<div class="outline-text-5" id="text-1-2-2-2">
</div><ol class="org-ol"><li>schedulePausingActivity<br  /><div class="outline-text-6" id="text-1-2-2-2-1">
<p>
schedulePausingActivity will firstly call activity.onPaused, and wait for
return, then it will notify AMS through AMS.activityPaused that the
activity is paused.
</p>
</div>
</li>

<li>scheduleResumeActivity<br  /><div class="outline-text-6" id="text-1-2-2-2-2">
<p>
it will call onResume, when onResume returns, it will add one Idler to
AMS's queue, to make sure AMS will be norified when queue is idle to stop
and destroy pending need-to-finish act ivies
</p>
</div>
</li>

<li>scheduleLaunchActivity<br  /><div class="outline-text-6" id="text-1-2-2-2-3">
<p>
when called by AMS.realStartActivity, scheduleLaunchActivity will
sequencially call onCreate, onStart,
onRestoreInstanceState,onPostCreate,onResume.
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> Activity side</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>onStop, onRestart is only related to activity visibility. they
are invoked by mWindowManager.setAppVisibility() due to
visibility change.
<ul class="org-ul">
<li>onStart may be called due to visibility change or life cycle
change.
</li>
<li>onPause, onDestroy, onResume is the core concept related to
activity life cycle, they are called only when life cycle is
changed.
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-3-1" class="outline-5">
<h5 id="sec-1-2-3-1"><span class="section-number-5">1.2.3.1</span> finish</h5>
</div>
<div id="outline-container-sec-1-2-3-2" class="outline-5">
<h5 id="sec-1-2-3-2"><span class="section-number-5">1.2.3.2</span> onPause</h5>
<div class="outline-text-5" id="text-1-2-3-2">
<p>
only when starting another <b>Activity</b>, will the former activity's
onPause be called; that is, Dialog, PopupWindow will not trigger
activity's onPause
</p>
</div>
</div>
<div id="outline-container-sec-1-2-3-3" class="outline-5">
<h5 id="sec-1-2-3-3"><span class="section-number-5">1.2.3.3</span> onStop</h5>
<div class="outline-text-5" id="text-1-2-3-3">
<p>
may only be called after onPause if the paused activity is totally
invisible to the user, onStop will be called that is, if the resumed
activity is opaque, the paused activity's onStop would not be called
</p>

<p>
resumeTopActivity will call mWindowManager.setAppVisibility(prev,
false); // cause prev.onStop be called to stop prev activity
</p>
</div>
</div>
<div id="outline-container-sec-1-2-3-4" class="outline-5">
<h5 id="sec-1-2-3-4"><span class="section-number-5">1.2.3.4</span> onDestroy</h5>
</div>
<div id="outline-container-sec-1-2-3-5" class="outline-5">
<h5 id="sec-1-2-3-5"><span class="section-number-5">1.2.3.5</span> onResume</h5>
</div>
<div id="outline-container-sec-1-2-3-6" class="outline-5">
<h5 id="sec-1-2-3-6"><span class="section-number-5">1.2.3.6</span> onRestart</h5>
<div class="outline-text-5" id="text-1-2-3-6">
<p>
resumeTopActivity will cal  mWindowManager.setAppVisibility(next, true);  // cause next.onRestart and next.onStart be called
to call onRestart and onStart
</p>
</div>
</div>

<div id="outline-container-sec-1-2-3-7" class="outline-5">
<h5 id="sec-1-2-3-7"><span class="section-number-5">1.2.3.7</span> onStart</h5>
</div>
<div id="outline-container-sec-1-2-3-8" class="outline-5">
<h5 id="sec-1-2-3-8"><span class="section-number-5">1.2.3.8</span> onCreate</h5>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> Task stack</h4>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> NativeActivity</h4>
</div>
<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> Activity Result</h4>
</div>

<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> PENDING Launcher</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
see also <a href="#sec-1-2-8-3">1.2.8.3</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> Task</h4>
<div class="outline-text-4" id="text-1-2-8">
</div><div id="outline-container-sec-1-2-8-1" class="outline-5">
<h5 id="sec-1-2-8-1"><span class="section-number-5">1.2.8.1</span> why relaunch an activity A from launcher will bring the task to foreground</h5>
<div class="outline-text-5" id="text-1-2-8-1">
<p>
note that: startActivity from launcher will always use Intent flags of NEW<sub>TASK</sub>
</p>

<div class="org-src-container">

<pre class="src src-java">startActivityUnchecked()
  <span style="color: #859900;">if</span> NEW_TASK &amp;&amp; ((MULTIPLE_TASK <span style="color: #b58900;">not</span> <span style="color: #268bd2;">set</span>)||...): <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">see MULTIPLE_TASK flag later, true</span>
    taskTop = findTaskLocked(intent, r.info)
      <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">findTaskLocked will return the top activity in any existing task matching the given intent</span>
      <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered</span>
      <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">How taskAffinity is null? if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null</span>

    <span style="color: #859900;">if</span> (taskTop != <span style="color: #2aa198;">null</span>): <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">there is already an existing task for the activity A, true</span>
      <span style="color: #859900;">if</span> (r.realActivity.equals(taskTop.task.realActivity)): <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">activity A is the same as the matching task's root activity, true</span>
        <span style="color: #859900;">if</span> FLAG_ACTIVITY_SINGLE_TOP is set:
          deliverNewIntentLocked(taskTop, r.intent);  <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">onNewIntent is called</span>
          resumeTopActivityLocked(<span style="color: #2aa198;">null</span>);
            mWindowManager.setAppVisibility(prev, <span style="color: #2aa198;">false</span>); <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">cause onStop be called</span>
            mWindowManager.setAppVisibility(next, <span style="color: #2aa198;">true</span>);  <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">cause onRestart and onStart be called</span>
          <span style="color: #859900;">return</span> START_DELIVERED_TO_TOP;
        <span style="color: #859900;">else</span> <span style="color: #859900;">if</span> r.intent.filterEquals(taskTop.task.intent):  <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">if activity A's calling intent is equal with the intent used to start</span>
                                                             <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">the task's root activity, intent equality will consider intent action,category,</span>
                                                             <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">data,type,component..., but *excluding any intent extra*, true</span>
          resumeTopActivity()
            <span style="color: #859900;">if</span> resumedActivity == topRunningActivity:        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">need not resume, in this case, resumedActivity is launcher, while topRunningActivity</span>
                                                             <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">is Activity A, false</span>
              <span style="color: #859900;">return</span>;
            <span style="color: #859900;">else</span>:
              pause resumeActivity and resume topRunningActivity  <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">true</span>
              mWindowManager.setAppVisibility(prev, <span style="color: #2aa198;">false</span>); <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">cause onStop be called</span>
              mWindowManager.setAppVisibility(next, <span style="color: #2aa198;">true</span>);  <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">cause onRestart and onStart be called</span>

          <span style="color: #859900;">return</span> START_TASK_TO_FRONT;                        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">move the task to foreground</span>
  <span style="color: #859900;">else</span>: <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">if NEW_TASK</span>
    <span style="color: #859900;">if</span> (top.realActivity.equals(r.realActivity)):
      <span style="color: #859900;">if</span> ((launchFlags&amp;<span style="color: #2aa198;">Intent</span>.FLAG_ACTIVITY_SINGLE_TOP) != 0
        or r.launchMode == <span style="color: #2aa198;">ActivityInfo</span>.LAUNCH_SINGLE_TOP
        or r.launchMode == <span style="color: #2aa198;">ActivityInfo</span>.LAUNCH_SINGLE_TASK):
        resumeTopActivityLocked(<span style="color: #2aa198;">null</span>);
        deliverNewIntentLocked(top, r.intent);
        <span style="color: #859900;">return</span> START_DELIVERED_TO_TOP;
    create or start <span style="color: #b58900;">the</span> <span style="color: #268bd2;">activity</span>                           <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">false</span>
</pre>
</div>

<p>
To summarize:
</p>

<p>
when relaunching an activity from launcher, because the intent used to
relaunch the activity is the same as the former task's root activity's
intent (both are MAIN &amp; LAUNCHER..), AMS will try to resume the
activity instead of relaunching it. startActivity with <b>NEW\<sub>TASK</sub></b> and
the <b>same</b> intent as the task's intent will bring the task to
foreground (through resumeTopActivity) instead of launching it. this
behavior is similar with that the task's top activity has the
SINGLE\<sub>TOP</sub> launchMode.
</p>

<p>
Note about MULTIPLE\<sub>TASK</sub> intent flag: Used in conjunction with
FLAG\<sub>ACTIVITY\</sub><sub>NEW</sub><sub>TASK</sub> to disable the behavior of bringing an
existing task to the foreground.  When set, a new task is always
started to host the Activity for the Intent, regardless of whether
there is already an existing task running the same thing.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-8-2" class="outline-5">
<h5 id="sec-1-2-8-2"><span class="section-number-5">1.2.8.2</span> startActivityUnchecked &amp; affinity, launchMode, intentFlags</h5>
<div class="outline-text-5" id="text-1-2-8-2">
<pre class="example">
01-06 15:01:48.800 E/sunway  (  383): startActivityLocked for Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.android.settings/.Settings }
01-06 15:01:48.810 E/sunway  (  383): startActivityUncheckedLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.810 E/sunway  (  383): startActivityLocked:ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.810 E/sunway  (  383): before setAppStartingWindow
01-06 15:01:48.830 E/sunway  (  383): after setAppStartingWindow
01-06 15:01:48.830 E/sunway  (  383): resumeTopActivityLocked: next is ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.840 E/sunway  (  383): start pausing for ActivityRecord{41aabee0 com.android.launcher/com.android.launcher2.Launcher}
01-06 15:01:48.950 E/sunway  (  383): activity paused
01-06 15:01:48.950 E/sunway  (  383): resumeTopActivityLocked: next is ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.950 E/sunway  (  383): resumeTopActivityLocked: really resume
01-06 15:01:48.950 E/sunway  (  383): startSpecificActivityLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.950 E/sunway  (  383): startProcessLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.050 E/sunway  (  383): resumeTopActivityLocked: next is ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.050 E/sunway  (  383): resumeTopActivityLocked: really resume
01-06 15:01:49.050 E/sunway  (  383): startSpecificActivityLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.050 E/sunway  (  383): startProcessLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.100 E/sunway  (  383): attachApplicationLocked for 1480
01-06 15:01:49.100 E/sunway  (  383): realStartActivityLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.100 E/sunway  (  383): scheduleLaunchActivity for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.140 W/asset   ( 1480): sunway: add sprd overlay package for vendor /vendor/overlay/framework/sprd-framework-res.apk
01-06 15:01:49.240 W/asset   ( 1480): sunway: add sprd overlay package for vendor /vendor/overlay/framework/sprd-framework-res.apk
</pre>

<p>
<b>FLAG\<sub>ACTIVITY\</sub><sub>NEW\</sub><sub>TASK</sub></b> is defininitly the most important property related to android task management.
</p>
</div>
<ol class="org-ol"><li>source code comment<br  /><div class="outline-text-6" id="text-1-2-8-2-1">
<pre class="example">
private final int startActivityUncheckedLocked(HistoryRecord r,
          HistoryRecord sourceRecord, Uri[] grantedUriPermissions,
          int grantedMode, boolean onlyIfNeeded, boolean doResume) {
      Slog.e("sunway","flag");
      final Intent intent = r.intent;
      final int callingUid = r.launchedFromUid;
      int launchFlags = intent.getFlags();

      // We'll invoke onUserLeaving before onPause only if the launching
    // activity did not explicitly state that this is an automated launch.
    mUserLeaving = (launchFlags&amp;Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
    if (DEBUG_USER_LEAVING) Slog.v(TAG,
            "startActivity() =&gt; mUserLeaving=" + mUserLeaving);

    // If the caller has asked not to resume at this point, we make note
    // of this in the record so that we can skip it when trying to find
    // the top running activity.
    if (!doResume) {
        r.delayedResume = true;
    }

    HistoryRecord notTop = (launchFlags&amp;Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP)
            != 0 ? r : null;

    // If the onlyIfNeeded flag is set, then we can do this if the activity
    // being launched is the same as the one making the call...  or, as
    // a special case, if we do not know the caller then we count the
    // current top activity as the caller.
    if (onlyIfNeeded) {
        HistoryRecord checkedCaller = sourceRecord;
        if (checkedCaller == null) {
            checkedCaller = topRunningNonDelayedActivityLocked(notTop);
        }
        if (!checkedCaller.realActivity.equals(r.realActivity)) {
            // Caller is not the same as launcher, so always needed.
            onlyIfNeeded = false;
        }
    }

    if (grantedUriPermissions != null &amp;&amp; callingUid &gt; 0) {
        for (int i=0; i&lt;grantedUriPermissions.length; i++) {
            grantUriPermissionLocked(callingUid, r.packageName,
                    grantedUriPermissions[i], grantedMode, r);
        }
    }

    grantUriPermissionFromIntentLocked(callingUid, r.packageName,
            intent, r);

    if (sourceRecord == null) {
        // This activity is not being started from another...  in this
        // case we -always- start a new task.
        if ((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
            Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "
                  + intent);
            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        }
    } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
        // The original activity who is starting us is running as a single
        // instance...  this new activity it is starting must go on its
        // own task.
        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
        // The activity being started is a single instance...  it always
        // gets launched into its own task.
        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    }

    if (r.resultTo != null &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        // For whatever reason this activity is being launched into a new
        // task...  yet the caller has requested a result back.  Well, that
        // is pretty messed up, so instead immediately send back a cancel
        // and let the new task continue launched as normal without a
        // dependency on its originator.
        Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");
        sendActivityResultLocked(-1,
                r.resultTo, r.resultWho, r.requestCode,
            Activity.RESULT_CANCELED, null);
        r.resultTo = null;
    }

    boolean addingToTask = false;
    if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp;
            (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
        // If bring to front is requested, and no result is requested, and
        // we can find a task that was started with this same
        // component, then instead of launching bring that one to the front.
        if (r.resultTo == null) {
            // See if there is a task to bring to the front.  If this is
            // a SINGLE_INSTANCE activity, there can be one and only one
            // instance of it in the history, and it is always in its own
            // unique task, so we do a special search.

            // sunway:
            // 对于launchMode不为SINGLE_INSTANCE的情况, taskTop是根
            // 据affinity(或activity component)查找到的已存在的task的top activity; 对于
            // SINGLE_INSTANCE的情况, taskTop为该single activity
            // Q: 系统如何在NEW_TASK时查找是否已经存在一个`密切`的task?

            HistoryRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE
                    ? findTaskLocked(intent, r.info)
                    : findActivityLocked(intent, r.info);

            // sunway:
            // 对于NEW_TASK, 已经找到一个已经存在的TASK或single instance
            // activity

            if (taskTop != null) {
                if (taskTop.task.intent == null) {
                    // This task was started because of movement of
                    // the activity based on affinity...  now that we
                    // are actually launching it, we can assign the
                    // base intent.
                    taskTop.task.setIntent(intent, r.info);
                }
                // If the target task is not in the front, then we need
                // to bring it to the front...  except...  well, with
                // SINGLE_TASK_LAUNCH it's not entirely clear.  We'd like
                // to have the same behavior as if a new instance was
                // being started, which means not bringing it to the front
                // if the caller is not itself in the front.


                HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);

                // sunway:
                // our task or single_instance activity is in background,
                // move it to front

                if (curTop.task != taskTop.task) {
                    r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
                    boolean callerAtFront = sourceRecord == null
                            || curTop.task == sourceRecord.task;

                    // sunway:
                    // 如果: 1. new task 2. task在后台 3. caller在前台 (或
                    // sourceRecord==null),则将task移到前台, 所以, 一个后台的
                    // task里的一个thread无法通过 new_task &amp;
                    // activity.startActivity将task移动到前台

                    if (callerAtFront) {
                        // We really do want to push this one into the
                        // user's face, right now.
                        moveTaskToFrontLocked(taskTop.task, r);
                    }
                }
                // If the caller has requested that the target task be
                // reset, then do so.
                if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
                    // sunway:
                    // reset task ... take a deep breath;
                    taskTop = resetTaskIfNeededLocked(taskTop, r);
                }
                if (onlyIfNeeded) {
                    // We don't need to start a new activity, and
                    // the client said not to do anything if that
                    // is the case, so this is it!  And for paranoia, make
                    // sure we have correctly resumed the top activity.
                    if (doResume) {
                        resumeTopActivityLocked(null);
                    }
                    return START_RETURN_INTENT_TO_CALLER;
                }

                if ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
                    // In this situation we want to remove all activities
                    // from the task up to the one being started.  In most
                    // cases this means we are resetting the task to its
                    // initial state.

                    // sunway:
                    // 在大多数情况下, task或single instance activity
                    // 在此之前已经被移动到前台,performClearTaskLocked只会
                    // finish该task中位于r之上的activity, 除非...移动到前台
                    // 时失败(例如callerAtFront为假,这时会有意想不到的效
                    // 果)

                    // sunway:
                    // performClearTaskLocked会finish位于r,top之间的所有
                    // activity,一般情况下不会finish `基准`activity (对于
                    // CLEAR_TOP,即是r,对于SINGLE_TASK,SINGLE_INSTANCE,即是
                    // task的root activity, 除非...基准activity是MULTIPLE
                    // launch mode且其SINGLE_TOP为假

                    // 总结: 对于一般的startActivity(不包含
                    // RESET_TASK_IF_NEEDED intent flag), CLEAR_TOP是可以
                    // finish某些activity的机会,如果想让一个activity在每次
                    // startActivity时finish掉之前的并create新的且只有一个实
                    // 例 (例如某些通知功能的activity),可以:
                    // 1. 使用NEW_TASK和CLEAR_TOP
                    // 2. launchMode为MULTIPLE,且SINGLE_TOP为假
                    // 3. 为防止CLEAR_TOP误杀同task的其他activity, 可以设其
                    // affinity为其他唯一值或者直接使用空串, 确保task中只有
                    // 它一个activity (类似于singleInstance)

                    // Q: 看起来start SINGLE_TASK 的 root activity 也会导致
                    // performClearTask .... 并perforClearTask并不
                    // 能保证developer中声称的SINGLE_TASK的属性:SINGLE_TASK必
                    // 须是task的root activity; 实际上这段代码的效果是: 设
                    // A,B的affinity相同, A启动B,其中B是
                    // SINGLE_TASK,则结果是A,B; B再启动A,结果A,B,A; A再启动
                    // B, 结果是A,B, 和CLEAR_TOP有啥区别?
                    // 若想达到文档中声称的SINGLE_TASK效果,必须保证B一开始就
                    // 是task的root activity.....那只能给它设一个唯一的
                    // affinity(或affinity为null)才行
                    // Q: 为什么会有这个问题?
                    // A: 相比之下,SINGLE_INSTANCE的行为是正常的,根本原因是
                    // 因为前面对taskTop的查找: 对于SINGLE_INSTANCE, 是从整
                    // 个mHistory去找唯一的一个activity实例. 而对于
                    // SINGLE_TASK, 则是从上到下根据affinity找\emph{第一个}
                    // 匹配的task, 考虑这种情况:
                    // 有A,B,C,D四个activity, 使用相同的affinity, 其中的A是
                    // SINGLE_TASK, 设当前有两个task, 'A,C,D'和'B'. 然后另外
                    // 某处startActivity(B), 假设系统找到第一个匹配的
                    // task是'A,C,D'... 是否要为B生成一个new task?
                    // 所以根本原因是task的管理还是过于简单, \emph{task的查找方法
                    // 无法满足SINGLE_TASK语义}.
                    // 做为workaround,可以通过确保SINGLE_TASK的activity为唯
                    // 一的affinity来弥补task查找方法的不足.


                    HistoryRecord top = performClearTaskLocked(
                            taskTop.task.taskId, r, launchFlags, true);

                    // sunway:
                    // 若top不为null, 说明CLEAR_TOP真的只是 `clear top`, 则需
                    // 要调用top的onNewIntent


                    if (top != null) {
                        if (top.frontOfTask) {
                            // Activity aliases may mean we use different
                            // intents for the top activity, so make sure
                            // the task now has the identity of the new
                            // intent.
                            top.task.setIntent(r.intent, r.info);
                        }
                        logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                        deliverNewIntentLocked(top, r.intent);
                    } else {
                        // sunway:
                        // 若top为null,说明CLEAR_TOP把`基准`activity也clear掉
                        // 了...这种情况的发生只有一种可能:`基准`activity是
                        // MULTIPLE &amp; SINGLE_TOP, `基准`activity被clear掉后,
                        // 需要通过addingToTask标记通知后续代码:该activity需
                        // 要重新添加一个新的实例到task中, addingToTask的意思
                        // 是:addNewInstanceToTask

                        // A special case: we need to
                        // start the activity because it is not currently
                        // running, and the caller has asked to clear the
                        // current task to have this activity at the top.
                        addingToTask = true;
                        // Now pretend like this activity is being started
                        // by the top of its task, so it is put in the
                        // right place.
                        sourceRecord = taskTop;
                    }
                } else if (r.realActivity.equals(taskTop.task.realActivity)) {
                    // sunway:
                    // 我们想要start的是task的root activity, 若使用的intent
                    // 也是相同的, 系统认为我们只是想moveTaskToFront, 所以不
                    // 生新create一个activity,则只是resume这个task的top
                    // activity.
                    // 实际上,这段代码反映的是launcher的行为: laucher每次点
                    // 击桌面图标时,对同一个图标,使用的intent是一样的,且要启
                    // 动的activity也必然是task的root activity
                    // 通过模拟launcher的这种行为,我们也可以只是将某个task移
                    // 动到前台,而不做其他任何事



                    // In this case the top activity on the task is the
                    // same as the one being launched, so we take that
                    // as a request to bring the task to the foreground.
                    // If the top activity in the task is the root
                    // activity, deliver this new intent to it if it
                    // desires.
                    if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                            &amp;&amp; taskTop.realActivity.equals(r.realActivity)) {
                        logStartActivity(EventLogTags.AM_NEW_INTENT, r, taskTop.task);
                        if (taskTop.frontOfTask) {
                            taskTop.task.setIntent(r.intent, r.info);
                        }
                        deliverNewIntentLocked(taskTop, r.intent);
                    } else if (!r.intent.filterEquals(taskTop.task.intent)) {
                        // In this case we are launching the root activity
                        // of the task, but with a different intent.  We
                        // should start a new instance on top.
                        addingToTask = true;
                        sourceRecord = taskTop;
                    }
                } else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
                    // sunway:
                    // 这里基本上是NEW_TASK所判断的最后一个条件了: 若
                    // RESET_TASK_IF_NEED设置, 则addingToTask为false,阻止了
                    // 后续的处理. 效果和前面提到的launcher行为类似,但要启动
                    // 的activity不必是root activity.
                    // 一般情况下,只有launcher会使用这个标志


                    // In this case an activity is being launched in to an
                    // existing task, without resetting that task.  This
                    // is typically the situation of launching an activity
                    // from a notification or shortcut.  We want to place
                    // the new activity on top of the current task.
                    addingToTask = true;
                    sourceRecord = taskTop;
                } else if (!taskTop.task.rootWasReset) {
                    // In this case we are launching in to an existing task
                    // that has not yet been started from its front door.
                    // The current task has been brought to the front.
                    // Ideally, we'd probably like to place this new task
                    // at the bottom of its stack, but that's a little hard
                    // to do with the current organization of the code so
                    // for now we'll just drop it.
                    taskTop.task.setIntent(r.intent, r.info);
                }
                if (!addingToTask) {
                    // We didn't do anything...  but it was needed (a.k.a., client
                    // don't use that intent!)  And for paranoia, make
                    // sure we have correctly resumed the top activity.
                    if (doResume) {
                        resumeTopActivityLocked(null);
                    }
                    return START_TASK_TO_FRONT;
                }
            }
        }
    }

    // sunway:
    // finally we are here....
    // 在三种情况下代码会走到这里:
    // case 1. NEW_TASK为真, 但taskTop为null...说明现在系统里找不到一个已经存在的
    // `密切`的task, 真的需要`new`一个task了
    // case 2. NEW_TASK==true, taskTop!=null, 但addingToTask为真, 即需要在taskTop
    // 上 new activity instance
    // case 3. 根本没有指定NEW_TASK标志,新的activity使用当前的task (使用当前的
    // task并不意味着要直接new activity instance, 因为SINGLE_TOP,
    // CLEAR_TOP...还要考虑)
    //
    //
    //
    //String uri = r.intent.toURI();
    //Intent intent2 = new Intent(uri);
    //Slog.i(TAG, "Given intent: " + r.intent);
    //Slog.i(TAG, "URI is: " + uri);
    //Slog.i(TAG, "To intent: " + intent2);
    if (r.packageName != null) {
        // If the activity being launched is the same as the one currently
        // at the top, then we need to check if it should only be launched
        // once.
        HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
        if (top != null &amp;&amp; r.resultTo == null) {
            if (top.realActivity.equals(r.realActivity)) {
                if (top.app != null &amp;&amp; top.app.thread != null) {
                    // sunway:
                    // case 2,3;
                    // SINGLE_TOP并非NEW_TASK的专利
                    // A,B,C (c single top)
                    if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
                        logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);
                        // For paranoia, make sure we have correctly
                        // resumed the top activity.
                        if (doResume) {
                            resumeTopActivityLocked(null);
                        }
                        if (onlyIfNeeded) {
                            // We don't need to start a new activity, and
                            // the client said not to do anything if that
                            // is the case, so this is it!
                            return START_RETURN_INTENT_TO_CALLER;
                        }
                        deliverNewIntentLocked(top, r.intent);
                        return START_DELIVERED_TO_TOP;
                    }
                }
            }
        }

    } else {
        if (r.resultTo != null) {
            sendActivityResultLocked(-1,
                    r.resultTo, r.resultWho, r.requestCode,
                Activity.RESULT_CANCELED, null);
        }
        return START_CLASS_NOT_FOUND;
    }

    boolean newTask = false;

    // Should this be considered a new task?
    if (r.resultTo == null &amp;&amp; !addingToTask
            &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        // sunway:
        // case 1, 新建一个task, NEW_TASK

        // todo: should do better management of integers.
        mCurTask++;
        if (mCurTask &lt;= 0) {
            mCurTask = 1;
        }
        r.task = new TaskRecord(mCurTask, r.info, intent,
                (r.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
        if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
                + " in new task " + r.task);
        newTask = true;
        addRecentTaskLocked(r.task);

    } else if (sourceRecord != null) {
        if (!addingToTask &amp;&amp;
                (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
            // sunway
            // case 3;
            // CLEAR_TOP并非NEW_TASK的专利
            // 由于这里没有经过NEW_TASK的 moveToFront, 导致CLEAR_TOP更容易伤
            // 到其他task的activity

            // In this case, we are adding the activity to an existing
            // task, but the caller has asked to clear that task if the
            // activity is already running.

            HistoryRecord top = performClearTaskLocked(
                    sourceRecord.task.taskId, r, launchFlags, true);
            if (top != null) {
                logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                deliverNewIntentLocked(top, r.intent);
                // For paranoia, make sure we have correctly
                // resumed the top activity.
                if (doResume) {
                    resumeTopActivityLocked(null);
                }
                return START_DELIVERED_TO_TOP;
            }
        } else if (!addingToTask &amp;&amp;
                (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
            // sunway:

            // case 3;
            // REORDER_TO_FRONT是非NEW_TASK的专利
            // 若当前task的stack为A,B,C; C调用startActivity(B),则执行后的结
            // 果为A,C,B;
            // 即B会被reorder to front
            //
            // 到目前为止可以导致onNewIntent的标志:
            // 1. SINGLE_INSTANCE, SINGLE_TASK
            // 2. MULTIPLE &amp; SINGLE_TOP
            // 3. REORDER_TO_FRONT


            // In this case, we are launching an activity in our own task
            // that may already be running somewhere in the history, and
            // we want to shuffle it to the front of the stack if so.
            int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
            if (where &gt;= 0) {
                HistoryRecord top = moveActivityToFrontLocked(where);
                logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                deliverNewIntentLocked(top, r.intent);
                if (doResume) {
                    resumeTopActivityLocked(null);
                }
                return START_DELIVERED_TO_TOP;
            }
        }
        // An existing activity is starting this new activity, so we want
        // to keep the new one in the same task as the one that is starting
        // it.
        r.task = sourceRecord.task;
        if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
                + " in existing task " + r.task);

    } else {
        // This not being started from an existing activity, and not part
        // of a new task...  just put it in the top task, though these days
        // this case should never happen.
        final int N = mHistory.size();
        HistoryRecord prev =
            N &gt; 0 ? (HistoryRecord)mHistory.get(N-1) : null;
        r.task = prev != null
            ? prev.task
            : new TaskRecord(mCurTask, r.info, intent,
                    (r.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
        if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
                + " in new guessed " + r.task);
    }
    if (newTask) {
        EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.task.taskId);
    }
    logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);

    // sunway:
    //
    // 经过九九八十一难,到这里才真正调用onCreate;回想前面的种种, 有些
    // activity被kill掉了, 有些被移动到前台并被resume了, 能收到onNewIntent调
    // 用都算不错了; 能真正因为startActivity导致onCreate被调用的有多少?

    startActivityLocked(r, newTask, doResume);
    return START_SUCCESS;
}




ate HistoryRecord findTaskLocked(Intent intent, ActivityInfo info) {
    ComponentName cls = intent.getComponent();
    if (info.targetActivity != null) {
        cls = new ComponentName(info.packageName, info.targetActivity);
    }

    TaskRecord cp = null;

    final int N = mHistory.size();
    for (int i=(N-1); i&gt;=0; i--) {
        HistoryRecord r = (HistoryRecord)mHistory.get(i);
        if (!r.finishing &amp;&amp; r.task != cp
                &amp;&amp; r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE) {

            // sunway:
            // launchMode!=SINGLE_INSTANCE这个条件可用避免这种情况:
            // 当前mHistory对于同一个affinity有多个task (只有一种可能:一个为正常的task,
            // 其他的均为SINGLE_INSTANCE); 通过这个条件判断,可以避免findTask
            // 时找到SINGLE_INSTANCE的task (这种task即使找到也不可能往上添加
            // 其他activity, 结果还是要新建一个task, 但实际上该
            // SINGLE_INSTANCE下面明明有一个可用的`正常`task...最后会导致task越
            // 来越多)

            cp = r.task;
            //Slog.i(TAG, "Comparing existing cls=" + r.task.intent.getComponent().flattenToShortString()
            //        + "/aff=" + r.task.affinity + " to new cls="
            //        + intent.getComponent().flattenToShortString() + "/aff=" + taskAffinity);
            if (r.task.affinity != null) {
                if (r.task.affinity.equals(info.taskAffinity)) {
                    //Slog.i(TAG, "Found matching affinity!");
                    return r;
                }
            } else if (r.task.intent != null
                    &amp;&amp; r.task.intent.getComponent().equals(cls)) {
                //Slog.i(TAG, "Found matching class!");
                //dump();
                //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
                return r;
            } else if (r.task.affinityIntent != null
                    &amp;&amp; r.task.affinityIntent.getComponent().equals(cls)) {
                //Slog.i(TAG, "Found matching class!");
                //dump();
                //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
                return r;
            }
        }
    }

    return null;
}


private final HistoryRecord resetTaskIfNeededLocked(HistoryRecord taskTop,
        HistoryRecord newActivity) {
    // sunway:
    // resetTaskIfNeeded, 是RESET_TASK_IF_NEED intent flag导致的调用
    // launcher在启动activity时会使用NEW_TASK &amp; RESET_TASK_IF_NEED 标志
    // 所以该标志和launch有关, 实际上, activity的四个属性:
    // 1. CLEAR_TASK_ON_LAUNCH
    // 2. FINISH_ON_TASK_LAUNCH
    // 3. ALLOW_TASK_REPARENTING
    // 4. ALWAYS_RETAIN_TASK_STATE
    // 都只是和这个标志有关
    // 另外, CLEAR_WHEN_TASK_RESET intent flag 也只和这个标志有关.
    // Q: RESET_TASK是干什么?
    // Q: IF_NEEDED是什么意思?

    boolean forceReset = (newActivity.info.flags
            &amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;

    // sunway:
    // ACTIVITY_INACTIVE_RESET_TIME 为 30 分钟
    // 当task.getInactiveDuration &gt; 30 min时, 表示该task需要被forceReset了, 这也
    // 许就是IF_NEEDED的要表达的意思(之一)?


    if (taskTop.task.getInactiveDuration() &gt; ACTIVITY_INACTIVE_RESET_TIME) {
        if ((newActivity.info.flags
                &amp;ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
            // sunway:
            // 若root activity设置了这个属性,可以避免空闲30分钟后整个task被
            // reset (reset case 1)
            // 但对case 2,3 无效
            forceReset = true;
        }
    }

    // sunway:
    // 所谓 reset task, 是指要从当前task中找出哪些activity需要被reset
    // (finish), 主要分为三种情况:
    // case 1. 整个task的所有activity被需要被reset
    // case 2. 某个或某些activity需要被reset
    // case 3. 还要考虑更复杂的ALLOW_TASK_REPARENTING属性

    final TaskRecord task = taskTop.task;

    // We are going to move through the history list so that we can look
    // at each activity 'target' with 'below' either the interesting
    // activity immediately below it in the stack or null.
    HistoryRecord target = null;
    int targetI = 0;
    int taskTopI = -1;
    int replyChainEnd = -1;
    int lastReparentPos = -1;

    // sunway:
    // 遍历mHistory的所有activity, top --&gt; bottom

    for (int i=mHistory.size()-1; i&gt;=-1; i--) {
        HistoryRecord below = i &gt;= 0 ? (HistoryRecord)mHistory.get(i) : null;

        if (below != null &amp;&amp; below.finishing) {
            continue;
        }
        if (target == null) {
            target = below;
            targetI = i;
            // If we were in the middle of a reply chain before this
            // task, it doesn't appear like the root of the chain wants
            // anything interesting, so drop it.
            replyChainEnd = -1;
            continue;
        }

        final int flags = target.info.flags;

        // sunway:
        // 当前activity需要被finish on task launch?
        // IF_NEEDED (之二)?

        final boolean finishOnTaskLaunch =
            (flags&amp;ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
        final boolean allowTaskReparenting =
            (flags&amp;ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;

        if (target.task == task) {
            // sunway:
            // 我们只能reset要reset的task, 其他的task不能碰

            // We are inside of the task being reset...  we'll either
            // finish this activity, push it out for another task,
            // or leave it as-is.  We only do this
            // for activities that are not the root of the task (since
            // if we finish the root, we may no longer have the task!).
            if (taskTopI &lt; 0) {
                taskTopI = targetI;
            }
            if (below != null &amp;&amp; below.task == task) {
                final boolean clearWhenTaskReset =
                        (target.intent.getFlags()
                                &amp;Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
                if (!finishOnTaskLaunch &amp;&amp; !clearWhenTaskReset &amp;&amp; target.resultTo != null) {
                    // If this activity is sending a reply to a previous
                    // activity, we can't do anything with it now until
                    // we reach the start of the reply chain.
                    // XXX note that we are assuming the result is always
                    // to the previous activity, which is almost always
                    // the case but we really shouldn't count on.
                    if (replyChainEnd &lt; 0) {
                        replyChainEnd = targetI;
                    }
                } else if (!finishOnTaskLaunch &amp;&amp; !clearWhenTaskReset &amp;&amp; allowTaskReparenting
                        &amp;&amp; target.taskAffinity != null
                        &amp;&amp; !target.taskAffinity.equals(task.affinity)) {

                    // sunway:
                    // 若当前处理的activity是从别的地方`收养`的
                    // (allowTaskReparenting为真,且它的affinity和要reset的
                    // task的affinity不同), 而且它不想死,那么放了它(从哪来的
                    // 回哪去,或者自立门户)
                    //
                    //
                    // If this activity has an affinity for another
                    // task, then we need to move it out of here.  We will
                    // move it as far out of the way as possible, to the
                    // bottom of the activity stack.  This also keeps it
                    // correctly ordered with any activities we previously
                    // moved.
                    HistoryRecord p = (HistoryRecord)mHistory.get(0);
                    if (target.taskAffinity != null
                            &amp;&amp; target.taskAffinity.equals(p.task.affinity)) {
                        // If the activity currently at the bottom has the
                        // same task affinity as the one we are moving,
                        // then merge it into the same task.
                        target.task = p.task;
                        if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
                                + " out to bottom task " + p.task);
                    } else {
                        mCurTask++;
                        if (mCurTask &lt;= 0) {
                            mCurTask = 1;
                        }
                        target.task = new TaskRecord(mCurTask, target.info, null,
                                (target.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
                        target.task.affinityIntent = target.intent;
                        if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
                                + " out to new task " + target.task);
                    }
                    mWindowManager.setAppGroupId(target, task.taskId);
                    if (replyChainEnd &lt; 0) {
                        replyChainEnd = targetI;
                    }
                    int dstPos = 0;
                    for (int srcPos=targetI; srcPos&lt;=replyChainEnd; srcPos++) {
                        p = (HistoryRecord)mHistory.get(srcPos);
                        if (p.finishing) {
                            continue;
                        }
                        if (DEBUG_TASKS) Slog.v(TAG, "Pushing next activity " + p
                                + " out to target's task " + target.task);
                        task.numActivities--;
                        p.task = target.task;
                        target.task.numActivities++;
                        mHistory.remove(srcPos);
                        mHistory.add(dstPos, p);
                        mWindowManager.moveAppToken(dstPos, p);
                        mWindowManager.setAppGroupId(p, p.task.taskId);
                        dstPos++;
                        if (VALIDATE_TOKENS) {
                            mWindowManager.validateAppTokens(mHistory);
                        }
                        i++;
                    }
                    if (taskTop == p) {
                        taskTop = below;
                    }
                    if (taskTopI == replyChainEnd) {
                        taskTopI = -1;
                    }
                    replyChainEnd = -1;
                    addRecentTaskLocked(target.task);
                } else if (forceReset || finishOnTaskLaunch
                        || clearWhenTaskReset) {

                    // sunway:
                    // 经过若干次循环后,确定了要reset的activity的范围,开始reset
                    // 其中, CLEAR_WHEN_TASK_RESET和CLEAR_TOP行为相似,都使
                    // 该activity以上被finish,但前者会限制上限为当前task

                    // If the activity should just be removed -- either
                    // because it asks for it, or the task should be
                    // cleared -- then finish it and anything that is
                    // part of its reply chain.
                    if (clearWhenTaskReset) {
                        // In this case, we want to finish this activity
                        // and everything above it, so be sneaky and pretend
                        // like these are all in the reply chain.
                        replyChainEnd = targetI+1;
                        while (replyChainEnd &lt; mHistory.size() &amp;&amp;
                                ((HistoryRecord)mHistory.get(
                                            replyChainEnd)).task == task) {
                            replyChainEnd++;
                        }
                        replyChainEnd--;
                    } else if (replyChainEnd &lt; 0) {
                        replyChainEnd = targetI;
                    }
                    HistoryRecord p = null;
                    for (int srcPos=targetI; srcPos&lt;=replyChainEnd; srcPos++) {
                        p = (HistoryRecord)mHistory.get(srcPos);
                        if (p.finishing) {
                            continue;
                        }
                        if (finishActivityLocked(p, srcPos,
                                Activity.RESULT_CANCELED, null, "reset")) {
                            replyChainEnd--;
                            srcPos--;
                        }
                    }
                    if (taskTop == p) {
                        taskTop = below;
                    }
                    if (taskTopI == replyChainEnd) {
                        taskTopI = -1;
                    }
                    replyChainEnd = -1;
                } else {
                    // If we were in the middle of a chain, well the
                    // activity that started it all doesn't want anything
                    // special, so leave it all as-is.
                    replyChainEnd = -1;
                }
            } else {
                // Reached the bottom of the task -- any reply chain
                // should be left as-is.
                replyChainEnd = -1;
            }

        } else if (target.resultTo != null) {
            // If this activity is sending a reply to a previous
            // activity, we can't do anything with it now until
            // we reach the start of the reply chain.
            // XXX note that we are assuming the result is always
            // to the previous activity, which is almost always
            // the case but we really shouldn't count on.
            if (replyChainEnd &lt; 0) {
                replyChainEnd = targetI;
            }

        } else if (taskTopI &gt;= 0 &amp;&amp; allowTaskReparenting
                &amp;&amp; task.affinity != null
                &amp;&amp; task.affinity.equals(target.taskAffinity)) {
            // sunway:
            // 如果其它task中有从当前task`过继`过去的activity, 那么也会reset
            // 它,或者会把它move回当前task (根据IF_NEEDED)

            // We are inside of another task...  if this activity has
            // an affinity for our task, then either remove it if we are
            // clearing or move it over to our task.  Note that
            // we currently punt on the case where we are resetting a
            // task that is not at the top but who has activities above
            // with an affinity to it...  this is really not a normal
            // case, and we will need to later pull that task to the front
            // and usually at that point we will do the reset and pick
            // up those remaining activities.  (This only happens if
            // someone starts an activity in a new task from an activity
            // in a task that is not currently on top.)
            Slog.e("sunway", "AMS:206");
            if (forceReset || finishOnTaskLaunch) {
                Slog.e("sunway", "AMS:208");
                if (replyChainEnd &lt; 0) {
                    replyChainEnd = targetI;
                }
                HistoryRecord p = null;
                for (int srcPos=targetI; srcPos&lt;=replyChainEnd; srcPos++) {
                    p = (HistoryRecord)mHistory.get(srcPos);
                    if (p.finishing) {
                        continue;
                    }
                    Slog.e("sunway", "AMS:218");
                    if (finishActivityLocked(p, srcPos,
                            Activity.RESULT_CANCELED, null, "reset")) {
                        taskTopI--;
                        lastReparentPos--;
                        replyChainEnd--;
                        srcPos--;
                    }
                }
                replyChainEnd = -1;
            } else {
                Slog.e("sunway", "AMS:229");
                if (replyChainEnd &lt; 0) {
                    replyChainEnd = targetI;
                }
                for (int srcPos=replyChainEnd; srcPos&gt;=targetI; srcPos--) {
                    HistoryRecord p = (HistoryRecord)mHistory.get(srcPos);
                    if (p.finishing) {
                        continue;
                    }
                    if (lastReparentPos &lt; 0) {
                        lastReparentPos = taskTopI;
                        taskTop = p;
                    } else {
                        lastReparentPos--;
                    }
                    mHistory.remove(srcPos);
                    p.task.numActivities--;
                    p.task = task;
                    mHistory.add(lastReparentPos, p);
                    if (DEBUG_TASKS) Slog.v(TAG, "Pulling activity " + p
                            + " in to resetting task " + task);
                    task.numActivities++;
                    mWindowManager.moveAppToken(lastReparentPos, p);
                    mWindowManager.setAppGroupId(p, p.task.taskId);
                    if (VALIDATE_TOKENS) {
                        mWindowManager.validateAppTokens(mHistory);
                    }
                }
                replyChainEnd = -1;

                // Now we've moved it in to place...  but what if this is
                // a singleTop activity and we have put it on top of another
                // instance of the same activity?  Then we drop the instance
                // below so it remains singleTop.
                if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
                    for (int j=lastReparentPos-1; j&gt;=0; j--) {
                        HistoryRecord p = (HistoryRecord)mHistory.get(j);
                        if (p.finishing) {
                            continue;
                        }
                        if (p.intent.getComponent().equals(target.intent.getComponent())) {
                            if (finishActivityLocked(p, j,
                                    Activity.RESULT_CANCELED, null, "replace")) {
                                taskTopI--;
                                lastReparentPos--;
                            }
                        }
                    }
                }
            }
        }

        target = below;
        targetI = i;
    }

    return taskTop;
    // sunway:
    // 总结:
    // RESET_TASK是指有些activity会被finish,有些会被move (ALLOW_TASK_REPARENTING)
    // IF_NEEDED因为有三层含义:
    //   1. task inactive超过30 min后会被CLEAR_TASK_ON_LAUNCH
    //   2. 有些activity若设置了FINISH_ON_TASK_LAUNCH属性或有
    //      CLEAR_WHEN_TASK_RESET intent flag, 会被finish
    //   3. 有些activity若设置了ALLOW_TASK_REPARENTING, 会被moved, 或者被finish
    // 一般只有launcher会 reset task
}
</pre>
</div>
</li>

<li>analysis<br  /><div class="outline-text-6" id="text-1-2-8-2-2">
<pre class="example">
startActivityUnchecked(HistoryRecord r, HistoryRecord sourceRecord, ...)
// r is the activity to be start; sourceRecord is the activity that issues the startActivity, for notification, service..., sourceRecord is null
  if (sourceRecord==null):
  // This activity is not being started from another...  in this case, always start new task
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
  else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
  // original Activity is SINGLE_INSTANCE launchMode
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
  else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
	   or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;

  if (r.resultTo != null &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
    // NEW_TASK is set, but requires Activity result, so just cancel the result
    sendActivityResultLocked(-1,...)

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 ...):
    HistoryRecord taskTop=findTaskLocked(intent, r.info);
       // find the target task complies with r, according to affinity, compnent, .... from mHistory, top --&gt; bottom
       // findTaskLocked will return the top activity in any existing task matching the given intent
       // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
       // How taskAffinity is null? if activity's taskAffinity property is set to "" (see `Notification`), then it's taskAffinity will be set to null
    if (taskTop!=null):
    // found an target task, may try to foreground the task
    // else jump to endif of ..launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK..
      HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
      // find the current top activity's task
      if (curTop.task != taskTop.task):
      // target task is in background, will try to foreground target task, unless ...
	boolean callerAtFront = sourceRecord == null  || curTop.task == sourceRecord.task;
	// whether the startActivity action is issued from an obscured activity
	// we prefer that an obscured activity can't moveTaskToFront
	if (callerAtFront):
	  moveTaskToFrontLocked(taskTop.task, r);
	  // move all the activities belonging to target task to the top of mHistory
	if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0):
	  // reset task if need, another dragon~
	  taskTop = resetTaskIfNeededLocked(taskTop, r);
      if ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
           or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
           or r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	HistoryRecord top = performClearTaskLocked(taskTop.task.taskId, r, launchFlags, true);
	// clear the *mHistory* from top to the target *artivity*
	// note that: if target is successfully moved to front beforehand,
	// clearTask will actually only clear the target task, instead of the whole mHistory
	  // for each activity from mHistory.top downto target activity, finish it!
	  // for the target activity, if it has the SINGLE_TOP flag, do nothing and return it, else finish it!
	if (top!=null):
	  // target activity has the SINGLE_TOP flag, thus not finished
	  deliverNewIntentLocked(top, r.intent);
	else:
	  // target activity has been finished, place a new one on the task
	  addingToTask = true;  // future actions will be taken if addingToTask is true, which means we need add the target activity to target task
		                // addingToTask means `startNewActivity`
      else if (r.realActivity.equals(taskTop.task.realActivity)): // else of clear_top
	// In this case the top activity on the task is the
        // same as the one being launched, so we take that
        // as a request to bring the task to the foreground.
	if (!r.intent.filterEquals(taskTop.task.intent)):
	// we are trying to restart target task's root activity, but with a different intent, we should start a new instance on top
	// else, do nothing (since the target task is already brought to front)
	  addingToTask = true;
      // if CLEAR_TOP ends here
      if (!addingToTask):
      // new instance should not be started, e.g. CLEAR_TOP will SINGLE_TOP; starting target task's root activity with the same intent
	resumeTopActivity()
	return;
  // if NEW_TASK end here

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // when we reach here:
  // 1. activity w/o NEW_TASK
  // 2. activity w/ NEW_TASK but doesn't found the target task

  HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
  if (top.realActivity.equals(r.realActivity)):
    if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
      or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
      or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	resumeTopActivityLocked(null);
	deliverNewIntentLocked(top, r.intent);
	return;
  if (!addingToTask  &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
    // case 2.
    r.task = new TaskRecord(mCurTask, r.info, intent,...)
  else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0):
    // case 1.
    HistoryRecord top = performClearTaskLocked(sourceRecord.task.taskId, r, launchFlags, true);
    if (top != null):
      deliverNewIntentLocked(top, r.intent);
      return;
  else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0):
    // case 1.
    // In this case, we are launching an activity in our own task
    // that may already be running somewhere in the history, and
    // we want to shuffle it to the front of the stack if so.
    int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
      // if sourceRecord.task is not the top task in mHistory, return -1, else return the index of r in mHistory
    HistoryRecord top = moveActivityToFrontLocked(where);
    deliverNewIntentLocked(top, r.intent);
    resumeTopActivityLocked(null);
    return;
  // if NEW_TASK ends here

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // all launchMode and flag is considered, if control flow still reach here ... startActivity!
  startActivityLocked(r, newTask, doResume);
  return;
</pre>
<p>
simplified procedure:
</p>

<pre class="example">
if NEW_TASK:
  if found target task:
    moveTaskToFront()
    clearTop
    starting with the same intent with target task?
single_top
new task
clear_top
reorder_to_front
startActivity
</pre>

<p>
To summarize:
</p>
<ol class="org-ol">
<li>FLAG\<sub>ACTIVITY\</sub><sub>NEW\</sub><sub>TASK</sub> may be set implicitly, e.g.
<ul class="org-ul">
<li>starting activity from service, notification &#x2026;, where sourceRecord==null
</li>
<li>target activity is SINGLE\<sub>INSTANCE</sub>, SINGLE\<sub>TASK</sub>
</li>
<li>sourceRecord is in SINGLE\<sub>INSTANCE</sub>
</li>
</ul>
</li>
<li>FLAG\<sub>ACTIVITY\</sub><sub>NEW\</sub><sub>TASK</sub> has two means:
<ol class="org-ol">
<li>if target task exists: `moveTaskToFront`
</li>
<li>if not: start new task
</li>
</ol>
</li>
<li>moveTaskToFront must meet 3 conditions:
<ol class="org-ol">
<li>NEW\<sub>TASK</sub>
</li>
<li>target task exists and is in background
</li>
<li>sourceRecord is null or sourceRecord is the top activity,
that is, only notification, service and curTop activity can move a background task to front through NEW\<sub>TASK</sub>
</li>
</ol>
</li>
<li>CLEAR\<sub>TOP</sub>
CLEAR\<sub>TOP</sub> will clear all the activities in <b>mHistory</b> on top of target activity, so  CLEAR\<sub>TOP</sub> should be used in two ways:
<ol class="org-ol">
<li>in most cases, CLEAR\<sub>TOP</sub> should be used in conjunction with NEW\<sub>TASK</sub>, so that, before clear top, the target task is moveTaskToFront,
thus the succeeding CLEAR\<sub>TOP</sub> will be restrict to the target task
</li>
<li>CLEAR\<sub>TOP</sub> can be used w/o NEW\<sub>TASK</sub>, but make sure the sourceRecord is the foreground task, or else all the activities on top of it will
be finished.
</li>
</ol>
</li>
<li>REORDER\<sub>TO\</sub><sub>FRONT</sub>
<ol class="org-ol">
<li>should <b>ONLY</b> be called by foreground task, or else the flag will not take effect
</li>
</ol>
<p>
because CLEAR\<sub>TOP</sub> condition is judged before REORDER\<sub>TO\</sub><sub>FRONT</sub>, so if CLEAR\<sub>TOP</sub> is set, REORDER\<sub>TO\</sub><sub>FRONT</sub> is ignored
What's more: REORDER\<sub>TO\</sub><sub>FRONT</sub> will only take effect if NEW\<sub>TASK</sub>
</p>
</li>
<li>deliverNewIntent
deliverNewIntent will occurs in two cases:
<ol class="org-ol">
<li>SINGLE\<sub>TOP</sub>, w/ or w/o NEW\<sub>TASK</sub>
</li>
<li>REORDER\<sub>TO\</sub><sub>FRONT</sub>
</li>
</ol>
</li>
</ol>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-2-8-3" class="outline-5">
<h5 id="sec-1-2-8-3"><span class="section-number-5">1.2.8.3</span> Launcher &amp; Task</h5>
</div>
<div id="outline-container-sec-1-2-8-4" class="outline-5">
<h5 id="sec-1-2-8-4"><span class="section-number-5">1.2.8.4</span> resetTaskIfNeededLocked</h5>
<div class="outline-text-5" id="text-1-2-8-4">
<p>
FLAG\<sub>ACTIVITY\</sub><sub>NEW\</sub><sub>TAKS</sub> &amp;&amp; FLAG\<sub>ACTIVITY\</sub><sub>RESET\</sub><sub>TASK\</sub><sub>IF\</sub><sub>NEEDED</sub> will trigger resetTaskIfNeededLocked
</p>

<p>
Typically, only launcher will set those two flags to resetTaskIfNeededLocked, but we still can set those flags manually to
trigger resetTaskIfNeededLocked
</p>

<pre class="example">
resetTaskIfNeededLocked
  // whether the launching activity has the property `CLEAR_TASK_ON_LAUNCH`
  boolean forceReset = (newActivity.info.flags &amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  // if the target task has been inactive for ACTIVITY_INACTIVE_RESET_TIME (30 min)
  // and the target's *root* activity doesn't have the ALWAYS_RETAIN_TASK_STATE property, also set forceReset to true
  // that is what the phrase `IfNeed` means
  if (taskTop.task.getInactiveDuration() &gt; ACTIVITY_INACTIVE_RESET_TIME):
    if ((newActivity.info.flags &amp;ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0):
      forceReset = true;
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  foreach HistoryRecord of the target task in mHistory (from top --&gt; bottom):
    // should the activity be finished on task launch?
    boolean finishOnTaskLaunch = (flags&amp;ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
    // should the activity has ALLOW_TASK_REPARENTING property?
    boolean allowTaskReparenting = (flags&amp;ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
    // should the activity clear it's top when task reset?
    boolean clearWhenTaskReset = (target.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
    if (!finishOnTaskLaunch &amp;&amp; !clearWhenTaskReset &amp;&amp; allowTaskReparenting
	&amp;&amp; !target.taskAffinity.equals(task.affinity)):
      // if the activity is ALLOW_TASK_REPARENTING and it's affinity is different with target task ...
      // that is , the activity is reparent from somewhere else ... , so detach it, instead of kill it.
      // however, ALLOW_TASK_REPARENTING can only overide forceReset: finishOnTaskLaunch and clearWhenTaskReset can still kill it.
      // ALLOW_TASK_REPARENTING is flexible: it can be attached/detached from a TO-BE-RESET task.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (forceReset || finishOnTaskLaunch || clearWhenTaskReset ):
      if (clearWhenTaskReset):
	// finish all the actvities of the target task above the launching activity.
      finish current activity
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (taskTopI &gt;= 0 &amp;&amp; allowTaskReparenting &amp;&amp; task.affinity.equals(target.taskAffinity)):
      // We are inside of another task...  if this activity has an affinity for our task, then either remove it if we are
      // clearing or attach it to our task
</pre>

<p>
To summarize:
</p>
<ul class="org-ul">
<li>CLEAR\<sub>TASK\</sub><sub>ON\</sub><sub>LAUNCH</sub> property will clear the task when re-launch the task from launcher, (only meaningful for root activity)
</li>
<li>if task has been inactive for 30 min, it will also be CLEAR\<sub>TASK\</sub><sub>ON\</sub><sub>LAUNCH</sub>, unless RETAIN\<sub>TASK\</sub><sub>STATE</sub> property is set
RETAIN\<sub>TASK\</sub><sub>STATE</sub> is closely related to the 30 min thresh-hold, (only meaningful for root activity)
</li>
<li>FINISH\<sub>ON\</sub><sub>TASK\</sub><sub>LAUNCH</sub> property vs. CLEAR\<sub>WHEN\</sub><sub>TASK\</sub><sub>RESET</sub> intent flag (not only meaningful for root activity)
</li>
<li>ALLOW\<sub>TASK\</sub><sub>REPARENTING</sub> is flexible: it can be detached/attached from a TO-BE-RESET task
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-8-5" class="outline-5">
<h5 id="sec-1-2-8-5"><span class="section-number-5">1.2.8.5</span> affinity</h5>
<div class="outline-text-5" id="text-1-2-8-5">
<p>
2010-11-15
</p>
<ol class="org-ol">
<li>One task's affinity is the root activity's task affinity.
</li>
<li>activity's task affinity, if not specified in manifest, is set to the activity's package name, by default.
</li>
<li>activity's task affinity can be <b>null</b>:
if activity's taskAffinity property is set to "" (see <i>Notification</i>), then it's taskAffinity will be set to null
</li>
<li>Affinity will affect activity in two ways:
<ol class="org-ol">
<li>When activity A calls startActivity(B) to start B activity, B will be
put into the same task as A, but if the calling intent set the flag
FLAG<sub>NEW</sub><sub>TASK</sub>
<ol class="org-ol">
<li>if there is already ONE task whose affinity is identical with B's
affinity (including the origina task), B will be put into that
task. so, if orig task's affinity is the same as B's affinity,B will still be placed into the orig task
</li>
<li>if there is no task whose affinity is identical with B's
affinity, B will be put into a new task. So the FLAG<sub>NEW</sub><sub>TASK</sub> is
a little ambiguous, maybe it should be named
FLAG<sub>NEW</sub><sub>OR</sub><sub>EXIST</sub><sub>TASK</sub>.
</li>
</ol>
</li>
<li>If A call startActivity(B) to start B activity, and the calling
task's affinity is same as B's affinity, and B has set the activity
property: AllowTaskReparenting, then B will be `reparented` to the
calling task.
</li>
</ol>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2-8-6" class="outline-5">
<h5 id="sec-1-2-8-6"><span class="section-number-5">1.2.8.6</span> launch mode</h5>
<div class="outline-text-5" id="text-1-2-8-6">
</div><ol class="org-ol"><li>standard<br  /></li>
<li>singleTop<br  /></li>
<li>singleInstance<br  /></li>
<li>singleTask<br  /></li></ol>
</div>

<div id="outline-container-sec-1-2-8-7" class="outline-5">
<h5 id="sec-1-2-8-7"><span class="section-number-5">1.2.8.7</span> Intent flag</h5>
<div class="outline-text-5" id="text-1-2-8-7">
</div><ol class="org-ol"><li>FLAG<sub>ACTIVITY</sub><sub>NEW</sub><sub>TASK</sub><br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>CLEAR</sub><sub>TOP</sub><br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>SINGLE</sub><sub>TOP</sub><br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>REORDER</sub><sub>TO</sub><sub>FRONT</sub><br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>RESET</sub><sub>TASK</sub><sub>IF</sub><sub>NEEDED</sub> [launch related]<br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>CLEAR</sub><sub>WHEN</sub><sub>TASK</sub><sub>RESET</sub> [launch related]<br  /><div class="outline-text-6" id="text-1-2-8-7-6">
<p>
stronger CLEAR<sub>TOP</sub>?
</p>
</div>
</li>

<li>FLAG<sub>ACTIVITY</sub><sub>MULTIPLE</sub><sub>TASK</sub><br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>FORWARD</sub><sub>RESULT</sub><br  /></li>
<li>FLAG<sub>ACTIVITY</sub><sub>EXCLUDE</sub><sub>FROM</sub><sub>RECENTS</sub><br  /></li></ol>
</div>

<div id="outline-container-sec-1-2-8-8" class="outline-5">
<h5 id="sec-1-2-8-8"><span class="section-number-5">1.2.8.8</span> Properties</h5>
<div class="outline-text-5" id="text-1-2-8-8">
</div><ol class="org-ol"><li>FINISH<sub>ON</sub><sub>TASK</sub><sub>LAUNCH</sub>  [launch related]<br  /></li>
<li>CLEAR<sub>TASK</sub><sub>ON</sub><sub>LAUNCH</sub>  [launch related]<br  /><div class="outline-text-6" id="text-1-2-8-8-2">
<p>
activity must be taks's root activity
</p>
</div>
</li>

<li>ALLOW<sub>TASK</sub><sub>REPARENTING</sub><br  /></li>
<li>ALWAYS<sub>RETAIN</sub><sub>TASK</sub><sub>STATE</sub><br  /></li></ol>
</div>

<div id="outline-container-sec-1-2-8-9" class="outline-5">
<h5 id="sec-1-2-8-9"><span class="section-number-5">1.2.8.9</span> moveTaskToBack</h5>
</div>
<div id="outline-container-sec-1-2-8-10" class="outline-5">
<h5 id="sec-1-2-8-10"><span class="section-number-5">1.2.8.10</span> isTaskRoot</h5>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Service&#xa0;&#xa0;&#xa0;<span class="tag"><span class="service">service</span></span></h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> startService</h4>
<div class="outline-text-4" id="text-1-3-1">
<pre class="example">
startServiceLocked()
   retrieveServiceLocked()
     checkComponentPermission()
   bringUpServiceLocked()
      if serviceRecord.app and app.thread is not null,
	   sendServiceArgs()
	      thread.scheduleServiceArgs()
	          service.onStartCommand()
       else
	   getProcessRecord(appName)
	   if app or thread is not null (process is ready)
	       realStartService()
	          thread.scheduleCreate..
	   else
	       startProcess()
	          start ActivityThread
	       add service to mPendingSer..
</pre>

<pre class="example">
New process:
  ActivityThread::attach()
    AMS::attachApplication()
      foreach mPendingServices:
        realStartService()
          thread.scheduleCreate..
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> bindService &amp;  unbindService</h4>
<div class="outline-text-4" id="text-1-3-2">
</div><div id="outline-container-sec-1-3-2-1" class="outline-5">
<h5 id="sec-1-3-2-1"><span class="section-number-5">1.3.2.1</span> ServiceConnection</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<p>
ServiceConnection itself is binder proxy, which only implement one method:
</p>
<pre class="example">
void connected(ComponentName name, IBinder service) throws RemoteException;
</pre>
<p>
through ServiceConnection.connected(), service can notify the <b>client</b> about service bound/unbound.
</p>

<p>
so the client must implement the ServiceConnection stub, actually, ActivityThread maintains one
</p>
<pre class="example">
HashMap&lt;Context, HashMap&lt;ServiceConnection, ServiceDispatcher&gt;&gt; mServices
</pre>
<p>
while ServiceDispatcher maintains the ServiceConnection stub. AMS will notify the client directly through ServiceConnection stub in ActivityThread
To summarize:
</p>
<ol class="org-ol">
<li>ServiceConnection is a stub implement in ActivityThread, AMS use it to notify client
</li>
<li>ServiceConnection are maintained by ActivityThread, Activity.destroy will not affect the connection.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3-2-2" class="outline-5">
<h5 id="sec-1-3-2-2"><span class="section-number-5">1.3.2.2</span> bindService</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<pre class="example">
int bindService(IServiceConnection connection,...);; connection is the binder proxy supplied by client
  mServiceConnections.put(binder, c); ;; AMS save the proxy for later use
   if ((flags&amp;Context.BIND_AUTO_CREATE) != 0):  ;; if BIND_AUTO_CREATE flag is set, will bring up the service
     bringUpServiceLocked(s, service.getFlags(), false);
       ;; may start process --&gt; create service --&gt; start service ...
     return 0;
   if (s.app != null &amp;&amp; b.intent.received):
     connection.connected(s.name, b.intent.binder); ;; notify client by onServiceConnected
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-2-3" class="outline-5">
<h5 id="sec-1-3-2-3"><span class="section-number-5">1.3.2.3</span> unbindService</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<pre class="example">
mServiceConnections.remove(connection);
s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());
if ((c.flags&amp;Context.BIND_AUTO_CREATE) != 0):
  bringDownServiceLocked(s, false);
    if (!force &amp;&amp; r.startRequested):  // startService will set r.startRequested to true, that why unbindService won't bring down service if it is
	                              // started by startService
      return;
    if (r.connections.size() &gt; 0):
      for each connection:
        if ((cr.flags&amp;Context.BIND_AUTO_CREATE) != 0):  // if there is still any other connection that is BIND_AUTO_CREATE,
		                                          // skip bring down the service
          return;
      for each connection:
        c.conn.connected(r.name, null);   // service is about to be brought down, notify all connections through onServiceDisconnected
  r.app.thread.scheduleStopService(r);
</pre>
<p>
To summarize:
  unbindService will normally stop service, unless:
</p>
<ol class="org-ol">
<li>the connection is not a BIND<sub>AUTO</sub><sub>CREATE</sub> connection
</li>
<li>service is started by startService
</li>
<li>that are still other BIND<sub>AUTO</sub><sub>CREATE</sub> connections bound to the service
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> ServiceRecord</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
d12/28/10 8:12 pm
similar with AMS::HistoryRecord. mainly save the r.ap and r.app.thread so as to interact with the service's process. .  But there is no correspondant like ActivityRecord in ActivityThread, since service needn't interqact with WMS, and it's life cycle is quite simple. (create, start, stop)
</p>
</div>
</div>

<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> STICKY service</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
STICKY mainly make sense when process has crashed due to uncaught exception.
see also <i>Android Process Crash and Restart</i>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Broadcast&#xa0;&#xa0;&#xa0;<span class="tag"><span class="broadcast">broadcast</span></span></h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> OrderedBroadcast</h4>
<div class="outline-text-4" id="text-1-4-1">
</div><div id="outline-container-sec-1-4-1-1" class="outline-5">
<h5 id="sec-1-4-1-1"><span class="section-number-5">1.4.1.1</span> AbortBroadcast()</h5>
</div>
<div id="outline-container-sec-1-4-1-2" class="outline-5">
<h5 id="sec-1-4-1-2"><span class="section-number-5">1.4.1.2</span> GetResult..()</h5>
</div>
<div id="outline-container-sec-1-4-1-3" class="outline-5">
<h5 id="sec-1-4-1-3"><span class="section-number-5">1.4.1.3</span> priority</h5>
<div class="outline-text-5" id="text-1-4-1-3">
<p>
broadcast receiver's intent filter's `priority` will be used to by the AMS to determine the order in which the broadcast is send to
</p>
</div>
</div>

<div id="outline-container-sec-1-4-1-4" class="outline-5">
<h5 id="sec-1-4-1-4"><span class="section-number-5">1.4.1.4</span> SetResult..()</h5>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> protected-broadcast</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
PACKAGE<sub>REMOVED</sub>/PACKAGE<sub>ADDED</sub>/BOOT<sub>COMPLETED</sub> are all protected-broadcasts, only the process with "system" uid can send the broadcast
</p>
<pre class="example">
broadcastIntentLocked()
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) :
    // Always okay.
  else:
    if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) :
      throw new SecurityException(msg);
</pre>

<p>
To summarize: 
</p>

<p>
`protected-broadcasts` means `those broadcasts can only
be sent by SYSTEM,PHONE,SHELL or root`
</p>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> SendBroadcast</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
every call to sendBroadcast will init a new receiver instance.
</p>
<pre class="example">
AMS:broadcastIntentLocked()
  // find out who will recv this broadcast
  if intent.getComponent():
    receivers.add(r);
  else:
    if !Intent.FLAG_RECEIVER_REGISTERED_ONLY:
      receivers=PM.queryIntentReceivers();
    registeredReceivers = ReceiverResolver.queryIntent(); ;;ReceiverResolver is a in-memory storage that stores runtime-registered receivers
  // now, `receivers` stores receivers from PM, `registeredReceivers` stores receivers from ReceiverResolver
  if !ordered:
    BroadcastRecord r=new BroadcastRecord(registeredReceivers);
    mParallelBroadcasts.add(r);
    add/update mStickyBroadcasts if the broadcast is STICKY 
    ;; note: mStickyBroadcasts is only re-broadcasted on registerReceiver()
    scheduleBroadcastsLocked()
      sendMessage(BROADCAST_INTENT_MSG);
        processNextBroadcast();
          foreach BroadcastRecord in mParallelBroadcasts:
            foreach receiver in BroadcastRecord:
              deliverToRegisteredReceiver();
                ;; make sure receiver has the requiredPermission imposed by the sender,  e.g. PERMISSION_BOOT_COMPLETED, sender can imposed a
                ;; requiredPermission through sendBroadcast(intent,requiredPermission)
                if r.requiredPermission!=null:
                  checkComponentPermission(r.requiredPermission,filter.receiverList.pid, filter.receiverList.uid, -1);
                ;; make sure the sender has the requiredPermission imposed by the receiver's filter
                if filter.requiredPermission != null:
                  checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1);
                performReceive();
                  if app.thread !=null:
                    app.thread.scheduleRegisteredReceiver();
                      ReceiverDispatcher.performReceive() ;; for registeredReceivers, receiver class are identified by ReceiverDispatcher (which is send to
                                                          ;; AMS during registerReceiver()
                        new Args() {
                          run():
                            receiver.onReceive();
                            if ordered:
                              AMS:finishReceiver(); ;; not called here
                        }
                        H.post(Args);
    registeredReceivers=null; ;; since registeredReceivers is broadcasted already as mParallelBroadcasts, it should not be merged with receivers
  ;; if  !ordered, registeredReceivers are broadcasted all at once, without TIMEOUT consideration! SO, registeredReceivers in non-ordered broadcast
  ;; will never cause ANR!
  ;; if ordered, both registeredReceivers and receivers are merged in a single list, so that both registeredReceivers and receivers are broadcasted in
  ;; order
  merge_into_one_receiver_list();
  scheduleBroadcastsLocked();
    sendMessage();
      processNextBroadcast();
        r=OrderedBroadcast.get(0);
        if r.nextReceiver&gt;r.receivers.size():
          removeMessages(BROADCAST_TIMEOUT_MSG);
        r.receiverTime=now();
        if current receiver is the first one of r:
          sendMessageAtTime(BROADCAST_TIMEOUT_MSG,r.receiverTime+BROADCAST_TIMEOUT);
        if current receiver is a registeredReceivers:
          scheduleBroadcastsLocked(get Current Receiver); ;; direct call
        else:
          if app!=null:
            app.thread.scheduleReceiver();
              handlerReceiver()
                receiver = (BroadcastReceiver)cl.loadClass(component).newInstance(); ;; for static receivers, receivers are identified by component name
                receiver.onReceive(context.getReceiverRestrictedContext(),...)
                AMS:finishReceiver(); ;; notify AMS that it can process next broadcast.
          else:
            startProcess();
            mPendingBroadcast=r; ;; mPendingBroadcast will broadcasted when process is ready and attached to AMS

   BROADCAST_TIMEOUT_MSG's handle Message() will check whether r.receiverTime is updated, if so, that means one of Ra's receiver has returned, so
   handler will not cause an ANR
</pre>
<p>
To summarize:
</p>
<ol class="org-ol">
<li>dynamic registered receiver
      <b>the same BroadcastReceiver instance is used for Multi-broadcast</b>
<ul class="org-ul">
<li>in non-ordered broadcast
<ol class="org-ol">
<li>doesn't cause ANR
</li>
<li>all dynamic receivers are invoked in parallel manner (by ActivityThread's handler), i.e. one receiver's onReceive() will not block another
receiver's correspondent.
</li>
</ol>
</li>
<li>in ordered broadcast
ANR and parallel/serial manner is the same as static registered receivers
</li>
</ul>
</li>

<li>static registered receiver
      <b>every time broadcast is received, a new static registered receiver instance is initiated</b>
<ul class="org-ul">
<li>always invoked in a serial manner, i.e. one static receiver's onReceive() will block other static receiver's correspondents, no matter
whether it is ordered. (maybe because static receiver's process is not assumed to be running, AMS need a simplified way to start all the processes)
</li>
</ul>
</li>
<li>for a certain broadcast, the ANR timing begins when the first receiver is about to be handled, and ends when the last receiver has been handled,
and, what's most important: take one broadcast contains 10 static receivers for example, <span class="underline">the total ANR timing can be 10*10s at most</span>, instead of 10s.
because although the BROADCAST<sub>TIMEOUT</sub> is set to be 10s, every receiver will update r.receiverTime in AMS.finishReceiver(), and the timeout handler
will issues an ANR only when <b>now-r.receiverTime &gt; BROADCAST<sub>TIMEOUT</sub> (10s)</b>
</li>

<li>sendBroadcast will make sure both the sender and the receiver has been granted the requiredPermission imposed by the counterpart.
see also protected-broadcast for another sendBroadcast limitation.
</li>

<li>Intent.FLAG<sub>RECEIVER</sub><sub>REGISTERED</sub><sub>ONLY</sub>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> BroadcastRecord</h4>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> Sticky</h4>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> ProcessRecord</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> processName</h4>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> AppDeathRecipient</h3>
<div class="outline-text-3" id="text-1-6">
<p>
see also <i>binder's death</i>
see also <i>Android Process Crash and Restart</i>
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> ActivityThread</h3>
<div class="outline-text-3" id="text-1-7">
<p>
ActivityThread stands for the client (contract to AMS) side <b>process</b>.
</p>

<p>
Actually, the class itself is not a Thread at all. It is a normal java
class, and has ONE main(), which act as the entry point of a java
process. 
</p>

<pre class="example">
ActivityThread.main()
  Looper.prepare()
  ActivityThread thread = new ActivityThread();
  thread.attach(false);
  Looper.loop();
</pre>

<p>
that is ,
</p>
<ul class="org-ul">
<li>ActivityThread.main() will start loop in the main thread, the
looper is the so-call `mainLooper`
</li>

<li>thread.attach() will:
<ul class="org-ul">
<li>establish reverse connection (AMS &#x2013;&gt; ActivityThread) with AMS,
(set IApplicationThread IBinder to AMS.app.thread), so that AMS
can use the IApplicationThread to interact with ActivityThread,
e.g. scheduleResumeaCtivity, scheduleLaunchActivity. AMS use
<i>@AppDeathRecipient</i> to reset app.thread to null, which means the
process has gone.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> misc</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> AMS.closeSystemDialogs</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
AMS.closeSystemDialogs 所做的并不只是关闭某些窗口 &#x2026; 而是通知某些人
当前需要关闭一些窗口, AMS.closeSystemDialogs 会做以下几件事:
</p>
<ol class="org-ol">
<li>发送一个特定的 broadcast
</li>
<li>调用 WMS.closeSystemDialogs, 而 WMS.closeSystemDialogs 会通过
ViewRootImpl 调用到 DecorView 的 onCloseSystemDialogs, 进而调用
DecorView 的 closeAllPanels 导致各种 panel (实际上只有 options menu
这一个 panel &#x2026;, context menu, action bar 等都不是 panel) 被关闭,
所以 closeSystemDialogs 似乎更应该叫 closeAllOptionsMenu &#x2026;

<p>
因为 View 的 onCloseSystemDialogs 目前为空操作, 所以popupWindow 不会
响应 closeSystemDialogs, 因为它的顶层 view 不是DecorView
</p>
</li>

<li>调用 activityStack.closeSystemDialogs, 带有
FLAG<sub>FINISH</sub><sub>ON</sub><sub>CLOSE</sub><sub>SYSTEM</sub><sub>DIALOGS</sub> 标志的 activity 会被 finish
</li>
</ol>

<p>
AMS.closeSystemDialogs 一方面可以由应用主动调用, 例如 launcher 或
keyguard, 用来关闭一个窗口. 一方面会因为 KeyEvent 被触发, 目前长按电源
关机, 或按 HOME 启动 launcher 或长按 HOME 启动 recentapp 都会触发
closeSystemDialogs, 应用可以根本这一点获得关机或按 HOME 的通知. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> What's the `system` process?</h3>
<div class="outline-text-3" id="text-1-9">
<p>
简单的说:
</p>
<ol class="org-ol">
<li>system 进程是 system<sub>server</sub> 所在的进程
</li>
<li>system 进程是 zygote 启动的第一 个 java 进程
</li>
<li>system 进程的 ServerThread 负责启动各种 service, 并且是 system 进程
的 main looper (或 system 进程对应的 activity thread 的looper) 所在
的线程.
</li>
<li>system 进程的 oom adj 为 SYSTEM<sub>ADJ</sub>, 并且为 persistent, 其在 AMS 登
记的进程名为 `system`: system 是一个 java 进程, 但它的进程名却有两
个: ps 显示的是 `system<sub>server`</sub>, AMS 里登记的是 `system`
</li>
</ol>
</div>


<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> system 进程及 ActivityThread 的初始化</h4>
<div class="outline-text-4" id="text-1-9-1">
<ol class="org-ol">
<li>system<sub>server</sub> 通过 app<sub>process</sub> 被启动 (参考 zygote init)
</li>
<li>system<sub>server</sub> 的一个单独的线程 ServerThread 负责启动各个 service,
其中包含 AMS
</li>
<li>AMS.main 会初始化一个 ActivityThread 做为 mSystemThread
<div class="org-src-container">

<pre class="src src-text">AMS.main
  ActivityThread.systemMain()
    ActivityThread thread = new ActivityThread();
    thread.attach(true);
</pre>
</div>
<p>
由于 mSystemThread 初始化在 ServerThread 线程, 所以它使用的 Looper
就是 ServerThread 的 Looper. (MyLooper 返回一个 ThreadLocal 变量)
</p>
</li>
<li>ServerThread 启动完 AMS 后会调用 AMS.setSystemProcess 方法, 将
system<sub>server</sub> 进程注册到 AMS, 并做为 `system` 进程

<div class="org-src-container">

<pre class="src src-text">ProcessRecord app = mSelf.newProcessRecordLocked(
                      mSystemThread.getApplicationThread(), info,
                      info.processName, false);
app.persistent = true;
app.pid = MY_PID; // system_server &#30340; pid, 1000
app.maxAdj = ProcessList.SYSTEM_ADJ;
// app.processName &#20026; "system" !
mSelf.mProcessNames.put(app.processName, app.uid, app);
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-01-30 Thu 13:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
