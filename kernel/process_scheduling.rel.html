<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-08-30 Tue 02:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: Process Scheduling</title>
<meta name="generator" content="Org-mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: Process Scheduling</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb6648e1">1. Linux Kernel: Process Scheduling</a>
<ul>
<li><a href="#orgbd1b69d">1.1. Overview</a></li>
<li><a href="#orgb86a66b">1.2. 相关数据结构</a>
<ul>
<li><a href="#org207d3a1">1.2.1. runqueue</a></li>
<li><a href="#org5081da4">1.2.2. task_struct</a></li>
<li><a href="#orgfae3f39">1.2.3. priority</a></li>
</ul>
</li>
<li><a href="#org7d5f71d">1.3. 相关的函数</a>
<ul>
<li><a href="#org63172e8">1.3.1. scheduler_tick</a></li>
<li><a href="#org14e9349">1.3.2. try_to_wake_up</a></li>
<li><a href="#orgc1fafcb">1.3.3. schedule</a></li>
<li><a href="#org1e8104d">1.3.4. set_tsk_need_resched</a></li>
</ul>
</li>
<li><a href="#orga0d2c67">1.4. 各种 scheduler</a>
<ul>
<li><a href="#org69333fa">1.4.1. SCHED_FIFO</a></li>
<li><a href="#org0b34aef">1.4.2. SCHED_RR</a></li>
<li><a href="#orgeb2b0dc">1.4.3. SCHED_NORMAL</a></li>
</ul>
</li>
<li><a href="#org4925a30">1.5. CPU 负载均衡</a>
<ul>
<li><a href="#orga8dba54">1.5.1. pull task</a></li>
<li><a href="#org3b07a1a">1.5.2. push task</a></li>
</ul>
</li>
<li><a href="#orgf2b1fb1">1.6. 相关 API</a>
<ul>
<li><a href="#orge975c4a">1.6.1. nice</a></li>
<li><a href="#org4181cf5">1.6.2. sched_yield</a></li>
<li><a href="#org3a80934">1.6.3. sched_setscheduler</a></li>
<li><a href="#org64b8f58">1.6.4. sched_setaffinity</a></li>
<li><a href="#orgb2a665b">1.6.5. fork</a></li>
<li><a href="#org6b3e486">1.6.6. See also</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb6648e1" class="outline-2">
<h2 id="orgb6648e1"><span class="section-number-2">1</span> Linux Kernel: Process Scheduling</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgbd1b69d" class="outline-3">
<h3 id="orgbd1b69d"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
linux 2.6.11 的进程调度的主要特征:
</p>

<ol class="org-ol">
<li>scheduler 是一个基于 roundrobin 的算法: 每个进程有一个时间片 (slice
或 quantum), 时间片是每次 roundrobin 时进程可以执行的时间长度, 大小
一般为几毫秒到几百毫秒.一次 roundrobin 完成后所有进程的时间片得到补
充进行下一次 roundrobin</li>

<li>每个 cpu 的 runqueue 有 active 和 expired 两个数组, 每个数组包含
140 条链表, 对应 140 个优先级, 所有本次 roundrobin 时间片已经耗尽的
进程按优先级组织在 expired 数组中,还有时间片的组织在 active 数组中,
scheduler 在 pick next 时在 active 数组中通过一个 bitmap 可以在 O(1)
内找到最高优先级的一个 task, 所以 2.6.11 的 scheduler 称为 O(1)
scheduler, 2.6 之前的 scheduler 称为 O(n) scheduler, 因为它只有一条
链表, 每次 pick next 时需要通过排序找到一个最高优先级的.</li>

<li>进程有静态优先级 (static priority), scheduler 会根据静态优先级给进
程分配不同长度的时间片, 静态优先级越高, 时间片越长</li>

<li>进程有动态优先级 (dynamic priority), 在 roundrobin 时 scheduler 根
据动态优先级来选择进程执行的顺序</li>

<li>动态优先级是在静态优先级基础上使用 "平均睡眠时间" 进行补偿或惩罚而
来, 简单的说, 平均睡眠时间越长, 对动态优先级的补偿越多</li>

<li>除了一般的基于时间片与动态优先级的调度外, scheduler 还支持实时调度
来调度实时进程, 但实时进程与普通进程还是要竞争同一个 cpu, linux 的
实时进程只是有更高的优先级和更多的调度机会, 但它无法保证实时进程能
在"确定的时间"内完成, 所以它只软实时(soft real time)</li>

<li>通过 "平均睡眠时间", scheduler 可以识别出 "交互式进程" (interactive
process) 与 "批处理进程" (batch process), scheduler 会通过调整
roundrobin 分配给 "交互式进程" 更多的执行机会</li>

<li>多 CPU 的负载均衡, 可以将繁忙的 CPU 中的 task pull 到当前 CPU 中, 或
者将当前 task push 到空闲的 CPU 中</li>
</ol>
</div>
</div>

<div id="outline-container-orgb86a66b" class="outline-3">
<h3 id="orgb86a66b"><span class="section-number-3">1.2</span> 相关数据结构</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-org207d3a1" class="outline-4">
<h4 id="org207d3a1"><span class="section-number-4">1.2.1</span> runqueue</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
runqueue 是一个 Per-CPU variable, 即每个 CPU 都有一个 runqueue, 这个
runqueue 是进程调度最主要的数据结构, 它维护了一个 running 进程的队列,
scheduler 需要从这个队列中选择进程来执行
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff79c6; font-weight: bold;">struct</span> <span style="color: #f8f8f2;">runqueue</span> {
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">runqueue &#32500;&#25252;&#30340;&#25152;&#26377; running &#36827;&#31243;&#30340;&#20010;&#25968;, &#26159; active &#21644; expired &#20043;&#21644;.</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#36825;&#20010;&#20540;&#21453;&#24212;&#20102;&#24403;&#21069; cpu &#30340;&#36127;&#36733;&#31243;&#24230;    </span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">nr_running</span>;
    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">curr &#21363; current, idle &#21363; swapper </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">task_t</span> *<span style="color: #f8f8f2;">curr</span>, *<span style="color: #f8f8f2;">idle</span>;
    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">&#26368;&#20027;&#35201;&#30340;&#25968;&#25454;&#32467;&#26500;: runqueue &#20013;&#25152;&#26377;&#30340;&#36827;&#31243;&#34987;&#20998;&#20026;&#20004;&#31867;: active &#19982;</span>
<span style="color: #6272a4;">     * expired, active &#26159;&#25351;&#26102;&#38388;&#29255;&#23578;&#27809;&#26377;&#32791;&#23613;&#30340;&#36827;&#31243;, expired &#26159;&#25351;&#26412;&#27425;</span>
<span style="color: #6272a4;">     * roundrobin &#36807;&#31243;&#20013;&#26102;&#38388;&#29255;&#24050;&#32463;&#32791;&#23613;&#30340;&#36827;&#31243;, scheduler &#21482;&#20250;&#20174; active</span>
<span style="color: #6272a4;">     * &#20013;&#23547;&#25214; candidate, &#21442;&#32771; process </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">prio_array_t</span> *<span style="color: #f8f8f2;">active</span>, *<span style="color: #f8f8f2;">expired</span>, <span style="color: #f8f8f2;">arrays</span>[2];
    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">&#25351;&#31034;&#26159;&#21542;&#38656;&#35201;&#23558;&#24403;&#21069; runqueue &#30340; task &#36716;&#25442;&#21040;&#20854;&#23427; cpu </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">int</span> <span style="color: #f8f8f2;">active_balance</span>;
}
</pre>
</div>

<p>
关于 runqueue 中的 arrays, active, expired:
</p>


<div class="figure">
<p><img src="../extra/kernel_scheduler_runqueue.png" alt="kernel_scheduler_runqueue.png" />
</p>
</div>

<p>
其中 p 组成的链表对应的 list entry 是 task_struct-&gt;run_list
</p>
</div>
</div>

<div id="outline-container-org5081da4" class="outline-4">
<h4 id="org5081da4"><span class="section-number-4">1.2.2</span> task_struct</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
具体的参考 <a href="process.html#orgf30d427">task_struct</a>, 其中和 scheduler 相关的部分:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff79c6; font-weight: bold;">struct</span> <span style="color: #f8f8f2;">task_struct</span> {
    <span style="color: #ff79c6; font-weight: bold;">volatile</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">state</span>;

    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">dynamic priority </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">int</span> <span style="color: #f8f8f2;">prio</span>
    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">static priority </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">int</span> static_prio;

    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">&#21644; runqueue &#26377;&#20851; </span><span style="color: #6272a4;">*/</span>
    <span style="color: #ff79c6; font-weight: bold;">struct</span> <span style="color: #f8f8f2;">list_head</span> <span style="color: #f8f8f2;">run_list</span>;
    <span style="color: #f8f8f2;">prio_array_t</span> *<span style="color: #f8f8f2;">array</span>;

    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#24179;&#22343;&#30561;&#30496;&#26102;&#38388;, &#21644; time slice &#22823;&#23567;&#21450; interactive process &#30340;&#21028;&#23450;&#26377;&#20851;,</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#38656;&#35201;&#27880;&#24847;&#30340;&#26159; sleep_avg &#26159;&#25351; 1s &#20043;&#20869;&#22788;&#20110; sleeping &#30340;&#26102;&#38388;, &#20294;&#23427;&#30340;&#32479;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#35745;&#26041;&#27861;&#24182;&#19981;&#26159;&#20005;&#26684;&#24847;&#20041;&#19978;&#30340;&#24179;&#22343;, &#21482;&#26159;&#19968;&#31181;&#36817;&#20284;&#30340;&#26041;&#27861;</span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">sleep_avg</span>;
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">timestamp &#26159;&#35760;&#24405; task &#19982;&#35745;&#31639; sleep_avg &#30456;&#20851;&#30340;&#26102;&#38388;&#25139;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">1. &#34987; schedule in &#25110; out &#30340;&#26102;&#38388; (schedule)</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">2. &#34987;&#21796;&#37266;&#30340;&#26102;&#38388; (try_to_wake_up)            </span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">timestamp</span>, <span style="color: #f8f8f2;">last_ran</span>;
    <span style="color: #f8f8f2;">int</span> <span style="color: #f8f8f2;">activated</span>;

    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">scheduler: SCHED_FIFO, SCHED_RR &#25110; SCHED_NORMAL </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">policy</span>;

    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">CPU mask </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">cpumask_t</span> <span style="color: #f8f8f2;">cpus_allowed</span>;

    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">&#24403;&#21069;&#36827;&#31243;&#21097;&#20313;&#30340;&#26102;&#38388;&#29255; </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">int</span> <span style="color: #f8f8f2;">time_slice</span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">int</span> first_time_slice;

    <span style="color: #6272a4;">/* </span><span style="color: #6272a4;">&#23454;&#26102;&#20248;&#20808;&#32423;(policy &#38656;&#35201;&#26159; FIFO &#25110; RR) </span><span style="color: #6272a4;">*/</span>
    <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">long</span> <span style="color: #f8f8f2;">rt_priority</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfae3f39" class="outline-4">
<h4 id="orgfae3f39"><span class="section-number-4">1.2.3</span> priority</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
dynamic priority 的范围为 0~139, 但上层 API 中 priority 的含义与
kernel 内部的 dynamic priority 定义有些差别:
</p>


<div class="figure">
<p><img src="../extra/kernel_scheduler_priority.png" alt="kernel_scheduler_priority.png" />
</p>
</div>

<ol class="org-ol">
<li>kernel 内部定义的范围为 0~139, 其中 0~99 对应 real time priority,
100~139 对应 conventional priority, 而且 0 是最高优先级, 139 是最低
优先级</li>

<li>通过 nice 系统调用可以设置的参数范围为 -20~+19, 它只会影响
conventional process 的 static priority, 实际上 static_prio = 120 +
nice, 即 nice 为 -20 时, static_prio 为 100, 为 conventional
process 的最高优先级, 相反, nice 为 19 时, static_prio 为 139, 为
conventional process 的最低优先级. 默认的 static_prio 为 120, 即
nice 为 0</li>

<li>bash 中 ps 或 top 看到的值的范围为 39~-100, 与 kernel 的 139~0 对应,
即 static_prio = ps_prio + 100</li>

<li>real time process 的 rt_priority 通过 sched_setscheduler 来设置, 但
与 conventional 不同的是, rt_priority 会影响 dynamic priority 而不
是 static_prio: prio = 99 - rt_priority, 所以, 当 rt_priority 为
99 时, prio 为 0, 是系统最高的优先级, 当 rt_priority 为 1 时, prio
为 98, 是 real time 最低优先级, 但仍比 conventional 的最高优先级
(100) 高</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org7d5f71d" class="outline-3">
<h3 id="org7d5f71d"><span class="section-number-3">1.3</span> 相关的函数</h3>
<div class="outline-text-3" id="text-1-3">
<p>
进程调度的主要入口是 schedule 函数, 但 schedule 函数工作时要依赖于
两个数据的维护:
</p>

<ol class="org-ol">
<li><p>
task_struct-&gt;slice_time
</p>

<p>
进程本次 roundrobin 剩余的时间片, 时间片为 0 的进程需要变成
expired 状态, 本次 roundrobin 不能再调度它, slice_time 由
scheduler_tick 维护
</p></li>

<li><p>
task_struct-&gt;prio
</p>

<p>
动态优先级, roundrobin 时需要根据 sleep_avg 调整动态优先级以选择进
程, 由 try_to_wake_up 时的 recalc_task_prio 维护
</p></li>
</ol>
</div>

<div id="outline-container-org63172e8" class="outline-4">
<h4 id="org63172e8"><span class="section-number-4">1.3.1</span> scheduler_tick</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
每次时钟中断发生时<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>, scheduler_tick 会被调用, 更新当前进程的
slice_time
</p>
</div>

<div id="outline-container-org14ea66f" class="outline-5">
<h5 id="org14ea66f"><span class="section-number-5">1.3.1.1</span> scheduler_tick</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">scheduler_tick</span>:
  <span style="color: #f8f8f2;">runqueue_t</span> *<span style="color: #f8f8f2;">rq</span> = this_rq();
  <span style="color: #f8f8f2;">task_t</span> *<span style="color: #f8f8f2;">p</span> = current;
  <span style="color: #ff79c6; font-weight: bold;">if</span> (rt_task(p)):
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#33509; task &#26159;&#23454;&#26102;&#36827;&#31243; (p-&gt;prio &lt; 100), &#21017;&#36827;&#34892;&#29305;&#27530;&#22788;&#29702;:</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">1. &#33509; scheduler &#20026; SCHED_RR, &#21017; p-&gt;time_slice &#20943;&#19968;, &#33509; time_slice</span>
    <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">&#24050;&#32463;&#32791;&#23613;, &#21017;&#34917;&#20805; time_slice &#24182;&#25226; task &#25918;&#22312; active &#30340;&#26411;&#23614; (&#32780;&#19981;</span>
    <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">&#26159;&#20687; SCHED_NORMAL &#37027;&#26679;&#25918;&#22312; expired &#20013;), &#28982;&#21518;&#36890;&#36807;</span>
    <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">set_tsk_need_resched &#22312;&#23558;&#26469;&#35843;&#29992; schedule &#26469;&#35843;&#24230;&#21478;&#19968;&#20010;&#36827;&#31243;&#25191;&#34892;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">2. &#33509; schedule &#20026; SCHED_FIFO, &#21017;&#19981;&#20570;&#20219;&#20309;&#21160;&#20316;, &#30452;&#25509;&#36820;&#22238;, &#22240;&#20026; FIFO</span>
    <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">&#24182;&#19981;&#38656;&#35201;&#32771;&#34385;&#26102;&#38388;&#29255;, &#23427;&#23436;&#20840;&#26159;&#25353;&#29031; FIFO &#26469;&#35843;&#24230;&#30340;: &#20808;&#26469;&#30340;&#20808;&#25191;&#34892;,</span>
    <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">&#30452;&#21040;&#23427;&#25191;&#34892;&#23436;&#25110;&#20027;&#21160;&#25918;&#24323;&#25110;&#34987;&#39640;&#20248;&#20808;&#32423;&#25250;&#21344;&#20026;&#27490;</span>
    <span style="color: #ff79c6; font-weight: bold;">if</span> ((p-&gt;policy == SCHED_RR) &amp;&amp; <span style="color: #bd93f9;">!</span>--p-&gt;time_slice) {
        p-&gt;time_slice = task_timeslice(p);
        set_tsk_need_resched(p);
        requeue_task(p, rq-&gt;active);
    }
    <span style="color: #ff79c6; font-weight: bold;">goto</span> <span style="color: #bd93f9;">out</span>;
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">conventional scheduler</span>
  <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>--p-&gt;time_slice):
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">time_slice &#24050;&#32463;&#32791;&#23613;:</span>
    <span style="color: #6272a4;">// </span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">1. &#23558; task &#20174; active &#20013; dequeue</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">2. set_tsk_need_resched &#25250;&#21344;&#24403;&#21069;&#36827;&#31243;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">3. &#37325;&#26032;&#35745;&#31639;&#21160;&#24577;&#20248;&#20808;&#32423;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">4. &#34917;&#20805; time_slice</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">5. &#33509; task &#19981;&#26159; interactive task &#25110;&#32773; expired &#24050;&#32463; startving, &#21017;&#23558;</span>
    <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">task enqueue &#21040; expired, &#21542;&#21017; task &#34987;&#37325;&#26032;&#25918;&#22238; active &#38431;&#23614;    </span>
    dequeue_task(p, rq-&gt;active);
    set_tsk_need_resched(p);

    p-&gt;prio = effective_prio(p);
    p-&gt;time_slice = task_timeslice(p);

    <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>TASK_INTERACTIVE(p) || EXPIRED_STARVING(rq)):
      enqueue_task(p, rq-&gt;expired);
      <span style="color: #ff79c6; font-weight: bold;">if</span> (p-&gt;static_prio &lt; rq-&gt;best_expired_prio):
        rq-&gt;best_expired_prio = p-&gt;static_prio;
    <span style="color: #ff79c6; font-weight: bold;">else</span>:
      enqueue_task(p, rq-&gt;active);
  <span style="color: #ff79c6; font-weight: bold;">else</span>:
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">interactive &#36827;&#31243;&#30340; time_slice &#26377;&#21487;&#33021;&#24456;&#38271;, &#32780;&#19988;&#23427;&#20204;&#20250;&#21453;&#22797;&#30340;&#37325;&#26032;&#36827;&#20837;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">active, &#20026;&#36991;&#20813;&#36825;&#31181; task &#38271;&#26102;&#38388;&#21344;&#29992; CPU &#23548;&#33268;&#21516;&#20248;&#20808;&#32423;&#30340; task &#26080;&#27861;&#21450;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#26102;&#25191;&#34892;, &#23558; time_slice &#20998;&#20026;&#20960;&#20010; TIMESLICE_GRANULARITY, &#27599;&#24403;&#24050;&#29992;&#30340;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">time_slice &#36798;&#21040; TIMESLICE_GRANULARITY &#30340;&#20493;&#25968;&#26102;((task_timeslice(p)</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">- p-&gt;time_slice) % TIMESLICE_GRANULARITY(p)), &#21017;&#20027;&#21160;&#25918;&#24323;&#19968;&#27425; (&#23558;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">task &#31227;&#21160;&#21040; active &#38431;&#23614;),    </span>
    <span style="color: #ff79c6; font-weight: bold;">if</span> (TASK_INTERACTIVE(p) &amp;&amp;
          <span style="color: #bd93f9;">!</span>((task_timeslice(p) - p-&gt;time_slice) % TIMESLICE_GRANULARITY(p)) &amp;&amp;
          (p-&gt;time_slice &gt;= TIMESLICE_GRANULARITY(p)) &amp;&amp;
          (p-&gt;array == rq-&gt;active)):
      requeue_task(p, rq-&gt;active);
      set_tsk_need_resched(p);
</pre>
</div>
</div>
</div>

<div id="outline-container-org075be92" class="outline-5">
<h5 id="org075be92"><span class="section-number-5">1.3.1.2</span> task_timeslice</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<p>
task_timeslice 是根据 static_prio 来决定 task 的 time_slice
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff79c6; font-weight: bold;">static</span> <span style="color: #f8f8f2;">unsigned</span> <span style="color: #f8f8f2;">int</span> <span style="color: #50fa7b; font-weight: bold;">task_timeslice</span>(<span style="color: #f8f8f2;">task_t</span> *<span style="color: #f8f8f2;">p</span>)
  <span style="color: #ff79c6; font-weight: bold;">if</span> (p-&gt;static_prio &lt; NICE_TO_PRIO(0)):
    <span style="color: #ff79c6; font-weight: bold;">return</span> SCALE_PRIO(<span style="color: #f8f8f2;">DEF_TIMESLICE</span>*4, p-&gt;static_prio);
  <span style="color: #ff79c6; font-weight: bold;">else</span>:
    <span style="color: #ff79c6; font-weight: bold;">return</span> SCALE_PRIO(DEF_TIMESLICE, p-&gt;static_prio);
</pre>
</div>

<p>
根据上面的公式, time_slice 的值的范围为 [800ms &#x2026; 100ms &#x2026; 5ms], 对
应的 nice 值为 [ -20 &#x2026; 0 &#x2026; 19 ]
</p>

<p>
另外, 无法是 SCHED_RR 还是 SCHED_NORMAL, 都是通过 task_timeslice 来计
算 time_slice 的, 所以 static_prio 对 SCHED_RR 也是有意义的.
</p>
</div>
</div>

<div id="outline-container-orgc31d232" class="outline-5">
<h5 id="orgc31d232"><span class="section-number-5">1.3.1.3</span> effective_prio</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
effective_prio 是根据 static_prio 和 sleep_avg 来计算 prio, 至于
sleep_avg 的计算, 是通过后面的 recalc_task_prio 函数
</p>

<p>
关于动态优先级:
</p>

<ol class="org-ol">
<li>只有 SCHED_NORMAL 能通过 effective_prio 来更新 prio</li>

<li>SCHED_RR 和 SCHED_FIFO 的 prio 与 static_prio 和 sleep_avg 无关, 只
有 rt_priority 有关</li>

<li>prio 相对于 static_prio 的 bonus 范围是 [-5 &#x2026;. +5]</li>
</ol>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">effective_prio</span>:
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23545;&#20110; rt_task, &#30452;&#25509;&#36820;&#22238;</span>
  <span style="color: #ff79c6; font-weight: bold;">if</span> (rt_task(p)):
    <span style="color: #ff79c6; font-weight: bold;">return</span> p-&gt;prio;
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23558; [0 .... MAX_SLEEP_AVG] &#26144;&#23556;&#20026; [-5 .... +5] &#30340; bonus, &#21363; sleep_avg</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#36234;&#38271;, bonus &#36234;&#22823;, &#30456;&#24212;&#30340; prio &#30340;&#20248;&#20808;&#32423;&#20250;&#36234;&#39640;</span>
  bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
  prio = p-&gt;static_prio - bonus;
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">prio &#19981;&#20250;&#27604; MAX_RT_PRIO (100) &#26356;&#39640;</span>
  <span style="color: #ff79c6; font-weight: bold;">if</span> (prio &lt; MAX_RT_PRIO):
    prio = MAX_RT_PRIO;
  <span style="color: #ff79c6; font-weight: bold;">if</span> (prio &gt; MAX_PRIO-1):
    prio = MAX_PRIO-1;
  <span style="color: #ff79c6; font-weight: bold;">return</span> prio
</pre>
</div>
</div>
</div>

<div id="outline-container-org56741dd" class="outline-5">
<h5 id="org56741dd"><span class="section-number-5">1.3.1.4</span> TASK_INTERACTIVE</h5>
</div>

<div id="outline-container-org0e0fc04" class="outline-5">
<h5 id="org0e0fc04"><span class="section-number-5">1.3.1.5</span> EXPIRED_STARVING</h5>
</div>
</div>

<div id="outline-container-org14e9349" class="outline-4">
<h4 id="org14e9349"><span class="section-number-4">1.3.2</span> try_to_wake_up</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">try_to_wake_up</span>:
  activate_task()
    recalc_task_prio()
      sleep_time = now - p-&gt;timestamp;
      <span style="color: #ff79c6; font-weight: bold;">if</span> (sleep_time &gt; NS_MAX_SLEEP_AVG):
        sleep_time = NS_MAX_SLEEP_AVG;
      p-&gt;sleep_avg += sleep_time;
      <span style="color: #ff79c6; font-weight: bold;">if</span> (p-&gt;sleep_avg &gt; NS_MAX_SLEEP_AVG):
        p-&gt;sleep_avg = NS_MAX_SLEEP_AVG;
      p-&gt;prio = effective_prio(p);
    __activate_task(p, rq);
      enqueue_task(p, rq-&gt;active);
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#25250;&#21344;  </span>
  <span style="color: #ff79c6; font-weight: bold;">if</span> (TASK_PREEMPTS_CURR(p, rq)):
    resched_task(rq-&gt;curr);
</pre>
</div>

<p>
recalc_task_prio 作用是当 task 从睡眠状态唤醒时 (try_to_wake_up) 时根
据 p-&gt;timestamp 计算本次睡眠的时间, 以此更新 sleep_avg 和 prio
</p>

<p>
p-&gt;timestamp 的赋值主要是在 schedule 函数中 (<a href="#orgc1fafcb">schedule</a>), 即 schedule 时
会将 prev-&gt;timestamp 和 next-&gt;timestamp 均设置为 now
</p>

<p>
对于 next 来说,下一次 schedule (next 被 schedule out) 时可以通过 now -
next-&gt;timestamp 得到 next 本次运行的时间 (run_time) 从而更新
next-&gt;sleep_avg -= run_time
</p>

<p>
对于 prev 来说, 分两种情况:
</p>

<ol class="org-ol">
<li>若 schedule 时 prev 是 sleeping 状态 (TASK_INTERRUPTIBLE 或
TASK_UNINTERRUPTIBLE), 则下一次 try_to_wake_up 时, 通过
prev-&gt;timestamp 可以得到 prev 本次 sleep 的时间</li>

<li>若 schedule 时 prev 是 running 状态 (TASK_RUNNING), 则显然
prev-&gt;timestamp 并不能用来计算 sleep 时间, 但没有关系, 因为后面
prev 并不会被 try_to_wake_up, 因为它还是 TASK_RUNNING, 并没有被放在
任何 waitqueue 里</li>
</ol>

<p>
recalc_task_prio 负责 sleep_avg 的增加, 而 schedule 负责 sleep_avg 的
减小, 最终 sleep_avg 是 sleeping 与 running 时间的差, 近似于 1s 内的平均
睡眠时间 (证明?)
</p>
</div>
</div>

<div id="outline-container-orgc1fafcb" class="outline-4">
<h4 id="orgc1fafcb"><span class="section-number-4">1.3.3</span> schedule</h4>
<div class="outline-text-4" id="text-1-3-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">schedule</span>:
  prev = current;
  rq = this_rq();
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">schedule &#21482;&#20250;&#20174; active &#20013;&#21462;&#36827;&#31243;</span>
  array = rq-&gt;active;
  <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>array-&gt;nr_active):
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">Switch the active and expired arrays.</span>
    rq-&gt;active = rq-&gt;expired;
    rq-&gt;expired = array;
    array = rq-&gt;active;
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#36825;&#19977;&#34892;&#20195;&#30721;&#21487;&#20197;&#24120;&#25968;&#26102;&#38388;&#20869;&#36873;&#25321; active &#20013;&#19968;&#20010;&#21160;&#24577;&#20248;&#20808;&#32423;&#26368;&#39640;&#30340;&#38142;&#34920;, &#25152;&#20197;</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#31216;&#20026; O(1) schedule</span>
  idx = sched_find_first_bit(array-&gt;bitmap);
  queue = array-&gt;queue + idx;
  next = list_entry(queue-&gt;next, task_t, run_list);
  <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>rt_task(next):
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23545;&#20110; conventional task, &#30452;&#25509;&#31227;&#21160;&#21040; active &#38431;&#23614;, &#22312;&#36825;&#19968;&#28857;&#19978;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">SCHED_FIFO &#21450; SCHED_RR &#19982;&#23427;&#19981;&#21516;: &#23545;&#20110; rt_task, &#21482;&#26377;&#20027;&#21160; yield &#25165;&#20250;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23548;&#33268;&#23427;&#34987;&#25918;&#22312;&#38431;&#23614;, &#34987;&#25250;&#21344;&#24182;&#19981;&#20250;&#23558;&#23427;&#25918;&#22312;&#38431;&#23614;</span>
    array = next-&gt;array;
    dequeue_task(next, array);
    enqueue_task(next, array);

  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">sleep_avg &#30456;&#20851;</span>
  <span style="color: #6272a4;">//</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">task_struct-&gt;timestamp &#26159;&#25351; task &#26368;&#36817;&#19968;&#27425;&#34987;&#35843;&#24230;&#30340;&#26102;&#38388; (schedule in</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#25110; out), &#25152;&#20197; run_time &#26159; prev &#26412;&#27425;&#36816;&#34892;&#30340;&#26102;&#38388;</span>
  run_time = now - prev-&gt;timestamp;
  prev-&gt;sleep_avg -= run_time;
  prev-&gt;timestamp = next-&gt;timestamp = now;
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">switch !</span>
  prepare_arch_switch(rq, next);
  prev = context_switch(rq, prev, next);
</pre>
</div>

<p>
可见, schedule 函数本身与 scheduler 关系不大, 它只是固定的从 active 中
取一个优先级最高的进程来调度, 所以若当前存在 real time process, 由于
real time process 的优先级必然比 conventional process 高, 极有可能导致
conventional process 的 starvation.
</p>

<p>
不同 scheduler 会以不同的方式影响进程在 active 和 expired 中的位置, 从
而影响 schedule, 具体参考 <a href="#orga0d2c67">各种 scheduler</a>
</p>
</div>
</div>

<div id="outline-container-org1e8104d" class="outline-4">
<h4 id="org1e8104d"><span class="section-number-4">1.3.4</span> set_tsk_need_resched</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
除了主动调用 schedule, kernel 还可以通过 set_tsk_need_resched 给当前
task 做个标记 TIF_NEED_RESCHED, 当 kernel 需要返回到 user mode 时 (从
system_call 或 interrupt, execetpion 返回到 user mode), 如果发现 task
的 TIF_NEED_RESCHED 置位, 则会调用 schedule, 实现用户进程的抢占 (user
preemption, 具体参考 interrupt).
</p>

<p>
常见的进程被抢占的场景:
</p>

<ol class="org-ol">
<li>scheduler_tick 时发现当前 task 的 time_slice 耗尽</li>

<li>try_to_wake_up 时被唤醒的 task 的优先级比当前 rq-&gt;curr 更高</li>

<li>通过 nice 或 sched_setscheduler 调整降低了当前 task 优先级或提高了
另一个 task 的优先级</li>

<li>load_balance 时 busiest CPU 的某个更高优先级的 task 被迁移到当前 CPU</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orga0d2c67" class="outline-3">
<h3 id="orga0d2c67"><span class="section-number-3">1.4</span> 各种 scheduler</h3>
<div class="outline-text-3" id="text-1-4">
<p>
各种 scheduler 并没有抽象成单独的实体, 所有 scheduler 的逻辑都散布在相
应的函数中, 例如 scheduler_tick, recalc_task_prio, schedule,
effective_prio, task_timeslice, set_user_nice, sys_sched_yield 等
</p>
</div>

<div id="outline-container-org69333fa" class="outline-4">
<h4 id="org69333fa"><span class="section-number-4">1.4.1</span> SCHED_FIFO</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
SCHED_FIFO 是 real time scheduler, 它的主要特征有:
</p>

<ol class="org-ol">
<li>完全不考虑 time slice</li>

<li>sched_yield 会导致它被移动到相应链表的队尾</li>

<li>只有下面三种情况下它的执行才会被打断:

<ol class="org-ol">
<li>被高优先级的进程抢占</li>

<li>被 IO 阻塞</li>

<li>sched_yield</li>
</ol></li>

<li>当它被高优先级进程抢占后, 仍然会位于链表的队头</li>

<li>它的 prio (动态优先级) 是固定的, 与 static_prio 和 sleep_avg 并没有
关系</li>
</ol>
</div>
</div>

<div id="outline-container-org0b34aef" class="outline-4">
<h4 id="org0b34aef"><span class="section-number-4">1.4.2</span> SCHED_RR</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
SCHED_RR 也是一种 real time scheduler, 在 SCHED_FIFO 上加入了
roundrobin, 避免一个进程长时间占用 CPU 导致同优先级的其它进程无法被调
度. 当它运行时间超过 time_slice 时, 会被调度出去并移动到链表的队尾.
</p>

<p>
SCHED_RR 时间片长度与普通进程一样, 都是基于 static_prio
(task_timeslice 函数), 所以对于 SCHED_RR 来说, 通过 nice 虽然不能调整
它的 prio, 却可以通过调整它的 static_prio 来调整 time_slice 的大小
</p>
</div>
</div>

<div id="outline-container-orgeb2b0dc" class="outline-4">
<h4 id="orgeb2b0dc"><span class="section-number-4">1.4.3</span> SCHED_NORMAL</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
SCHED_NORMAL 是 conventional (非 real time) 进程使用的 scheduler, 它的
主要特征:
</p>

<ol class="org-ol">
<li>它的动态优先级低于 real time process, 所以它有可能因为 real time 进
程而 startving</li>

<li>与 SCHED_RR 一样, 它是基于 roundrobin 的, 而且 time_slice 长度也是
由 static_prio 决定的</li>

<li>它通过 sleep_avg 和 static_prio 来调整 prio, sleep_avg 越大, prio
越高</li>

<li>通过 sleep_avg 检测进程是否是 interactive, 对于 interactive 进程,
当它 time_slice 耗尽时, 会被再次放到 active 相应链表的队尾, 而对于
batch 进程, 会被放到 expired 中, 通过这种方式使 interactive 进程更
多的执行, 但为了防止 expired 中的进程发生 starvation, interactive
进程有时也会被直接放在 expired 中 (参考 scheduler_tick)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org4925a30" class="outline-3">
<h3 id="org4925a30"><span class="section-number-3">1.5</span> CPU 负载均衡</h3>
<div class="outline-text-3" id="text-1-5">
<p>
在 O(1) scheduler 之前 (O(n) scheduler), 所有 CPU 共享同一个 runqueue,
</p>

<p>
这样的优点是:
</p>

<ol class="org-ol">
<li>可以充分利用所有 CPU</li>

<li>所有进程都可以公平的使用所有 CPU</li>
</ol>

<p>
但也存在缺点:
</p>

<ol class="org-ol">
<li>多个 CPU 在使用同一个 runqueue 时会有 contention</li>

<li>cache locality 很差, 因为共享 runqueue 会导致进程频繁在不同的 CPU
中迁移</li>
</ol>

<p>
因此 O(1) 针对每个 CPU 都有一个 runqueue, CPU 只会从它自己的 runqueue
中取 task 执行, 虽然克服了前面的缺点, 但前面的优点也成为它的缺点: 有可
能某个 CPU 的 task 很多, 而有些 CPU 很空闲, 导致 CPU 吞吐率下降, 而且
task 无法公平的调度. 所以 O(1) scheduler 加入了 CPU 负载均衡 (load
balance): 将多核的负载平衡一下, 避免有些 CPU 过忙或过闲.
</p>

<p>
load balance 主要有两种:
</p>

<ol class="org-ol">
<li>pull task</li>

<li>migrate(push) task</li>
</ol>
</div>

<div id="outline-container-orga8dba54" class="outline-4">
<h4 id="orga8dba54"><span class="section-number-4">1.5.1</span> pull task</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
pull task 即 "把其它更忙的 cpu 的 task 拉到当前 cpu 执行", 在
scheduler_tick 时会通过 load_balance 实现 pull task
</p>
</div>

<div id="outline-container-org2318c29" class="outline-5">
<h5 id="org2318c29"><span class="section-number-5">1.5.1.1</span> load_balance</h5>
<div class="outline-text-5" id="text-1-5-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">scheduler_tick</span>:
  rebalance_tick(cpu, rq, NOT_IDLE);
    this_load = this_rq-&gt;nr_running * SCHED_LOAD_SCALE;
    this_rq-&gt;cpu_load = (old_load + this_load) / 2;
    interval = sd-&gt;balance_interval;
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#36890;&#36807; interval &#38480;&#21046; load_balance &#30340;&#39057;&#29575;    </span>
    <span style="color: #ff79c6; font-weight: bold;">if</span> (j - sd-&gt;last_balance &gt;= interval):
      sd-&gt;last_balance += interval;
      load_balance(this_cpu, this_rq, sd, idle)
        <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#26681;&#25454; loading (nr_running) &#25214;&#19968;&#20010;&#26368;&#32321;&#24537;&#30340; cpu        </span>
        busiest = find_busiest_queue(group);
        move_tasks(this_rq, this_cpu, busiest,imbalance, sd, idle);
          <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#20248;&#20808;&#20174; expired &#20013;&#36873;&#25321;          </span>
          <span style="color: #ff79c6; font-weight: bold;">if</span> (busiest-&gt;expired-&gt;nr_active):
            array = busiest-&gt;expired;
            dst_array = this_rq-&gt;expired;
          <span style="color: #ff79c6; font-weight: bold;">else</span>:
            array = busiest-&gt;active;
            dst_array = this_rq-&gt;active;
          <span style="color: #bd93f9;">LOOP</span>:
          <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#25214;&#21040; busiest &#20013;&#30340;&#19968;&#20010; task          </span>
          idx = find_next_bit(array-&gt;bitmap, MAX_PRIO, idx);
          head = array-&gt;queue + idx;
          curr = head-&gt;prev;
          tmp = list_entry(curr, task_t, run_list);
          <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#21028;&#26029; tmp &#26159;&#21542;&#21487;&#20197;&#20174; busiest &#36801;&#31227;&#21040; this_cpu          </span>
          <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>can_migrate_task(tmp, busiest, this_cpu, sd, idle)):
            <span style="color: #ff79c6; font-weight: bold;">goto</span> <span style="color: #bd93f9;">LOOP</span>
          <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#20174; busiest &#36801;&#31227;&#21040; this_cpu                </span>
          pull_task(busiest, src_array, tmp, this_rq, dst_array, this_cpu);
            dequeue_task(tmp, src_array);
            src_rq-&gt;nr_running--;
            this_rq-&gt;nr_running++;
            enqueue_task(tmp, dst_array);
            <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#33509;&#36801;&#31227;&#21040; this_rq &#30340;&#36827;&#31243;&#30340;&#20248;&#20808;&#32423;&#39640;&#20110; this_rq-&gt;curr, &#21017;&#36890;&#36807;</span>
            <span style="color: #6272a4;">// </span><span style="color: #6272a4;">resched_task &#25250;&#21344; this_rq-&gt;curr            </span>
            <span style="color: #ff79c6; font-weight: bold;">if</span> (TASK_PREEMPTS_CURR(p, this_rq)):
              resched_task(this_rq-&gt;curr);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbbdb82a" class="outline-5">
<h5 id="orgbbdb82a"><span class="section-number-5">1.5.1.2</span> can_migrate_task</h5>
<div class="outline-text-5" id="text-1-5-1-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">can_migrate_task</span>:
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#19977;&#31181;&#24773;&#20917;&#19979; migrate &#20250;&#22833;&#36133;:</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">1. p &#26159; busiest-&gt;current, &#21363;&#23427;&#27491;&#22312; busiest &#19978;&#36816;&#34892;, &#26174;&#28982;&#26080;&#27861;&#34987;</span>
  <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">migrate</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">2. p-&gt;cpus_allowed &#19981;&#21253;&#25324; this_cpu (&#36890;&#36807; sched_setaffinity &#35774;&#32622;&#30340;)</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">3. task_hot, &#21363; (now - p-&gt;last_ran) &#23567;&#20110;&#26576;&#20010;&#38376;&#38480;, &#35828;&#26126; task &#26368;&#36817;&#36816;&#34892;</span>
  <span style="color: #6272a4;">//    </span><span style="color: #6272a4;">&#36807;, cache is hot, &#24212;&#35813;&#36991;&#20813; migrate        </span>
  <span style="color: #ff79c6; font-weight: bold;">if</span> (task_running(rq, p)):
    <span style="color: #ff79c6; font-weight: bold;">return</span> 0;
  <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>cpu_isset(this_cpu, p-&gt;cpus_allowed)):
    <span style="color: #ff79c6; font-weight: bold;">return</span> 0;
  <span style="color: #ff79c6; font-weight: bold;">if</span> (task_hot(p, rq-&gt;timestamp_last_tick, sd)):
    <span style="color: #ff79c6; font-weight: bold;">return</span> 0;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3b07a1a" class="outline-4">
<h4 id="org3b07a1a"><span class="section-number-4">1.5.2</span> push task</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
push task 即 "将 task push 到空闲的 cpu 去执行", 一个例子就是 do_execve 时
的 sched_exec
</p>
</div>

<div id="outline-container-orga2c71c7" class="outline-5">
<h5 id="orga2c71c7"><span class="section-number-5">1.5.2.1</span> sched_exec</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">do_execve</span>:
  sched_exec();
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#24403;&#21069; cpu &#24050;&#32463;&#24456;&#31354;&#38386;, &#19981;&#20877; push    </span>
    <span style="color: #ff79c6; font-weight: bold;">if</span> (this_rq()-&gt;nr_running &lt;= 1):
      <span style="color: #ff79c6; font-weight: bold;">goto</span> <span style="color: #bd93f9;">out</span>;
    new_cpu = find_idlest_cpu(current, this_cpu, sd);
    sched_migrate_task(current, new_cpu);
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#38656;&#35201;&#32771;&#34385; affinity      </span>
      <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>cpu_isset(dest_cpu, p-&gt;cpus_allowed):
        <span style="color: #ff79c6; font-weight: bold;">goto</span> <span style="color: #bd93f9;">out</span>;
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">migrate_task &#20250;&#21796;&#37266; migrate_thread &#21435;&#23436;&#25104; task &#30340;&#36801;&#31227;</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4; background-color: #373844;">TODO</span><span style="color: #6272a4;">: &#20026;&#20160;&#20040;&#38656;&#35201; migrate_thread      </span>
      migrate_task(p, dest_cpu, &amp;req)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf2b1fb1" class="outline-3">
<h3 id="orgf2b1fb1"><span class="section-number-3">1.6</span> 相关 API</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-orge975c4a" class="outline-4">
<h4 id="orge975c4a"><span class="section-number-4">1.6.1</span> nice</h4>
<div class="outline-text-4" id="text-1-6-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">set_user_nice</span>:
  <span style="color: #ff79c6; font-weight: bold;">if</span> (rt_task(p)):
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23545;&#20110; rt_task, static_prio &#20063;&#20250;&#34987; nice &#20462;&#25913;, &#22240;&#20026;&#35745;&#31639; time_slice</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#36827;&#38656;&#35201;&#29992;&#21040;.</span>
    p-&gt;static_prio = NICE_TO_PRIO(nice);
    <span style="color: #ff79c6; font-weight: bold;">goto</span> <span style="color: #bd93f9;">out</span>;

  array = p-&gt;array;
  <span style="color: #ff79c6; font-weight: bold;">if</span> (array):
    dequeue_task(p, array);

  old_prio = p-&gt;prio;
  new_prio = NICE_TO_PRIO(nice);
  delta = new_prio - old_prio;
  p-&gt;static_prio = NICE_TO_PRIO(nice);
  p-&gt;prio += delta;

  <span style="color: #ff79c6; font-weight: bold;">if</span> (array):
    enqueue_task(p, array);
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#22914;&#26524;&#35201;&#25552;&#39640;&#26576;&#20010; task &#30340;&#20248;&#20808;&#32423;, &#25110;&#32773;&#35201;&#38477;&#20302;&#24403;&#21069; task &#30340;&#20248;&#20808;&#32423;, &#21017;&#36890;&#36807;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">resched_task &#35843;&#29992; scheduler, &#23454;&#29616; task &#30340;&#25250;&#21344;</span>
    <span style="color: #ff79c6; font-weight: bold;">if</span> (delta &lt; 0 || (delta &gt; 0 &amp;&amp; task_running(rq, p))):
      resched_task(rq-&gt;curr);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4181cf5" class="outline-4">
<h4 id="org4181cf5"><span class="section-number-4">1.6.2</span> sched_yield</h4>
<div class="outline-text-4" id="text-1-6-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">sys_sched_yield</span>:
  <span style="color: #f8f8f2;">runqueue_t</span> *<span style="color: #f8f8f2;">rq</span> = this_rq_lock();
  <span style="color: #f8f8f2;">prio_array_t</span> *<span style="color: #f8f8f2;">array</span> = current-&gt;array;
  <span style="color: #f8f8f2;">prio_array_t</span> *<span style="color: #f8f8f2;">target</span> = rq-&gt;expired;
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23545;&#20110; rt_task &#26469;&#35828;, yield &#24182;&#19981;&#20250;&#23558; task &#31227;&#21160;&#21040; expired, &#32780;&#20165;&#20165;&#26159;&#31227;&#21160;</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#21040; active &#30340;&#38431;&#23614;</span>
  <span style="color: #ff79c6; font-weight: bold;">if</span> (rt_task(current)):
    target = rq-&gt;active;

  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23545;&#20110; rt_task &#26469;&#35828;, &#36890;&#36807; dequeue_task &#21644; enqueue_task &#23558; task &#31227;&#21160;&#21040;</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">active &#38431;&#23614;, &#23545;&#20110; conventional task &#26469;&#35828;, &#23558; task &#20174; active &#31227;&#21160;&#21040;</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">expired.</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#20294;&#30475;&#36215;&#26469; task &#30340; time_slice &#24182;&#27809;&#26377;&#36890;&#36807; task_timeslice &#36827;&#20837;&#34917;&#20805;, &#25152;&#20197;</span>
  <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#23427;&#23558;&#34987; schedule &#26102;&#36824;&#20250;&#20351;&#29992;&#26087;&#30340; time_slice?</span>
  dequeue_task(current, array);
  enqueue_task(current, target);

  schedule();
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a80934" class="outline-4">
<h4 id="org3a80934"><span class="section-number-4">1.6.3</span> sched_setscheduler</h4>
</div>

<div id="outline-container-org64b8f58" class="outline-4">
<h4 id="org64b8f58"><span class="section-number-4">1.6.4</span> sched_setaffinity</h4>
</div>

<div id="outline-container-orgb2a665b" class="outline-4">
<h4 id="orgb2a665b"><span class="section-number-4">1.6.5</span> fork</h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #bd93f9;">fork</span>:
  sched_fork(p)
    p-&gt;state = TASK_RUNNING;
    p-&gt;array = <span style="color: #bd93f9;">NULL</span>;
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#29238;&#23376;&#36827;&#31243;&#30340; time_slice &#37117;&#21464;&#20026;&#29238;&#36827;&#31243;&#30340;&#19968;&#21322;</span>
    p-&gt;time_slice = (current-&gt;time_slice + 1) &gt;&gt; 1;
    current-&gt;time_slice &gt;&gt;= 1;
  wake_up_new_task(p)
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#35745;&#31639;&#21160;&#24577;&#20248;&#20808;&#32423;, &#23545;&#20110; conventional process, prio &#30001; static_prio &#21644;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">sleep_avg &#20915;&#23450;, &#23545;&#20110; real time process, prio &#19981;&#20250;&#20877;&#34987;&#20462;&#25913;, &#30452;&#25509;&#20351;</span>
    <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#29992; parent fork &#20986;&#26469;&#30340; prio</span>
    p-&gt;prio = effective_prio(p);
    <span style="color: #ff79c6; font-weight: bold;">if</span> (<span style="color: #bd93f9;">!</span>(clone_flags &amp; CLONE_VM)):
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">CLONE_VM &#27809;&#26377;&#32622;&#20301;, &#20808;&#35843;&#24230;&#23376;&#36827;&#31243;&#25191;&#34892;, &#22240;&#20026;&#26377;&#21487;&#33021;&#23376;&#36827;&#31243;&#20250;&#30452;&#25509;&#35843;&#29992;</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">exec. &#36890;&#36807;&#35753;&#23376;&#36827;&#31243;&#20808;&#25191;&#34892; exec, &#21487;&#20197;&#36991;&#20813;&#29238;&#36827;&#31243;&#20889;&#20869;&#23384;&#26102;&#23548;&#33268;&#30340; COW,</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#22914;&#26524; CLONE_VM &#32622;&#20301;, &#21017;&#19981;&#20250;&#21457;&#29983; COW, &#20248;&#20808;&#35753;&#29238;&#36827;&#31243;&#25191;&#34892;</span>
      p-&gt;prio = current-&gt;prio;
      list_add_tail(&amp;p-&gt;run_list, &amp;current-&gt;run_list);
      p-&gt;array = current-&gt;array;
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">"&#35753;&#23376;&#36827;&#31243;&#20808;&#25191;&#34892;"&#26159;&#36890;&#36807;&#20004;&#28857;&#20570;&#21040;&#30340;:</span>
      <span style="color: #6272a4;">//</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">1. &#36890;&#36807; list_add_tail (&#32780;&#19981;&#26159;&#36890;&#24120;&#30340; enqueue_task) &#23558; p &#28155;&#21152;&#21040;</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">active &#38142;&#34920;&#20013;, &#20294;&#20301;&#20110; current &#20043;&#21069;</span>
      <span style="color: #6272a4;">//</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">2. set_need_resched &#20250;&#20351; current &#36827;&#31243;&#36820;&#22238;&#21040; user mode &#21069;&#21457;&#29983;</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">schedule, &#30001;&#20110; p &#19978;&#19968;&#27493;&#24050;&#32463;&#22312;&#38142;&#34920;&#20013; current &#20043;&#21069;, &#25152;&#20197;&#23427;&#26497;&#26377;&#21487;&#33021;</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">&#22312; schedule &#34987;&#36873;&#20013;, &#20294;&#21363;&#20351;&#27809;&#26377;&#36873;&#20013; p, &#20063;&#21487;&#20197;&#20445;&#35777; p &#32943;&#23450;&#22312;</span>
      <span style="color: #6272a4;">// </span><span style="color: #6272a4;">current &#20043;&#21069;&#34987;&#35843;&#24230;</span>
      set_need_resched();
    <span style="color: #ff79c6; font-weight: bold;">else</span>:
      enqueue_task(p, rq-&gt;active);
      rq-&gt;nr_running++;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b3e486" class="outline-4">
<h4 id="org6b3e486"><span class="section-number-4">1.6.6</span> See also</h4>
<div class="outline-text-4" id="text-1-6-6">
<ol class="org-ol">
<li><a href="https://en.wikipedia.org/wiki/O(1)_scheduler">O(1) scheduler from Wikipedia</a></li>

<li><a href="http://www.informit.com/articles/article.aspx?p=101760&amp;seqNum=2">The Linux Process Scheduler By Robet Love</a></li>

<li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-kn26sch/">Linux 2.6 调度系统分析 from IBM developerWorks</a></li>

<li><a href="http://www.cs.columbia.edu/~junfeng/10sp-w4118/lectures/l14-sched-linux.pdf">Scheduling in Linux from cs.columbia.edu</a></li>

<li>sched-design.txt from kernel documentation</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
时钟中断是每 (1/HZ) s 一次, HZ 一般为 1000, 所以时钟中断为 1ms
一次
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Date: <span class="timestamp-wrapper"><span class="timestamp">&lt;2016-07-14 Thu&gt;</span></span></p>
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2016-08-30 Tue 02:50</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
