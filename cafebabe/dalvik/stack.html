<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Stack</title>
<!-- 2014-04-30 Wed 16:53 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Stack</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Stack</a>
<ul>
<li><a href="#sec-1-1">1.1. dalvik stack 初始化</a></li>
<li><a href="#sec-1-2">1.2. stack frame 结构</a></li>
<li><a href="#sec-1-3">1.3. 关于 dalvik 的寄存器</a></li>
<li><a href="#sec-1-4">1.4. stack frame 的维护</a></li>
<li><a href="#sec-1-5">1.5. StackSaveArea</a></li>
<li><a href="#sec-1-6">1.6. InterpSave</a></li>
<li><a href="#sec-1-7">1.7. breakFrame 与异常处理</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Stack</h2>
<div class="outline-text-2" id="text-1">
<p>
dalvik 的 stack 是用 malloc 在 native 的堆上分配的(或者用 mmap 分配的,由
编译选项决定), 和 native 的 stack没有任何关系.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> dalvik stack 初始化</h3>
<div class="outline-text-3" id="text-1-1">
<p>
每一个 dalvik thread 都有一个 dalvik stack, 所以 dalvik stack 初始化是
在 allocThread 时初始化的. 
</p>

<p>
dvm 启动时调用 dvmThreadStartup 或 JNI AttachCurrentThread 时会调用
allocThread 方法
</p>

<div class="org-src-container">

<pre class="src src-text">Thread* allocThread(int interpStackSize)
  stackBottom = (u1*) malloc(interpStackSize);
  // &#25110; stackBottom = (u1*) mmap(NULL, interpStackSize, ...)
  thread-&gt;interpStackSize = interpStackSize;
  thread-&gt;interpStackStart = stackBottom + interpStackSize;
  thread-&gt;interpStackEnd = stackBottom + STACK_OVERFLOW_RESERVE;
  dvmInitInterpreterState(thread);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> stack frame 结构</h3>
<div class="outline-text-3" id="text-1-2">
<p>
From Stack.h:
</p>

<pre class="example">
    Low addresses (0x00000000)

                     +- - - - - - - - -+
                     -  out0           -
                     +-----------------+  &lt;-- stack ptr (top of stack)
                     +  VM-specific    +
                     +  internal goop  +
                     +-----------------+  &lt;-- curFrame: FP for cur function
                     +  v0 == local0   +
+-----------------+  +-----------------+
+  out0           +  +  v1 == in0      +
+-----------------+  +-----------------+
+  out1           +  +  v2 == in1      +
+-----------------+  +-----------------+
+  VM-specific    +
+  internal goop  +
+-----------------+  &lt;-- frame ptr (FP) for previous function
+  v0 == local0   +
+-----------------+
+  v1 == local1   +
+-----------------+
+  v2 == in0      +
+-----------------+
+  v3 == in1      +
+-----------------+
+  v4 == in2      +
+-----------------+
-                 -
-                 -
-                 -
+-----------------+  &lt;-- interpStackStart

    High addresses (0xffffffff)
</pre>

<p>
其中的 VM-specific internal goop 实际上就是 StackSaveArea 结构.
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 关于 dalvik 的寄存器</h3>
<div class="outline-text-3" id="text-1-3">
<p>
dalvik 中定义的寄存器如 v0/v1.. 实际上并不是真正的 cpu 寄存器, 而是对
应于 stack frame 中的一定区域:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #cb4b16;"># define</span> <span style="color: #268bd2;">GET_REGISTER</span>(<span style="color: #268bd2;">_idx</span>)                 (fp[(_idx)])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> stack frame 的维护</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> interp -&gt;</h4>
<div class="outline-text-4" id="text-1-4-1">
</div><div id="outline-container-sec-1-4-1-1" class="outline-5">
<h5 id="sec-1-4-1-1"><span class="section-number-5">1.4.1.1</span> invokeMethod 时 push stack frame</h5>
<div class="outline-text-5" id="text-1-4-1-1">
<div class="org-src-container">

<pre class="src src-text">GOTO_TARGET(invokeMethod, const Method* _methodToCall,...)
  StackSaveArea* newSaveArea;
  u4* newFp;

  // registersSize &#21253;&#21547;&#21442;&#25968;, &#23616;&#37096;&#21464;&#37327;&#31561;, &#20294;&#19981;&#21253;&#21547; outs
  // &#22914; stack.org &#25152;&#36848;,  fp &#25351;&#21521; StackSaveArea &#30340;&#24213;&#37096;(&#39640;&#22320;&#22336;), &#25152;&#20197;&#26377;
  // SAVEAREA_FROM_FP &#21644; FP_FROM_SAVEAREA &#36825;&#20004;&#20010;&#23439;:
  // SAVEAREA_FROM_FP(_fp)   ((StackSaveArea*)(_fp) -1)

  newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall-&gt;registersSize;
  newSaveArea = SAVEAREA_FROM_FP(newFp);
  newSaveArea-&gt;prevFrame = fp;
  // pc &#26159;&#24403;&#28982;&#20989;&#25968;&#20989;&#25968;&#20869;&#30340;&#31243;&#24207;&#35745;&#25968;&#22120;
  newSaveArea-&gt;savedPc = pc;
  newSaveArea-&gt;method = methodToCall;

  if (!dvmIsNativeMethod(methodToCall)):
    /*
    * "Call" interpreted code.  Reposition the PC, update the
    * frame pointer and other local state, and continue.
    */
    curMethod = methodToCall;
    self-&gt;interpSave.method = curMethod;
    pc = methodToCall-&gt;insns;
    fp = newFp;
    self-&gt;interpSave.curFrame = fp;
    FINISH(0);
      inst = FETCH(0);
      goto *handlerTable[INST_INST(inst)];
  else:
    self-&gt;interpSave.curFrame = newFp;
    // jni call bridge: dvmCallJNIMethod
    (*methodToCall-&gt;nativeFunc)(newFp, &amp;retval, methodToCall, self);
    // pop stack frame
    self-&gt;interpSave.curFrame = newSaveArea-&gt;prevFrame;
    fp = newSaveArea-&gt;prevFrame;
    FINISH(3);
</pre>
</div>

<p>
构造 stack frame 的过程:
</p>
<ol class="org-ol">
<li>根据新函数的 registersSize 生成一个新的 fp 和 StackSaveArea
</li>
<li>将当前的 fp 保存到 StackSaveArea 的 prevFrame
</li>
<li>将当前的 pc 保存到 StackSaveArea 的 savedPc
</li>
<li>设置新的 fp 和 pc, 然后根据 pc 获得指令, 再根据跳转表跳转
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-1-2" class="outline-5">
<h5 id="sec-1-4-1-2"><span class="section-number-5">1.4.1.2</span> invokeMethod 时 pop stack frame</h5>
<div class="outline-text-5" id="text-1-4-1-2">
<div class="org-src-container">

<pre class="src src-text">GOTO_TARGET(returnFromMethod)
  StackSaveArea* saveArea;
  saveArea = SAVEAREA_FROM_FP(fp);
  fp = (u4*)saveArea-&gt;prevFrame;
  curMethod = SAVEAREA_FROM_FP(fp)-&gt;method;
  pc = saveArea-&gt;savedPc;
  FINISH(3);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-1-3" class="outline-5">
<h5 id="sec-1-4-1-3"><span class="section-number-5">1.4.1.3</span> To summarize</h5>
<div class="outline-text-5" id="text-1-4-1-3">
<p>
由 interp 发起的 invokeMethod 会 push 一个 stack frame, 若
methodToCall 也是 interp, 则 fp, pc 会被设置为新的 frame 的相关值, 然
后调用. 若 methodToCall 是 native, 则并不会设置 pc, fp, 因为对 native
方法不需要使用这两个值
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> dvmInvokeMethod -&gt;</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
在 jni 中可以通过 dvmInvokeMethod 调用 java 类的 method, 特别的, 启动
虚拟机也是通过该方法. 
</p>

<div class="org-src-container">

<pre class="src src-text">void dvmCallMethodV(self,method, obj, pResult...)
  clazz = callPrep(self, method, obj, false);
    dvmPushInterpFrame(self, method)
      if (self-&gt;interpSave.curFrame != NULL):
        stackPtr = (u1*) SAVEAREA_FROM_FP(self-&gt;interpSave.curFrame);
      else
        stackPtr = self-&gt;interpStackStart;
      // &#26500;&#36896;&#19968;&#20010; break frame, &#21644;&#19968;&#20010;&#23545;&#35937;&#20110; method &#35843;&#29992;&#30340; StackSaveArea
      // &#24182;&#36171;&#20540;&#32473; self-&gt;interpSave.curFrame
      self-&gt;interpSave.curFrame = FP_FROM_SAVEAREA(saveBlock);
  if (dvmIsNativeMethod(method)):
    (*method-&gt;nativeFunc)((u4*)self-&gt;interpSave.curFrame, pResult, method, self);
  else:    
    dvmInterpret(self, method, pResult);
  dvmPopFrame(self);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> 关于函数返回值</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
函数参数在调用时会通过 outs 放到新函数的 stack frame 中, 但返回值如何
返回? 
通过设置 interpretor 自身的一个变量:  retval, 例如:
</p>

<div class="org-src-container">

<pre class="src src-c">HANDLE_OPCODE(OP_RETURN <span style="color: #586e75; font-style: italic;">/*</span><span style="color: #586e75; font-style: italic;">vAA</span><span style="color: #586e75; font-style: italic;">*/</span>)
vsrc1 = INST_AA(inst);
retval.i = GET_REGISTER(vsrc1);
GOTO_returnFromMethod();
OP_END
</pre>
</div>

<p>
以及调用 native 函数时:
</p>
<div class="org-src-container">

<pre class="src src-c">(*methodToCall-&gt;nativeFunc)(newFp, &amp;retval, methodToCall, self);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> StackSaveArea</h3>
<div class="outline-text-3" id="text-1-5">
<p>
StackSaveArea 是位于 stack frame 中用了保存上一个 frame 相关信息的结构
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">StackSaveArea</span> {
    <span style="color: #b58900;">u4</span>*         <span style="color: #268bd2;">prevFrame</span>;

    <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">saved program counter (from method in caller's frame) </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">u2</span>*   <span style="color: #268bd2;">savedPc</span>;

    <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">pointer to method we're *currently* executing; handy for exceptions </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">Method</span>* <span style="color: #268bd2;">method</span>;

};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> InterpSave</h3>
<div class="outline-text-3" id="text-1-6">
<p>
每一个 dalvik thread 都有一个 InterpSave 对象,
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">InterpSave</span> {
    <span style="color: #859900;">const</span> <span style="color: #b58900;">u2</span>*       <span style="color: #268bd2;">pc</span>;         <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Dalvik PC</span>
    <span style="color: #b58900;">u4</span>*             <span style="color: #268bd2;">curFrame</span>;   <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Dalvik frame pointer</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">Method</span>    *<span style="color: #268bd2;">method</span>;    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Method being executed</span>
    <span style="color: #b58900;">DvmDex</span>*         <span style="color: #268bd2;">methodClassDex</span>;
    <span style="color: #b58900;">JValue</span>          <span style="color: #268bd2;">retval</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">...</span>
};
</pre>
</div>

<p>
之所以 thread 需要保存这个对象, 是因为 interpretor 可以嵌套调用, 即:
dvmCallMethodV -&gt; interp -&gt; jni -&gt; dvmCallMethodV -&gt; interp
</p>

<p>
这些函数调用之间必须把 fp 保存下来, 而无法把 fp 做为一个简单的函数内部
的局部变量. 所以 dalvik 选择用 thread-&gt;interpSave 在函数调用之间保存
fp, 否则用参数在各个函数间传来传去太麻烦了&#x2026;
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> breakFrame 与异常处理</h3>
<div class="outline-text-3" id="text-1-7">
<p>
当 native 函数通过 dvmCallMethodV 调用其他函数时 (native 或 interp),会
先 push 一个 break frame, 然后再 push 一个真正的 frame. 这个 break
frame 的作用是为了处理异常. 因为异常发生时, 正常情况下会通过不断的
unrolling stack frame 的方式来找到真正的 catcher. 若 stack frame 中某个
frame 代表着 native 函数, 则 stack frame 的 unrolling 必须停止并停止对
异常的处理: 因为 native 函数本身一定有一个 ExceptionOccurred 的函数会来
检查是否有异常.
</p>

<div class="org-src-container">

<pre class="src src-text">HANDLE_OPCODE(OP_THROW /*vAA*/)
  dvmSetException(self, obj);
  GOTO_exceptionThrown();

GOTO_TARGET(exceptionThrown)
  /* We need to unroll to the catch block or the nearest "break"
  * frame.
  *
  * A break frame could indicate that we have reached an intermediate
  * native call, or have gone off the top of the stack and the thread
  * needs to exit.  Either way, we return from here, leaving the
  * exception raised.
  *
  * If we do find a catch block, we want to transfer execution to
  * that point.
  */
  catchRelPc = dvmFindCatchBlock(self, pc - curMethod-&gt;insns,exception, false, (void**)(void*)&amp;fp);
    while (true):
      StackSaveArea* saveArea = SAVEAREA_FROM_FP(fp);
      catchAddr = findCatchInMethod(self, saveArea-&gt;method, relPc, exception-&gt;clazz);
        /*
        * Search the method's list of exceptions for a match.
        * Returns the offset of the catch block on success, or -1 on failure.
        */
        // &#36890;&#36807;&#26597;&#25214; method &#30340;&#24322;&#24120;&#34920;&#26469;&#30830;&#23450; exceptions-&gt;clazz &#26159;&#21542;&#33021;&#34987;
        // saveArea-&gt;method catch
      if (catchAddr &gt;= 0)
        break;
      if (dvmIsBreakFrame((u4*)saveArea-&gt;prevFrame)):
        // &#24403;&#21069;&#26041;&#27861;&#20013;&#27809;&#26377;&#25214;&#21040;&#23545;&#24212;&#30340; catcher, &#19988; prevFrame &#26159; break
        // frame, &#21017;&#26080;&#27861;&#32487;&#32493; unrolling, &#36820;&#22238; -1
        break;
      // unrolling
      else:
        fp = saveArea-&gt;prevFrame;
        // &#33719;&#24471;&#19978;&#19968;&#20010;&#20989;&#25968;&#20013;&#23545;&#24212;&#30340; relPc
        relPc = saveArea-&gt;savedPc - SAVEAREA_FROM_FP(fp)-&gt;method-&gt;insns;
    // while end  
  // &#25214;&#21040;&#20102; catchAddr
  if (catchRelPc &lt; 0):
    // &#27809;&#25214;&#21040; catcher, &#30452;&#25509;&#36864;&#20986; interpeter
    // interpeter &#36864;&#20986;&#21518;, native &#20195;&#30721;&#20250;&#36127;&#36131;&#28165;&#29702; stack frame
    // &#22312;&#36864;&#20986;&#20043;&#21069;&#38656;&#35201;&#35843;&#29992; dvmSetException, &#22240;&#20026; native &#20195;&#30721;&#30340;
    // ExceptionOccurred &#20381;&#36182;&#36825;&#20010;&#35843;&#29992;
    dvmSetException(self, exception);
    GOTO_bail();
  else:
    // self-&gt;interpSave.curFrame &#22312; dvmFindCatchBlock &#26102;&#24050;&#32463;&#34987;&#36171;&#20026;&#27491;&#30830;
    // &#30340;&#20540;
    curMethod = SAVEAREA_FROM_FP(fp)-&gt;method;
    self-&gt;interpSave.method = curMethod;
    //methodClass = curMethod-&gt;clazz;
    methodClassDex = curMethod-&gt;clazz-&gt;pDvmDex;
    pc = curMethod-&gt;insns + catchRelPc;
    FINISH(0);
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-04-30 Wed 16:53</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
