<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>JVM</title>
<!-- 2014-04-09 Wed 13:47 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">JVM</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Java VM</a>
<ul>
<li><a href="#sec-1-1">1.1. String.intern()</a></li>
<li><a href="#sec-1-2">1.2. Constant Pool</a></li>
<li><a href="#sec-1-3">1.3. Class Loader</a></li>
<li><a href="#sec-1-4">1.4. invokeXXX</a></li>
<li><a href="#sec-1-5">1.5. GC</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Java VM</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> String.intern()</h3>
<div class="outline-text-3" id="text-1-1">
<p>
see also <i>constant pool</i>
</p>

<p>
String.intern()与constant pool的关系?
VM 运行后, VM 本身会维护一个 internedStrings&lt;char *, String&gt; 的 HashMap, String.intern() 的作用是:
</p>
<ul class="org-ul">
<li>从 internedStrings 中查找是否已存在, 若不存在, 向 map 中插入一条记录, 最后返回 map的value,
</li>
<li>所以 assert(new String("abc").intern() == new String("abc").intern());

<p>
String.intern() 使用的 internedStrings 本身和 constant pool 并没有直接关系, 但:
</p>
</li>
</ul>
<pre class="example">
String s1="abc";
String s2=new String("abc");
assert(s1==s2.intern());
</pre>
<p>
有两种可能:
</p>
<ol class="org-ol">
<li>VM 在 resolve class (resolve constant pool) 时, 一次性的将所有
CONSTANT<sub>String</sub><sub>info</sub> 全通过 intern() 放到 internedStrings 中, 然后
CONSTANT<sub>String</sub><sub>info的</sub> data 为 生成的 String 对象
</li>

<li>LAZY initialization: 如 <i>constant pool</i> 所述, 访问
CONSTANT<sub>String</sub><sub>info</sub> 使用 `ldc` 指令, 而 `ldc` 指令可以隐式的调用
String.intern(), 并返回 intern() 的结果

<p>
To summarize:
</p>
<ul class="org-ul">
<li>对于 string literal, 再显式调用 intern() 没有意义
</li>
<li>对于 运行时 string, 若 string 经常重复, 可以通过 intern() 做 cache
</li>
</ul>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Constant Pool</h3>
<div class="outline-text-3" id="text-1-2">
<p>
see also <a href="#sec-1-1">1.1</a>
see also <i>autoboxing</i>
see also <i>valueOf</i>
</p>

<pre class="example">
String s1="abc";
String s2="abc";
assert(s1==s2);
String s3=new String("abc");
String s4=new String("abc");
assert(s3!=s4);

Integer i1=100;
Integer i2=100;
assert(i1==i2);  // see autoboxing &amp; valueOf
Integer i3=200;
Integer i4=200;
assert(i3!=i4);  // see autoboxing &amp; valueOf
</pre>

<p>
Constant pool plays an important role in the dynamic linking of Java program. In addition to constant values (String, integer, float literal),
the constant pool contains the following kinds of symbolic references:
</p>
<ul class="org-ul">
<li>fully qualified names of classes and interfaces
</li>
<li>field names and descriptors (type&#x2026;)
</li>
<li>method names and descriptors (params,type,&#x2026;)
</li>
</ul>

<p>
Constant pool can contain the following variety entries:
</p>
<ul class="org-ul">
<li>CONSTANT<sub>Utf8</sub>
</li>
<li>CONSTANT<sub>Integer</sub>
</li>
<li>CONSTANT<sub>Float</sub>
</li>
<li>CONSTANT<sub>Long</sub>
</li>
<li>CONSTANT<sub>Double</sub>
</li>
<li>CONSTANT<sub>Class</sub>
</li>
<li>CONSTANT<sub>String</sub>
</li>
<li>CONSTANT<sub>FieldRef</sub>
</li>
<li>CONSTANT<sub>MethodRef</sub>
</li>
<li>CONSTANT<sub>NameAndType</sub>
</li>
</ul>

<p>
To summarize:
Constant pool works in 3 varieties:
</p>
<ol class="org-ol">
<li>save constant literal (and class static field), much like DATA section in ELF
</li>
<li>help dynamic linking resolution
</li>
<li>name cache
</li>
</ol>
</div>
<div id="outline-container-sec-1-2-0-1" class="outline-5">
<h5 id="sec-1-2-0-1"><span class="section-number-5">1.2.0.1</span> class, method, field..</h5>
<div class="outline-text-5" id="text-1-2-0-1">
<p>
java code:
</p>
<pre class="example">
public class Test {
  int x;
  public static void main(String args[]) {
     Test t=new Test ();
     t.x=100;
     t.foo ();
  }
  void foo () {

  }
}
</pre>
<p>
byte code:
</p>
<pre class="example">
const #1 = Method	#6.#18;	//  java/lang/Object."&lt;init&gt;":()V
const #2 = class	#19;	//  Test
const #3 = Method	#2.#18;	//  Test."&lt;init&gt;":()V
const #4 = Field	#2.#20;	//  Test.x:I
const #5 = Method	#2.#21;	//  Test.foo:()V
const #6 = class	#22;	//  java/lang/Object
const #7 = Asciz	x;
const #8 = Asciz	I;
const #9 = Asciz	&lt;init&gt;;
const #10 = Asciz	()V;
const #11 = Asciz	Code;
const #12 = Asciz	LineNumberTable;
const #13 = Asciz	main;
const #14 = Asciz	([Ljava/lang/String;)V;
const #15 = Asciz	foo;
const #16 = Asciz	SourceFile;
const #17 = Asciz	Test.java;
const #18 = NameAndType	#9:#10;//  "&lt;init&gt;":()V
const #19 = Asciz	Test;
const #20 = NameAndType	#7:#8;//  x:I
const #21 = NameAndType	#15:#10;//  foo:()V
const #22 = Asciz	java/lang/Object;

{
int x;

public Test();
Code:
Stack=1, Locals=1, Args_size=1
0:	aload_0
1:	invokespecial	#1; //Method java/lang/Object."&lt;init&gt;":()V
4:	return
LineNumberTable:
line 2: 0

public static void main(java.lang.String[]);
Code:
Stack=2, Locals=2, Args_size=1
0:	new	#2; //class Test
3:	dup
4:	invokespecial	#3; //Method "&lt;init&gt;":()V
7:	astore_1
8:	aload_1
9:	bipush	100
11:	putfield	#4; //Field x:I
14:	aload_1
15:	invokevirtual	#5; //Method foo:()V
18:	return
LineNumberTable:
line 5: 0
line 6: 8
line 7: 14
line 8: 18

void foo();
Code:
Stack=0, Locals=1, Args_size=1
0:	return
LineNumberTable:
line 11: 0

}
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-0-2" class="outline-5">
<h5 id="sec-1-2-0-2"><span class="section-number-5">1.2.0.2</span> put/set static field</h5>
<div class="outline-text-5" id="text-1-2-0-2">
<p>
java code:
</p>
<pre class="example">
class Test {
   static float x=1.1f;
   public static void main(String args[]) {
       x=1.2f;
     }
 }
</pre>
<p>
byte code:
</p>
<pre class="example">
...
const #3 = Field        #5.#20; //  Test.x:F
...
0:   ldc     #2; //float 1.2f
2:   putstatic       #3; //Field x:F
...
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-0-3" class="outline-5">
<h5 id="sec-1-2-0-3"><span class="section-number-5">1.2.0.3</span> literal</h5>
<div class="outline-text-5" id="text-1-2-0-3">
</div><ol class="org-ol"><li>String literal<br  /><div class="outline-text-6" id="text-1-2-0-3-1">
<p>
java code:
</p>
<pre class="example">
public class Test {
public static void main(String args[]) {
String s1="abc";
}
}
</pre>
<p>
byte code:
</p>
<pre class="example">
~@mbjswglx56&gt; javap -verbose Test
Compiled from "Test.java"
public class Test extends java.lang.Object
SourceFile: "Test.java"
minor version: 0
major version: 49
Constant pool:
const #1 = Method       #4.#13; //  java/lang/Object."&lt;init&gt;":()V
const #2 = String       #14;    //  abc
const #3 = class        #15;    //  Test
const #4 = class        #16;    //  java/lang/Object
const #5 = Asciz        &lt;init&gt;;
const #6 = Asciz        ()V;
const #7 = Asciz        Code;
const #8 = Asciz        LineNumberTable;
const #9 = Asciz        main;
const #10 = Asciz       ([Ljava/lang/String;)V;
const #11 = Asciz       SourceFile;
const #12 = Asciz       Test.java;
const #13 = NameAndType #5:#6;//  "&lt;init&gt;":()V
const #14 = Asciz       abc;
const #15 = Asciz       Test;
const #16 = Asciz       java/lang/Object;

{
public Test();
Code:
Stack=1, Locals=1, Args_size=1
0:   aload_0
1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
4:   return
LineNumberTable:
line 2: 0

public static void main(java.lang.String[]);
Code:
Stack=1, Locals=2, Args_size=1
0:   ldc     #2; //String abc
2:   astore_1
3:   return
LineNumberTable:
line 4: 0
line 5: 3

}
</pre>
<p>
可见,"abc"这个string literal被保存在constant pool #14/#2 的位置, java代码使用 `ldc #2` 从 constant pool中获得这个string, 并放到栈顶.
</p>

<p>
ldc pushes a one-word constant from the constant pool onto the operand stack. the following java types can be pushed using ldc:
</p>
<ul class="org-ul">
<li>int
</li>
<li>float
</li>
<li>String
</li>
</ul>

<p>
Pushing a String causes a reference to a java.lang.String object to be constructed and pushed onto the operand stack. Pushing an int or float causes
a primitive value to be pushed;
</p>

<p>
String literal总是放在constant pool中, 并通过 ldc 加载.
</p>
</div>
</li>
<li>int, float literal<br  /><div class="outline-text-6" id="text-1-2-0-3-2">
<p>
java code:
</p>
<pre class="example">
Integer i=100;
</pre>
<p>
byte code:
</p>
<pre class="example">
0:   bipush  100
2:   invokestatic    #2; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
5:   astore_1
</pre>
<p>
java code:
</p>
<pre class="example">
Integer i=100000;
</pre>
<p>
byte code:
</p>
<pre class="example">
0:   ldc     #2; //int 100000
2:   invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
5:   astore_1
</pre>
<ul class="org-ul">
<li>对于int常量, &gt;short时放在constant pool, &lt;short时直接写到代码中
</li>
<li>ldc 对于 int 只是放 primitive 值放在 stack中, Integer的 autoboxing 实际就是隐式的调用了 Integer.valueOf
</li>
<li>float常量始终存放在constant pool中
</li>
</ul>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Class Loader</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> class unloading</h4>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> invokeXXX</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> invokevirtual vs. invokespecial</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
similar with c++'s call-by-reference and call-by-value; that is, `invokespecial` will prohibit polymorphism.
</p>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> invokestatic</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
direct addressing
</p>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> invokeinterface</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
contant-pool would be iterated to find the interface method, since an object can inhereit multiply interface;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> GC</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> 分代 GC</h4>
<div class="outline-text-4" id="text-1-5-1">
</div><div id="outline-container-sec-1-5-1-1" class="outline-5">
<h5 id="sec-1-5-1-1"><span class="section-number-5">1.5.1.1</span> young gen</h5>
<div class="outline-text-5" id="text-1-5-1-1">
</div><ol class="org-ol"><li>eden<br  /></li>
<li>survior * 2<br  /></li></ol>
</div>

<div id="outline-container-sec-1-5-1-2" class="outline-5">
<h5 id="sec-1-5-1-2"><span class="section-number-5">1.5.1.2</span> old gen</h5>
<div class="outline-text-5" id="text-1-5-1-2">
<p>
大对象直接进入 old gen
</p>
</div>
</div>

<div id="outline-container-sec-1-5-1-3" class="outline-5">
<h5 id="sec-1-5-1-3"><span class="section-number-5">1.5.1.3</span> perm gen</h5>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> GC 算法</h4>
<div class="outline-text-4" id="text-1-5-2">
</div><div id="outline-container-sec-1-5-2-1" class="outline-5">
<h5 id="sec-1-5-2-1"><span class="section-number-5">1.5.2.1</span> mark and sweep</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<p>
young gen 通常使用 copy 算法
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2-2" class="outline-5">
<h5 id="sec-1-5-2-2"><span class="section-number-5">1.5.2.2</span> copy</h5>
<div class="outline-text-5" id="text-1-5-2-2">
<p>
old gen 通常使用 mark and sweep 算法
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> Finalizer And Reference</h4>
<div class="outline-text-4" id="text-1-5-3">
</div><div id="outline-container-sec-1-5-3-1" class="outline-5">
<h5 id="sec-1-5-3-1"><span class="section-number-5">1.5.3.1</span> finalize() 导致两次 GC</h5>
<div class="outline-text-5" id="text-1-5-3-1">
<p>
<a href="http://www.fasterj.com/articles/finalizer1.shtml">http://www.fasterj.com/articles/finalizer1.shtml</a>
</p>

<ol class="org-ol">
<li>对于有 finalize() 的类, jvm 会给每个类生成一个 FinalizerReference
</li>
<li>GC 时, 每个 FinalizerReference 会被检查, 若 referent 已经被
unmarked, 则
<ol class="org-ol">
<li>将 referent 重新置为 marked
</li>
<li>将 referent enqueue 到 FinalizerQueue 中, 后面 Finalizer Thread
会负责调用 finalize(), 并再次 unmark 该 referent
</li>
<li>再次 GC 时, referent 才会真正被 GC
</li>
</ol>
</li>
</ol>

<p>
Finalizer 的具体实现和使用 PhantomReference 避免 finalizer 非常类似, 只
不过是由 jvm 维护着一个 FinalizerReference 以及一个 FinalizerQueue,并且
调度 Finalizer Thread 在 FinalizerQueue 上阻塞(通过 remove) 以便调用
finalizer
</p>
</div>

<ol class="org-ol"><li>FinalizerReference<br  /></li>
<li>Finalizer Thread<br  /></li></ol>
</div>

<div id="outline-container-sec-1-5-3-2" class="outline-5">
<h5 id="sec-1-5-3-2"><span class="section-number-5">1.5.3.2</span> 使用 PhantomReference 避免 finalize()</h5>
<div class="outline-text-5" id="text-1-5-3-2">
<p>
<a href="http://java.dzone.com/articles/finalization-and-phantom">http://java.dzone.com/articles/finalization-and-phantom</a>
</p>
</div>

<ol class="org-ol"><li>使用 WeakReference 是否也可以?<br  /><div class="outline-text-6" id="text-1-5-3-2-1">
<p>
好像不行, dvm 里 GC 时处理各处 reference 的代码:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">clearWhiteReferences &#26159;&#23558; references &#25968;&#32452;&#20013;&#27599;&#20010; reference</span>
<span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#36827;&#34892;&#22914;&#19979;&#22788;&#29702;: &#33509; referent &#20026; unmarked, &#21017;&#23558; reference enqueue &#21040;</span>
<span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#30456;&#24212;&#30340; queue &#20013;</span>
clearWhiteReferences(softReferences);
clearWhiteReferences(weakReferences);

<span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">enqueueFinalizerReferences &#20250;&#36127;&#36131;&#23558; finalizerReferences &#20013; unmarked</span>
<span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#30340; reference &#32622;&#20110; FinalizerQueue &#20013;, &#20197;&#35843;&#24230; finalize()</span>
enqueueFinalizerReferences(finalizerReferences);

<span style="color: #586e75; font-style: italic;">/*</span>
<span style="color: #586e75; font-style: italic;"> * Clear all f-reachable soft and weak references with white</span>
<span style="color: #586e75; font-style: italic;"> * referents.</span>
<span style="color: #586e75; font-style: italic;"> */</span>

clearWhiteReferences(softReferences);
clearWhiteReferences(weakReferences);

<span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#28165;&#29702; phantomReferences</span>
clearWhiteReferences(phantomReferences);
</pre>
</div>
<p>
由以上代码可知, weakReferences, softReferences 在 enqueue 时, 后续的
enqueueFinalizerReferences 有可能导致 weakReferences 的 referent 重新
变为 marked, 结果就是 weakReferences 的 queue 读取出来的
weakReferences 有可能其 referent 并没有被 finalize &#x2026;. 不过, 若
referent 本身并不是 finalizable, 则 enqueueFinalizerReferences 并不能
对其产生影响, 所以这时 weakReferences, phantomReferences 应该是一样的
</p>
</div>
</li></ol>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-04-09 Wed 13:47</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
