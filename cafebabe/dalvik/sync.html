<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Sync</title>
<!-- 2014-04-09 Wed 13:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Sync</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Sync</a>
<ul>
<li><a href="#sec-1-1">1.1. thin locks</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Sync</h2>
<div class="outline-text-2" id="text-1">
<p>
Sync 部分主要包含以下的内容:
</p>

<ol class="org-ol">
<li>lock/wait/notity 的实现
</li>
<li>java hashcode 的实现
</li>
</ol>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> thin locks</h3>
<div class="outline-text-3" id="text-1-1">
<p>
每一个 C++ Object 类都有一个成员: int lock, 用来表示 lock 的状态.
dalvik 的 lock 是一种称为 thin locks 的锁. 这种 lock 与传统的基于
mutex 的 lock 不同, 它分为两种状态: thin 和 fat.  在不同的状态下, lock
字段的意义不同:
</p>
<ol class="org-ol">
<li>thin 状态
<pre class="example">
[31 ---- 19] [18 ---- 3] [2 ---- 1] [0]
 lock count   thread id  hash state  0
</pre>
</li>

<li>fat 状态
<pre class="example">
[31 ---- 3] [2 ---- 1] [0]
  pointer   hash state  1
</pre>

<p>
其中的 pointer 是指向 struct Monitor 的指针
</p>
</li>
</ol>

<p>
初始时所有 lock 都处于 thin 状态, 这种状态下 dalvik 会使用 spinlock 来
获得锁. 当发生 lock contention 时, lock 会 thin 状态 inflate 到 fat 状
态, 此后该 lock 就会通过传统的 mutex 来进行锁的获得与释放, 而该 lock 会
一直处于 fat 状态 (无法退回到 thin 状态)
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Java Lightweight Lock</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Lightweight Lock 是java 1.6提供的一种锁优化机制, Dalvik 看起来也使用了这种机制. 
在虚拟机中, synchronized 对应的具体指令是 MonitorEnter/MonitorExit, 例如:
</p>
<pre lang="java" line="1">
Object obj=new Object ();
synchronized (obj) {
System.out.println("");
}
</pre>
<p>
对应的byte code是:
</p>
<pre lang="java" line="1">
...
10:     astore_2
11:     monitorenter
12:     getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;
15:     ldc     #4; //String 
17:     invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
20:     aload_2
21:     monitorexit
</pre>

<p>
Dalvik 的 MonitorEnter() 的源码:
</p>

<pre lang="c" line="1">
MonitorEnter:
dvmLockObject(_self, obj);
threadId = self->threadId;
thinp = &obj->lock; // 每个object都有一个四字节的lock成员,在hotspot虚拟机, 这个u4长度的lock和hash code等一起,放在对象头的Mark Word中 
if LW_SHAPE(thin) == LW_SHAPE_THIN:  // LW_SHAPE 实际是取 thin 这个 u4的最低位, 若为0, 表示这是一个thin lock ,否则, 为fat lock
if LW_LOCK_OWNER(thin) == threadId:
obj->lock += 1 << LW_LOCK_COUNT_SHIFT;
else if LW_LOCK_OWNER(thin) == 0:
ATOMIC_CMP_SWAP((int32_t *)thinp, thin, newThin)
else:
for (;;):
if LW_SHAPE(thin) == LW_SHAPE_THIN:
if ATOMIC_CMP_SWAP:
break;
else:
sched_yield() ;; lock is inflated by another thread to FAT_LOCK
;; we have acquired the lock, FATTEN it.
mon = dvmCreateMonitor(obj);
lockMonitor(self, mon);b
thin |= (u4)mon | LW_SHAPE_FAT;
else: // is a FAT_LOCK
lockMonitor(self, LW_MONITOR(obj->lock));
</pre>
<ul class="org-ul">
<li>所谓thin lock, fat lock:

<p>
在Lightweight Lock中, 同一个对象的锁可能处于两种状态:thin, fat; thin lock 是指该锁可以使用CAS (Compare And Swap) 这种轻量级的指令直接获得或释放,开销很小. 
fat lock 是指该锁必须使用操作系统提供的mutex进行获取或释放,开销较大.
</p>
</li>
<li>CAS

<p>
Compare And Swap, 意思是比较两个值,若不等,则进行交换, 这个指令的关键是比较与赋值这两个操作是原子的, 不需要再加锁.在不同的平台中都有直接的机器指令与之对应,
如x86中的cmpxchg指令. CAS的开销很小,而且两个操作是原子的不用加锁,经常用来实际各种lock-free算法 
</p>
</li>
<li>lock-free, 就是避免加锁,如最简单的环形缓冲区方法
</li>
<li>上面代码显示的Lightweight Lock的实现中,关键的几点是:

<ul class="org-ul">
<li>若一个锁是thin且尚未锁定,则使用CAS加锁(实际只是修改lock的owner为当前线程,并没有什么耗时的加锁动作)
</li>
<li>若一个锁是thin且已锁定,则把它作为一个spinlock在死循环,直到之前持有thin lock的线程将thin lock释放
这里提到的thin lock的判断锁定,加锁,解锁开销都很小, 例如通过判断lock owner 判断是否加锁, 使用CAS加锁,解锁 
</li>
<li>进行spin的的线程在获得thin lock后, 会将锁升级为fat lock；thin lock此时被升级为fat lock, 是因为系统发现锁出现了竞争, 再使用spinlock很有可能会白白浪费CPU. 
</li>
<li>thin lock一旦变成fat lock, Lightweight Lock的使命就结束了, 之后对这个锁的使用操作都会使用pthread<sub>mutex</sub><sub>xxx</sub>
</li>
<li>Lightweight Lock机制没有办法把fat lock降级为thin lock 
</li>
</ul>
</li>
<li>spinlock

<p>
spinlock,即自旋锁, 线程在等待spinlock时, 不会被挂起,而是执行一个while(true)的死循环,并在这个死循环中不停的检测锁是否释放. 
spinlock适用于锁持有时间较短的情况,并且主要用在SMP的情况; 但在单处理器的情况下,就无法避免进程切换了, 因为要
退出spin, 只能靠别的进程来修改spin的flag.
</p>
</li>
<li>pthread<sub>mutex</sub><sub>xxx</sub>

<p>
pthread提供的mutex；现在linux都使用futex(Fast Usermode muTex) 来实现mutex, 开销也比以前通过syscall进入内核的方法好多了.
</p>
</li>
</ul>

<p>
总结:
</p>
<ul class="org-ul">
<li>因为Lightweight Lock机制, java的synchronized比想象的要高效, 特别是没有锁冲突的情况下,只是简单一条CAS指令,几乎没有额外开销.
</li>
<li>Lightweight Lock过程
<ol class="org-ol">
<li>T1 is the first thread acquiring the lock, so it will using CAS to acquire the THIN<sub>LOCK</sub>
</li>
<li>while T1 holding the lock, T2,T3 come to request the lock, they both will spin on the THIN<sub>LOCK</sub>
</li>
<li>when T2 acquire the lock, it will inflate the lock from THIN<sub>LOCK</sub> to FAT<sub>LOCK</sub>, and use mutex to accquire the lock; 
after that, T3 will use mutex to accquire the lock
</li>
<li>once a lock is inflated to FAT<sub>LOCK</sub>, there is no way for it to com back as THIN<sub>LOCK</sub>.
</li>
</ol>
</li>
</ul>
</div>



<div id="outline-container-sec-1-1-1-1" class="outline-5">
<h5 id="sec-1-1-1-1"><span class="section-number-5">1.1.1.1</span> hashcode</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<p>
对与 MarkSweep GC 来说, hashcode 就是 struct Object 的地址. 因为
MarkSweep GC 不会移动对象. 
</p>

<p>
对于 Copying GC 来说, 获得 hashcode 时会参考 lock byte 中的 hashState字
段, 例如, 若 hashState 为 LW<sub>HASH</sub><sub>STATE</sub><sub>HASHED</sub> 或
LW<sub>HASH</sub><sub>STATE</sub><sub>UNHASHED</sub>, 则 hashcode 直接就是Object 地址. 若 hashState
为 LW<sub>HASH</sub><sub>STATE</sub><sub>HASHED</sub><sub>AND</sub><sub>MOVED</sub>, 说明之前获取后 hashcode 且后来
Copying GC 移动过对象, 这时 hashcode 不能简单的取对象的地址了: Copying
GC 会负责在移动对象时根据当前 hashState 决定是否把移动前的对象地址做为
hashcode 保存到对象后面的一个特定位置中.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-1-2" class="outline-5">
<h5 id="sec-1-1-1-2"><span class="section-number-5">1.1.1.2</span> lock</h5>
<div class="outline-text-5" id="text-1-1-1-2">
</div><ol class="org-ol"><li>dvmLockObject<br  /></li>
<li>lockMonitor<br  /></li>
<li>unlockMonitor<br  /></li></ol>
</div>

<div id="outline-container-sec-1-1-1-3" class="outline-5">
<h5 id="sec-1-1-1-3"><span class="section-number-5">1.1.1.3</span> wait/notify</h5>
<div class="outline-text-5" id="text-1-1-1-3">
</div><ol class="org-ol"><li>waitMonitor<br  /></li>
<li>notifyMonitor<br  /></li></ol>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-04-09 Wed 13:46</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
