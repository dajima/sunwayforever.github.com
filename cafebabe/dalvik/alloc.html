<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Alloc</title>
<!-- 2014-04-16 Wed 17:56 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Alloc</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Alloc</a>
<ul>
<li><a href="#sec-1-1">1.1. Glossary</a></li>
<li><a href="#sec-1-2">1.2. dvmAllocObject</a></li>
<li><a href="#sec-1-3">1.3. dvmCollectGarbageInternal</a></li>
<li><a href="#sec-1-4">1.4. Daemons 与 ReferenceQueue</a></li>
<li><a href="#sec-1-5">1.5. HeapWorker</a></li>
<li><a href="#sec-1-6">1.6. Concurrent GC</a></li>
<li><a href="#sec-1-7">1.7. Copying GC</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Alloc</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Glossary</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>HeapSource
</li>
<li>GcHeap
</li>
<li>MarkSweep
</li>
<li>Copying
</li>
<li>Mspace &amp; dlmalloc
</li>
<li>liveBits
</li>
<li>markBits
</li>
<li>markStack
</li>
<li>cardTable
</li>
<li>HeapWorker
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> dvmAllocObject</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-text">Object* dvmAllocObject(ClassObject* clazz, int flags)
  newObj = (Object*)dvmMalloc(clazz-&gt;objectSize, flags);
    ptr = tryMalloc(size);
      ptr = dvmHeapSourceAlloc(size);
      if (ptr != NULL):
        return ptr;
      // &#20998;&#37197;&#22833;&#36133;, &#24320;&#22987; GC, false &#34920;&#31034; SoftReferences &#19981;&#34987; GC
      gcForMalloc(false);
        dvmCollectGarbageInternal(GC_FOR_MALLOC);
      // &#31532;&#20108;&#27425; malloc  
      ptr = dvmHeapSourceAlloc(size);
        ptr = mspace_malloc(heap-&gt;msp, n);
        // countAllocation &#20250;&#23558; hs-&gt;liveBits &#23545;&#24212;&#30340;&#32622; 1
        countAllocation(heap, ptr);
      if (ptr != NULL): return ptr;
      // &#31532;&#19977;&#27425; ...
      ptr = dvmHeapSourceAllocAndGrow(size);
      if (ptr != NULL): return ptr;
      // &#21363;&#20351; Heap Grow &#20102;&#36824;&#26159;&#19981;&#34892;, &#20877;&#27425; GC, true &#34920;&#31034; SoftReferences &#20063;&#34987; GC
      gcForMalloc(true);
      // &#31532;&#22235;&#27425; ...
      ptr = dvmHeapSourceAllocAndGrow(size);
      if (ptr != NULL): return ptr;
      return null;
    if (ptr == NULL):
      throwOOME();
  DVM_OBJECT_INIT(newObj, clazz);
    dvmSetFieldObject(obj, OFFSETOF_MEMBER(Object, clazz), clazz_)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> dvmCollectGarbageInternal</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-text">dvmCollectGarbageInternal(spec)
  // &#19968;&#20849;&#26377;&#22235;&#31181;&#31867;&#22411;&#30340; GC:
  // 1. GC_FOR_MALLOC, &#23545;&#24212;&#20110; dvmMalloc &#26102;&#30340;&#31532;&#19968;&#27425; GC (&#19981;&#28165;&#29702; SoftReferences)
  // 2. GC_CONCURRENT, &#30001; HeapWorker &#21457;&#36215;&#30340; GC
  // 3. GC_EXPLICIT, &#30001; System.gc() &#21457;&#36215;&#30340; GC
  // 4. GC_BEFORE_OOM, &#23545;&#24212;&#20110; dvmMalloc &#26102;&#31532;&#20108;&#27425; GC (&#28165;&#29702; SoftReferences)
  if (spec == GC_FOR_MALLOC):
    ATRACE_BEGIN("GC (Alic)");
  else if (spec == GC_CONCURRENT):
    ATRACE_BEGIN("GC (concurrent)");
  else if (spec == GC_EXPLICIT):
    ATRACE_BEGIN("GC (explicit)");
  else if (spec == GC_BEFORE_OOM):
    ATRACE_BEGIN("GC (before OOM)");
  else:
    ATRACE_BEGIN("GC (unknown)");
  // &#21442;&#32771;: dalvik thread dvmSuspendAllThreads
  dvmSuspendAllThreads(SUSPEND_FOR_GC);
  // mark &#38454;&#27573;
  /* Mark the set of objects that are strongly reachable from the roots.
  */
  dvmHeapMarkRootSet();
  // &#33509; spec &#34920;&#26126;&#35813; gc &#30001; HeapWorker &#21457;&#36215;, &#21017; dvmHeapScanMarkedObjects
  // &#26102;&#24182;&#19981; stop the world. &#36825;&#20063;&#26159; Concurrent GC &#30340;&#26412;&#24847;.
  if (spec-&gt;isConcurrent):
    dvmClearCardTable();
    dvmResumeAllThreads(SUSPEND_FOR_GC);
  /* Recursively mark any objects that marked objects point to strongly.
  * If we're not collecting soft references, soft-reachable
  * objects will also be marked.
  */
  dvmHeapScanMarkedObjects();
  if (spec-&gt;isConcurrent):
    dvmSuspendAllThreads(SUSPEND_FOR_GC);
    dvmHeapReMarkRootSet();
    dvmHeapReScanMarkedObjects();
  /*
  * All strongly-reachable objects have now been marked.  Process
  * weakly-reachable objects discovered while tracing.
  */
  dvmHeapProcessReferences();
  // sweep &#38454;&#27573;
  dvmHeapSweepSystemWeaks();
  /*
  * Live objects have a bit set in the mark bitmap, swap the mark
  * and live bitmaps.  The sweep can proceed concurrently viewing
  * the new live bitmap as the old mark bitmap, and vice versa.
  */
  dvmHeapSourceSwapBitmaps();
  dvmHeapSweepUnmarkedObjects();
  // &#23558;&#26412;&#27425; GC &#20135;&#29983;&#30340; white reference &#21644; finalizer reference &#36890;&#30693;&#32473;
  // java &#23618;&#30340; ReferenceQueueDaemon
  dvmEnqueueClearedReferences(&amp;gDvm.gcHeap-&gt;clearedReferences);
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> dvmHeapMarkRootSet</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">

<pre class="src src-text">rootMarkObjectVisitor(void *addr, u4 thread, ...)
  markObjectNonNull(obj, ctx, false);

dvmHeapMarkRootSet
  // rootMarkObjectVisitor &#26159;&#19968;&#20010; callback, &#23545;&#27599;&#19968;&#20010; gc root &#20013;&#30340;&#23545;&#35937;
  // &#37117;&#20250;&#35843;&#29992;&#36825;&#20010; visitor
  dvmVisitRoots(rootMarkObjectVisitor, &amp;gcHeap-&gt;markContext);
    visitHashTable(visitor, gDvm.loadedClasses, ROOT_STICKY_CLASS, arg);
    visitPrimitiveTypes(visitor, arg);
    visitHashTable(visitor, gDvm.literalStrings, ROOT_INTERNED_STRING, arg);
    visitIndirectRefTable(visitor, &amp;gDvm.jniGlobalRefTable, 0, ROOT_JNI_GLOBAL, arg);
    visitReferenceTable(visitor, &amp;gDvm.jniPinRefTable, 0, ROOT_VM_INTERNAL, arg);
    // visitThreads &#26159;&#26368;&#20027;&#35201;&#30340;&#19968;&#36807; scan &#36807;&#31243;: GC root &#22823;&#37096;&#20998;&#20363;&#22914; static &#23545;&#35937;,
    // &#23616;&#37096;&#23545;&#35937;&#31561;&#37117;&#21253;&#21547;&#22312; stack frame &#20013;, visitThreads &#36127;&#36131;&#25195;&#25551;&#25152;&#26377;
    // stack frame
    visitThreads(visitor, arg);
      for each thread:
        (*visitor)(&amp;thread-&gt;threadObj, threadId, ROOT_THREAD_OBJECT, arg);
        (*visitor)(&amp;thread-&gt;exception, threadId, ROOT_NATIVE_STACK, arg);
        visitIndirectRefTable(visitor, &amp;thread-&gt;jniLocalRefTable, threadId, ...);
        // visitThreadStack &#36127;&#36131;&#25195;&#25551;&#25152;&#26377;&#30340; stack frame, &#24182;&#26681;&#25454; stack
        // frame &#20013; register &#30340;&#20351;&#29992;&#24773;&#20917;&#26469;&#21028;&#26029;&#26159;&#21542;&#35201; mark
        visitThreadStack(visitor, thread, arg);
          // &#36941;&#21382;&#25152;&#26377; frame
          for (u4 *fp = (u4 *)thread-&gt;interpSave.curFrame;
                fp != NULL;
                fp = (u4 *)saveArea-&gt;prevFrame):
            // &#33509;&#27492;&#26102;&#23384;&#22312; register map, &#21017;&#26681;&#25454; register map &#24471;&#21040;
            // register &#20351;&#29992;&#24773;&#20917;, &#21542;&#21017;, &#25195;&#25551;&#25152;&#26377;&#30340; register
            // &#23545;&#27599;&#19968;&#20010;&#21487;&#33021;&#20351;&#29992;&#30340; register, &#36890;&#36807; liveBits &#21487;&#20197;&#21028;&#26029;
            // &#20986;&#36825;&#20010; register &#23545;&#24212;&#30340;&#22320;&#22336;&#26159;&#21542;&#26159;&#19968;&#20010; java &#23545;&#35937;
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-1-1" class="outline-5">
<h5 id="sec-1-3-1-1"><span class="section-number-5">1.3.1.1</span> 关于 bitmap 的操作</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<p>
对于 markBits 和 liveBits 一样
</p>

<p>
markObjectNonNull 的过程是: 根据 addr 换算出对象在 bitmap 中的 bit
index, 将 bitmap 该bit 置 1, 因为 dalvik 中所有的对象都是 8 bytes 对齐
的, 所以 bitmap 中每 bit 代表 heap 的 8 bytes.
</p>

<p>
假设 gc heap 大小为 32 bytes, 则 markBits 的大小为 4 bits, 假设一共有两
个对象需要 mark, 地址相对于 heap-&gt;base 的 offset 分别为 0, 16, 则
markBits 的值为 1010, 即 markBits 只标记对象的地址, 和对象的大小无关.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> dvmHeapScanMarkedObjects</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">

<pre class="src src-text">dvmHeapScanMarkedObjects
  /* The bitmaps currently have bits set for the root set.
  * Walk across the bitmaps and scan each object.
  */
  // dvmHeapBitmapScanWalk &#36127;&#36131;&#25195;&#25551; markBits, &#23545;&#30452;&#25509;&#24341;&#29992;&#30340;
  // filed &#31561;&#36827;&#34892; mark, &#24182;&#25918;&#21040; markStack &#20013;
  dvmHeapBitmapScanWalk(ctx-&gt;bitmap, scanBitmapCallback, ctx);
  processMarkStack(ctx);
    // &#22312; scanObject &#36807;&#31243;&#20013;, markStack &#20250;&#22686;&#38271;, &#36890;&#36807; markStack, &#23558;&#36882;&#24402;
    // &#36807;&#31243;&#21464;&#20026;&#36845;&#20195;
    GcMarkStack *stack = &amp;ctx-&gt;stack;
    while (stack-&gt;top &gt; stack-&gt;base):
      const Object *obj = markStackPop(stack);
      scanObject(obj, ctx);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> dvmHeapProcessReferences</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
到此, 所有 strong references 的对象都被 mark 了, 但 soft, weak,
phantom references 并没有被 mark. 
</p>

<p>
dvmHeapProcessReferences 负责将 reference 放到 reference queue 中, 另
外, 对 soft reference, 会根据上层 dvmCollectGarbageInternal 使用的
spec, 决定是否将 soft reference 也进行 mark
</p>

<p>
gcHeap 本身对所有 soft, weak, phantom reference对象都维护着一个列表, 保
存着这些 Reference 对象, 以便这里可以方便的遍历. 每次 GC 时在 scan 阶段
都会重新生成这些列表, 这些列表中保存的 reference 对象本身肯定是 marked.
</p>

<div class="org-src-container">

<pre class="src src-text">scanObject
  scanDataObject(obj, ctx);
    if (IS_CLASS_FLAG_SET(obj-&gt;clazz, CLASS_ISREFERENCE)):
      delayReferenceReferent((Object *)obj, ctx);
        enqueuePendingReference(obj, list);
</pre>
</div>

<p>
另外, gcHeap 还维护着一个 finalizerReferences 列表, 这个队列中的成员不
是用户通过 new 生成的 reference, 而是一些那些定义了 finalize 函数的对
象. 
</p>

<div class="org-src-container">

<pre class="src src-text">dvmHeapProcessReferences
  if (!gDvm.zygote &amp;&amp; !clearSoftRefs):
    preserveSomeSoftReferences(softReferences);
      while (*list != NULL) {
        Object *ref = dequeuePendingReference(list);
        // referent &#26159; Reference &#31867;&#30340;&#19968;&#20010;&#25104;&#21592;, &#25351;&#21521; reference &#24341;&#29992;&#30340;&#23545;&#35937;
        // &#20363;&#22914; new WeakReference&lt;Object&gt;(o), &#21017; referent &#25351;&#21521; o
        Object *referent = dvmGetFieldObject(ref, referentOffset);
        bool marked = isMarked(referent, ctx);
        if (!marked &amp;&amp; ((++counter) &amp; 1)):
          /* Referent is white and biased toward saving, mark it. */
          markObject(referent, ctx);
          marked = true;
        if (!marked):
          /* Referent is white, queue it for clearing. */
          enqueuePendingReference(ref, &amp;clear);
  // &#25152;&#35859;&#30340; white reference, &#26159;&#21542; referent &#27809;&#26377;&#34987; mark &#30340; reference       
  clearWhiteReferences(softReferences);
  clearWhiteReferences(weakReferences);
  // &#33509; finalizerReferences &#20013;&#30340; reference &#30340; referent &#27809;&#26377; mark, &#21017;
  // &#23558;&#36825;&#20010; reference &#25918;&#21040; f-queue &#20013;, HeapWorker &#20250;&#36127;&#36131;&#25191;&#34892;&#23427;&#30340;
  // finalize &#20989;&#25968;. &#20294;&#26159;&#27491;&#22240;&#20026; HeapWorker &#36824;&#38656;&#35201;&#35775;&#38382; referent, &#25152;&#20197;
  // referent &#20250;&#34987;&#37325;&#26032;&#32622;&#20026; marked
  enqueueFinalizerReferences(finalizerReferences);

  /*
  * Clear all f-reachable soft and weak references with white
  * referents.
  */
  // &#36825;&#20004;&#21477;&#21448;&#34987;&#35843;&#29992;&#19968;&#27425;? &#22240;&#20026; enqueueFinalizerReferences &#21487;&#33021;&#23548;&#33268;
  // &#26032;&#30340; referent &#21464;&#20026; unmarked, &#36827;&#32780;&#23548;&#33268;&#36825;&#20123; referent &#20013;&#30340;
  // reference &#25104;&#21592;&#20063;&#21464;&#20026; unmarked, &#36827;&#32780;&#34987;&#21152;&#20837; references &#21015;&#34920;&#20013;, &#25152;&#20197;&#38656;
  // &#35201;&#23545;&#36825;&#20123;&#26032;&#21152;&#20837;&#30340; reference &#23545;&#35937;&#26412;&#36523;&#20877; clear &#19968;&#27425;. 

  clearWhiteReferences(softReferences);
  clearWhiteReferences(weakReferences);

  // phantom &#22312;&#26368;&#21518;&#34987; clear, &#32780;&#19981;&#26159;&#20687; weak, soft &#37027;&#26679;&#22312;
  // enqueueFinalizerReferences &#21069;&#23601;&#36827;&#34892;&#19968;&#27425; clear. &#20026;&#21861; weak, soft &#30340;
  // &#19981;&#33021;&#20687; phantom &#19968;&#26679;&#21482;&#22312; enqueueFinalizerReferences &#21518;&#36827;&#34892;&#19968;&#27425;?
  // &#22240;&#20026; soft, weak &#23545;&#35937;&#26412;&#36523;&#26377;&#19968;&#20010; referent &#24341;&#29992;...&#32780; phantom &#26159;&#19981;&#21253;
  // &#25324;&#36825;&#20010;&#25104;&#21592;&#30340;: &#33509;&#26032; enqueueFinalizerReferences &#20877; clear weak
  // references, &#26377;&#21487;&#33021;&#20250;&#21457;&#29983;&#26412;&#35813; clear &#30340; weak reference &#27809;&#26377; clear:
  // &#22240;&#20026; enqueueFinalizerReferences &#23558;&#26576;&#20010; weak reference &#30340; referent
  // &#21464;&#20026; marked &#20102;...

  // phantom &#30340;&#36825;&#20010;&#29305;&#28857;&#20063;&#20351;&#23427;&#36866;&#21512;&#29992;&#26469;&#20195;&#26367; finalize &#20989;&#25968;
  // &#21442;&#32771; jvm &#20351;&#29992; PhantomReference &#36991;&#20813; finalize()
  clearWhiteReferences(phantomReferences);
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-3-1" class="outline-5">
<h5 id="sec-1-3-3-1"><span class="section-number-5">1.3.3.1</span> FinalizerReference</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<p>
FinalizerReference 是一个 java 类, 但在 java 层并不可见: dalvik 在初始
化一个 Object 时, 若发现该对象实现了 finalize() 方法, 则会通过
dvmSetFinalizable (通过 FinalizerReference.add) 方法添加一个
FinalizerReference 对象对 FinalizerReference 的一个静态成员. 后续 GC
scan 时一定会找到这个 FinalizerReference.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> dvmHeapSourceSwapBitmaps</h4>
<div class="outline-text-4" id="text-1-3-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">HeapBitmap</span> <span style="color: #268bd2;">tmp</span> = gHs-&gt;liveBits;
gHs-&gt;liveBits = gHs-&gt;markBits;
gHs-&gt;markBits = tmp;
</pre>
</div>
<p>
简单的交换一下 liveBits 与 markBits, 以便进行下次 GC.
</p>
</div>
</div>

<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> dvmHeapSweepUnmarkedObjects</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Walk through the list of objects that haven't been marked and free
them.  Assumes the bitmaps have been swapped.
</p>

<p>
真正的 sweep 阶段
</p>

<div class="org-src-container">

<pre class="src src-text">dvmHeapSweepUnmarkedObjects
  // &#23545;&#27599;&#19968;&#20010; garbage object &#25191;&#34892;
  // &#22914;&#20309;&#25214;&#21040; garbage object? (liveBits &amp; ~markBits) = 1 &#34920;&#31034; garbage object
  // &#27880;&#24847;&#36825;&#37324;&#30340; markBits, liveBits &#25351;&#30340;&#26159; swap &#21069;&#30340; bitmap, &#32780;&#19988;&#36825;&#20010;&#25805;&#20316;&#24182;
  // &#19981;&#31561;&#20215;&#20110; "&#24322;&#25110;" &#25805;&#20316;.
  dvmHeapBitmapSweepWalk(sweepBitmapCallback,...)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">sweepBitmapCallback(size_t numPtrs, void **ptrs, void *arg)
  dvmHeapSourceFreeList(numPtrs, ptrs);
    mspace_bulk_free(msp, ptrs, numPtrs);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Daemons 与 ReferenceQueue</h3>
<div class="outline-text-3" id="text-1-4">
<p>
clearWhiteReferences 和 enqueueFinalizerReferences 最终会将 reference
对象放在 gDvm.gcHeap-&gt;clearedReferences 这个列表中. 
</p>

<p>
对于 FinalizerReference, 其 referent 对应的 finalize() 函数需要被调用.对
于 weak, soft, phantom reference, 其 ReferenceQueue 的 poll 或remove 需
要结束阻塞并返回该 reference. 如何做到?
</p>

<p>
在 GC 的最后阶段, dvmEnqueueClearedReferences 会负责将这些 reference
通知给 java 层的 ReferenceQueueDaemon:
</p>

<div class="org-src-container">

<pre class="src src-text">dvmEnqueueClearedReferences
  Method *meth = gDvm.methJavaLangRefReferenceQueueAdd;
  dvmCallMethod(self, meth, NULL, &amp;unused, reference);
</pre>
</div>

<p>
实际上就是调用了 ReferenceQueue 的静态方法: add
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">add</span>(Reference&lt;?&gt; list) {
    <span style="color: #859900;">synchronized</span> (ReferenceQueue.<span style="color: #859900;">class</span>) {
        <span style="color: #859900;">if</span> (unenqueued == <span style="color: #2aa198;">null</span>) {
            unenqueued = list;
        } <span style="color: #859900;">else</span> {
            Reference&lt;?&gt; next = unenqueued.pendingNext;
            unenqueued.pendingNext = list.pendingNext;
            list.pendingNext = next;
        }
        ReferenceQueue.<span style="color: #859900;">class</span>.notifyAll();
    }
}
</pre>
</div>

<p>
静态的 ReferenceQueue 拿到了所有的 white reference 和 finalize
reference, 但是 notifyAll 是通知谁?
</p>

<p>
答案就是 ReferenceQueueDaemon !
</p>

<p>
Daemons 是一个 java 类, 实际上就是对 Thread 的一个简单包装. 
当 zygote fork 后, 会通过 Daemons.start 启动如下的线程:
</p>

<ol class="org-ol">
<li>ReferenceQueueDaemon
</li>
<li>FinalizerDaemon
</li>
<li>FinalizerWatchdogDaemon
</li>
</ol>

<p>
ReferenceQueueDaemon 负责在 ReferenceQueue 上 wait, 等待 dalvik 的通知,
一旦拿到 reference, 会把消息分发给各个 reference
</p>

<ol class="org-ol">
<li>对于 weak, soft, phantom 等 white reference 来说, 就是通知各自的 ReferenceQueue 对象.
</li>
<li>对于 FinalizerReference 来说, 就是通知 FinalizerDaemon 开始工作: 调
用 finalize() 函数.
</li>
</ol>

<p>
还有一个 FinalizerWatchdogDaemon 是负责监视 finalize 函数的执行的, 执
行过久的进程会被 kill. 
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> HeapWorker</h3>
<div class="outline-text-3" id="text-1-5">
<p>
dalvik 启动时会启动 HeapWorker 线程, 负责 concurrent GC.
</p>

<p>
HeapWorker 对应于这个 native thread:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">gcDaemonThread</span>(<span style="color: #b58900;">void</span>* <span style="color: #268bd2;">arg</span>)
{
    dvmChangeStatus(<span style="color: #2aa198;">NULL</span>, THREAD_VMWAIT);
    <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">trim</span> = <span style="color: #2aa198;">false</span>;
    <span style="color: #859900;">if</span> (gHs-&gt;gcThreadTrimNeeded) {
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = dvmRelativeCondWait(&amp;gHs-&gt;gcThreadCond, &amp;gHs-&gt;gcThreadMutex,
                                         HEAP_TRIM_IDLE_TIME_MS, 0);
        <span style="color: #859900;">if</span> (result == ETIMEDOUT) {
            <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">Timed out waiting for a GC request, schedule a heap trim. </span><span style="color: #586e75; font-style: italic;">*/</span>
            trim = <span style="color: #2aa198;">true</span>;
        }
    } <span style="color: #859900;">else</span> {
        dvmWaitCond(&amp;gHs-&gt;gcThreadCond, &amp;gHs-&gt;gcThreadMutex);
    }

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Many JDWP requests cause allocation. We can't take the heap lock and wait to</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">transition to runnable so we can start a GC if a debugger is connected, because</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">we don't know that the JDWP thread isn't about to allocate and require the</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">heap lock itself, leading to deadlock. http://b/8191824.</span>
    <span style="color: #859900;">if</span> (gDvm.debuggerConnected) {
        <span style="color: #859900;">continue</span>;
    }

    dvmLockHeap();
    <span style="color: #586e75; font-style: italic;">/*</span>
<span style="color: #586e75; font-style: italic;">     * Another thread may have started a concurrent garbage</span>
<span style="color: #586e75; font-style: italic;">     * collection before we were scheduled.  Check for this</span>
<span style="color: #586e75; font-style: italic;">     * condition before proceeding.</span>
<span style="color: #586e75; font-style: italic;">     </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #859900;">if</span> (<span style="color: #dc322f;">!</span>gDvm.gcHeap-&gt;gcRunning) {
        dvmChangeStatus(<span style="color: #2aa198;">NULL</span>, THREAD_RUNNING);
        <span style="color: #859900;">if</span> (trim) {
            trimHeaps();
            gHs-&gt;gcThreadTrimNeeded = <span style="color: #2aa198;">false</span>;
        } <span style="color: #859900;">else</span> {
            dvmCollectGarbageInternal(GC_CONCURRENT);
            gHs-&gt;gcThreadTrimNeeded = <span style="color: #2aa198;">true</span>;
        }
        dvmChangeStatus(<span style="color: #2aa198;">NULL</span>, THREAD_VMWAIT);
    }
    dvmUnlockHeap();
    dvmChangeStatus(<span style="color: #2aa198;">NULL</span>, THREAD_RUNNING);
    <span style="color: #859900;">return</span> <span style="color: #2aa198;">NULL</span>;
}
</pre>
</div>

<p>
可见, HeapWorker 是否工作取决于 gHs-&gt;gcThreadCond, 参考
dvmHeapSourceAlloc 的代码:
</p>

<div class="org-src-container">

<pre class="src src-text">dvmHeapSourceAlloc
  if (heap-&gt;bytesAllocated &gt; heap-&gt;concurrentStartBytes):
    /*
    * We have exceeded the allocation threshold.  Wake up the
    * garbage collector.
    */
    dvmSignalCond(&amp;gHs-&gt;gcThreadCond);
</pre>
</div>
<p>
所以, 如果当前已经发配的内存大于 heap-&gt;concurrentStartBytes 时 (默认的
配置是 freeBytes - CONCURRENT<sub>START</sub>(128KB), 即当可用内存少于 128KB 时),
HeapWorker 会开始工作, 并且周期性的 (HEAP<sub>TRIM</sub><sub>IDLE</sub><sub>TIME</sub><sub>MS</sub>) 执行
dvmCollectGarbageInternal
</p>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Concurrent GC</h3>
<div class="outline-text-3" id="text-1-6">
<p>
HeapWorker 实际上就是实现了 Concurrent Mark Sweep (CMS), 说它是
concurrent, 不是因为它会周期性的执行, 而是因为它允许在
dvmHeapScanMarkedObjects() 时各个 java 继续执行, 而不必`stop the
world` (并发标记).
</p>

<p>
关于 CMS:
<a href="http://dl.acm.org/citation.cfm?id=362422.362480">http://dl.acm.org/citation.cfm?id=362422.362480</a>
</p>

<p>
"This paper reports our experiences with a mostly-concurrent
incremental garbage collector, implemented in the context of a high
performance virtual machine for the Java™ programming language. The
garbage collector is based on the “mostly parallel” collection
algorithm of Boehm et al. and can be used as the old generation of a
generational memory system. It overloads efficient write-barrier code
already generated to support generational garbage collection to also
identify objects that were modified during concurrent marking. These
objects must be rescanned to ensure that the concurrent marking phase
marks all live objects. This algorithm minimises maximum garbage
collection pause times, while having only a small impact on the
average garbage collection pause time and overall execution time. We
support our claims with experimental results, for both a synthetic
benchmark and real programs."
</p>

<p>
CMS 一般分为四个阶段:
</p>
<ol class="org-ol">
<li>初始标记
对应于 dvmCollectGarbageInternal 的 dvmHeapMarkRootSet
</li>
<li>并发标记
对应于 dvmHeapScanMarkedObjects
</li>
<li>重新标记
对应于 dvmHeapReMarkRootSet 与 dvmHeapReScanMarkedObjects
</li>
<li>清除
</li>
</ol>


<p>
CMS 可以更快, 是因为并发标记期间并没有 `stop the world`, 但带来的后果是
并发标记结束后有可能会因为其他线程的执行产生新的可达对象, 这时就需要重
新标记. 但是重新标记不能像初始标记和并发标记那样从头扫描一次, 这样就速
度太慢没有意义.
</p>

<p>
要做到快速重新标记, 需要一个叫做 CardTable 的东西与之配合.
</p>

<p>
CardTable 实际就是一个 write barrier, GC Heap 被分割为固定大小的 card
保存在 CardTable 中, 每次对 GC Heap 的修改会导致 CardTable 中相应的
card 被标记为 dirty. 如此一来, 重新标记时只需要考虑这些 dirty 的 card
对应的内存中的对象. 
</p>
<div class="org-src-container">

<pre class="src src-text">scanDirtyCards
  HeapBitmap *markBits = ctx-&gt;bitmap;
  const u1 *card = start, *prevAddr = NULL;
  while (card &lt; end):
    if (*card != GC_CARD_DIRTY):
      return card;
    while (ptr &lt; limit):
      // &#25152;&#35859;&#30340; gray object, &#26159;&#25351;&#35813; object &#24050;&#32463;&#25195;&#25551;&#21040;, &#20294;&#27809;&#26377;&#21518;&#32493;&#36827;&#19968;&#27493;&#25195;&#25551;
      // dalvic GC mark &#37096;&#20998;&#20195;&#30721;&#39057;&#32321;&#25552;&#21040; black, white, gray, &#24212;&#35813;&#26159;&#25351; dalvik
      // &#20351;&#29992;&#20102; tri-color marking (&#19977;&#33394;&#26631;&#35760;&#31639;&#27861;)
      // &#37325;&#26032;&#26631;&#35760;&#30340;&#30446;&#30340;&#19981;&#26159;&#20026;&#20102;&#25226;&#24050;&#32463; mark &#30340; unmark, &#32780;&#26159;
      // &#23558;&#26032;&#20135;&#29983;&#30340;&#21487;&#36798;&#30340; object &#37325;&#26032; mark, &#30830;&#20445;&#27809;&#26377;&#27491;&#22312;&#20351;&#29992;
      // &#30340;&#23545;&#35937;&#34987; GC
      // Additionally, although the
      // collector guarantees to identify all live objects during a
      // marking phase, some objects may become garbage during that phase
      // and they will not be reclaimed until the next old
      // generation collection. Such objects are referred to as floating garbage.
      Object *obj = nextGrayObject(ptr, limit, markBits);
        // nextGrayObject &#30340;&#36807;&#31243;&#26159;&#22312; dirty card &#34920;&#31034;&#30340;&#20869;&#23384;&#30340;&#33539;&#22260;&#20869;
        // &#23545;&#27599;&#19968;&#20010; 8 bytes &#23545;&#40784;&#30340;&#22320;&#22336;&#22312; markBits &#20013;&#26597;&#25214;, &#30475;&#30475;&#26159;&#19981;&#26159;&#19968;&#20010;
        // &#23545;&#35937;.
        for (ptr = base; ptr &lt; limit; ptr += HB_OBJECT_ALIGNMENT) {
          if (dvmHeapBitmapIsObjectBitSet(markBits, ptr)):
            return (Object *)ptr;
      scanObject(obj, ctx);
      ptr = (u1*)obj + ALIGN_UP(objectSize(obj), HB_OBJECT_ALIGNMENT);

    if (ptr &lt; limit) {
    /* Ended within the current card, advance to the next card. */
      ++card;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Copying GC</h3>
<div class="outline-text-3" id="text-1-7">
<p>
上面提到的都是关于 MarkSweep GC 的, 包含 markBits, liveBits,
Concurrent GC 等都是和 MarkSweep GC 相关. 因为 android 默认的就是
MarkSweep GC. 
</p>

<p>
实际上, android 还实现了一个 Copying GC, 还两种 GC 对外都是实现了
HeapSource 这一接口, 例如 dvmHeapSourceAlloc 这个负责分配内存的函数在
HeapSource.cpp (对应 MarkSweep) 和 Copying.cpp (对应 Copying) 中都有实
现. 编译时只会编译某一个进行 (否则会发生重复定义), 所以两者只能在编译
时确定使用哪个, 无法动态切换. 
</p>

<p>
Copying GC 把整个 GC Heap 分为大小为 512 Bytes 的 block, 并且通过一个
blockSpace 数组来记录各个 block 的状态, 目前定义了四种状态:
</p>
<ul class="org-ul">
<li>BLOCK<sub>FREE</sub>
</li>
<li>BLOCK<sub>FROM</sub><sub>SPACE</sub>
</li>
<li>BLOCK<sub>TO</sub><sub>SPACE</sub>
</li>
<li>BLOCK<sub>CONTINUED</sub>
</li>
</ul>

<p>
即, Copying GC 并没有像传统的 Copying GC 那样, 把 heap 分为两个固定大
小的空间, 也没有像 hot spot 那样分为一个 Eden 和两个 survivor. 
</p>
</div>


<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> dvmHeapSourceAlloc</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
初始状态下所有 block 都为 free, 当每次调用 dvmHeapSourceAlloc 时,
Copying GC 会通过两个指针记录当前正在"使用"的 block:
</p>

<div class="org-src-container">

<pre class="src src-text">/* Start of free space in the current block. */
u1 *allocPtr;
/* Exclusive limit of free space in the current block. */
u1 *allocLimit;
</pre>
</div>

<p>
若要分配的对象大小还能放在当前正在"使用"的 block 中, 则直接通过
advance allocPtr 的方法来分配. 
</p>

<p>
若当前 block 大小不够了, 则通过 allocateBlocks(heapSource, blocks) 分
配一个或多个新的连续 block, 然后把这些 block 在 blockSpace 中标记为
BLOCK<sub>TO</sub><sub>SPACE</sub>, 并且修改 allocPtr 和 allocLimit, 把当前正在"使用" 的
block 指向新的 block.
</p>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> dvmScavengeRoots</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
与 MarkSweep 把 GC 分为 mark 阶段和 sweep 阶段不同, copying 只有一个
scavenge 阶段. 
</p>

<p>
Copying GC 与 MarkSweep 一样, 都是通过 Heap.cpp 的
dvmCollectGarbageInternal 开始 GC 的
</p>

<div class="org-src-container">

<pre class="src src-text">dvmCollectGarbageInternal
  dvmHeapMarkRootSet();
    /* do nothing */
  dvmHeapScanMarkedObjects();
    dvmScavengeRoots
  dvmHeapProcessReferences();
    /* do nothing */
  dvmHeapSweepUnmarkedObjects();
    /* do nothing */
  // ...
</pre>
</div>

<p>
可见, 为了把后写的 Copying GC 放到之前按照 MarkSweep 实现的框架了,
Copying GC 写了许多空的 stub 函数. 最终只有一个 dvmScavengeRoots 是有
用的. 
</p>


<p>
dvmScavengeRoots 需要解决几个问题:
</p>
<ol class="org-ol">
<li>把对象从 BLOCK<sub>FROM</sub><sub>SPACE</sub> 的 block 复制到 BLOCK<sub>TO</sub><sub>SPACE</sub>
</li>
<li>修改引用关系
</li>
<li>对 `pinning` 的对象要特殊处理
</li>
<li>处理 hashcode
</li>
</ol>

<div class="org-src-container">

<pre class="src src-text">dvmScavengeRoots
  dvmHeapSourceFlip();
    // &#25226;&#31867;&#22411;&#20026; BLOCK_TO_SPACE &#30340; block &#21464;&#20026; BLOCK_FROM_SPACE
    // &#22240;&#20026; dvmHeapSourceAlloc &#20998;&#37197;&#30340;&#23545;&#35937;&#37117;&#25918;&#22312; BLOCK_TO_SPACE &#20013;

  /*
  * Promote blocks with stationary objects.
  */
  pinThreadList();
  pinReferenceTable(&amp;gDvm.jniGlobalRefTable);
  pinReferenceTable(&amp;gDvm.jniPinRefTable);
  pinHashTableEntries(gDvm.loadedClasses);
  pinHashTableEntries(gDvm.dbgRegistry);
  pinPrimitiveClasses();
  pinInternedStrings();
    // &#25152;&#35859;&#30340; pin, &#23601;&#26159;&#25226;&#19968;&#20010; object &#25152;&#22312;&#30340; block &#30001; BLOCK_FROM_SPACE
    // &#21464;&#20026; BLOCK_TO_SPACE
    promoteBlockByAddr(*addr)
      heapSource-&gt;blockSpace[block] = BLOCK_TO_SPACE;
      enqueueBlock(heapSource, block);

  // &#37325;&#32622; allocPtr &#21644; allocLimit
  gDvm.gcHeap-&gt;heapSource-&gt;allocPtr = allocateBlocks(gDvm.gcHeap-&gt;heapSource, 1);
  gDvm.gcHeap-&gt;heapSource-&gt;allocLimit = gDvm.gcHeap-&gt;heapSource-&gt;allocPtr + BLOCK_SIZE;

  scavengeThreadList();
  scavengeReference(&amp;gDvm.outOfMemoryObj);
  scavengeReference(&amp;gDvm.internalErrorObj);
  scavengeReference(&amp;gDvm.noClassDefFoundErrorObj);
  scavengeInternedStrings();

  scavengeBlockQueue();

  preserveSoftReferences(&amp;gDvm.gcHeap-&gt;softReferences);
  clearWhiteReferences(&amp;gDvm.gcHeap-&gt;weakReferences);
  processFinalizableReferences();
  clearWhiteReferences(&amp;gDvm.gcHeap-&gt;softReferences);
  clearWhiteReferences(&amp;gDvm.gcHeap-&gt;weakReferences);
  clearWhiteReferences(&amp;gDvm.gcHeap-&gt;phantomReferences);
  clearFromSpace(gcHeap-&gt;heapSource);
</pre>
</div>
<p>
与 MarkSweep 采用一个 markStack 来迭代 mark 类似, Copying GC 使用一个
blockQueue 进行迭代式的 scavenge.
</p>

<p>
在上面的函数中, scavengeBlockQueue 之前的各种 scavangeXxx 类似于
MarkSweep 的 scanRootSet, 这些函数会负责对 GC root 进行初步的
scavange, 主要是通过 allocateGray 在 BLOCK<sub>TO</sub><sub>SPACE</sub> 生成 GC ROOT 的
copy. 这个新对象被称为 gray object, 是因为它们还需要后续的处理: 
</p>

<ol class="org-ol">
<li>它引用到的其他对象还没处理
</li>
<li>它引用的对象的指针需要被调整
</li>
</ol>

<p>
以下面的对象为例:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">class</span> <span style="color: #b58900;">A</span> {
    <span style="color: #b58900;">B</span> <span style="color: #268bd2;">b</span>;
    <span style="color: #b58900;">C</span> <span style="color: #268bd2;">c</span>;
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">B</span> {
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>;
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">C</span> {
    <span style="color: #b58900;">B</span> <span style="color: #268bd2;">b2</span>;
}
</pre>
</div>

<p>
假设 A 对象有 GC root, 则 
</p>
<ol class="org-ol">
<li>scavange a, blockQueue 为 {a'}, 但其 a'.b, a'.c 都指向旧的 b,c 的地址.
</li>
<li>scavange a', 导致 b,c 被 copy 到 b',c', 此时 blockQueue 为 {b',c'}
</li>
<li>scavange b'
</li>
<li>scavange c', blockQueue 为 {b2'}
</li>
<li>scavange b2'
</li>
</ol>

<p>
可见, scavange 过程是一个 BFS 过程.
</p>

<p>
BFS 中对每个节点的处理, 主要是 scavengeObject
</p>

<div class="org-src-container">

<pre class="src src-text">scavengeObject
  scavengeDataObject
    scavengeReference((Object **) obj);
    for every field:
      Object **ref = (Object **)((u1 *)obj + offset);
      scavengeReference(ref);
</pre>
</div>

<p>
最主要的代码是在 scavengeReference, 当我们对 a'-&gt;b 调用scavengeReference 时,
会导致:
</p>
<ol class="org-ol">
<li>a'-&gt;b 被复制到 b' 
</li>
<li>a'-&gt;b 这个引用被修改为 a'-&gt;b'
</li>
<li>b' 被加入 blockQueue 中
</li>
</ol>

<div class="org-src-container">

<pre class="src src-text">scavengeReference(Object ** obj)
  // toSpaceContains, &#35828;&#26126; *obj &#24050;&#32463;&#26159;&#22797;&#21046;&#21518;&#30340;&#23545;&#35937;(&#25110;&#32773;&#35813;&#23545;&#35937;&#26159; pin &#29366;
  // &#24577;),&#19988;&#19978;&#23618;&#24341;&#29992;&#30340;&#20063;&#26159;&#26032;&#30340;&#23545;&#35937;&#20102;, &#30452;&#25509;&#36820;&#22238;
  if (toSpaceContains(*obj)):
    LOG_SCAV("scavengeReference skipping pinned object @ %p", *obj);
    return;
  if (isForward(*obj)):
    // &#35828;&#26126; a'-&gt;b &#25351;&#21521;&#36824;&#26159;&#26087;&#30340; b &#23545;&#35937;, &#20294;&#26159;&#26087;&#30340; b &#23545;&#35937;&#24050;&#32463;&#34987;&#26631;&#35760;&#20026; forward
    // &#21363; b' &#24050;&#32463;&#29983;&#25104;, &#36890;&#36807; getForward &#21487;&#20197;&#25343;&#21040;&#36825;&#20010; b'
    *obj = (Object *)getForward(*obj);
    return;
  // a'-&gt;b &#36824;&#27809;&#32463;&#36807; copy
  toObj = transportObject(fromObj);
    assert(fromSpaceContains(fromObj));
    toObj = allocateGray(allocSize);
      addr = dvmHeapSourceAlloc(size);
      block = addressToBlock(heapSource, (const u1 *)addr);
      // &#26032;&#30340; gray object &#36827;&#34892; blockQueue
      enqueueBlock(heapSource, block);
    memcpy(toObj, fromObj, copySize);
  setForward(toObj, fromObj);
    *(unsigned long *)fromObj = (uintptr_t)toObj | 0x1;
  *obj = (Object *)toObj;
</pre>
</div>
</div>

<div id="outline-container-sec-1-7-2-1" class="outline-5">
<h5 id="sec-1-7-2-1"><span class="section-number-5">1.7.2.1</span> forward</h5>
<div class="outline-text-5" id="text-1-7-2-1">
<p>
getForward, isForward, setForward 这三个函数是用来实现对象移动后指针的
重定位的. 
例如, 假设 a-&gt;b 和 c-&gt;b2 本来指向的是同一个 B 对象. 当 scavenge a 的过
程中, b 被复制到 b', 那么 scavenge c 时, 如果把 c'-&gt;b2 指向 b'?
</p>

<p>
当 b 被复制到 b' 时, 会调用 setForward(b',b), 即
</p>

<div class="org-src-container">

<pre class="src src-text">*(unsigned long *)b = (uintptr_t)b' | 0x1;
</pre>
</div>

<p>
可见, setForward 后, 原来的 b 对象不再是一个有效的 java 对象, 因为它的
每一个 long 会被改写为 b' 的地址加一个 0x1 的标记 (这种 b' | 0x1 是有
效的, 因为 b' 保证是 8 bytes 对齐的), 这种改写虽然破坏了 b 对象, 但信
息通过 b' 已经保存了下来, 没有什么问题. 
</p>

<p>
当 scavenge c' 时, 通过对 c'-&gt;b2 执行 isForward 判断, 可以知道 b2' 是
否存在, 若已经存在, 则直接通过 getForward 从 b2 中获得 b2' 地址即可. 
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-04-16 Wed 17:56</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
