<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>JIT And AOT</title>
<!-- 2014-09-26 Fri 10:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">JIT And AOT</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. JIT</a>
<ul>
<li><a href="#sec-1-1">1.1. common<sub>updateProfile</sub></a></li>
<li><a href="#sec-1-2">1.2. dvmCompileTrace</a></li>
</ul>
</li>
<li><a href="#sec-2">2. AOT</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> JIT</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> common<sub>updateProfile</sub></h3>
<div class="outline-text-3" id="text-1-1">
<p>
JIT 的入口是 common<sub>updateProfile</sub>, 例如, 在 OP<sub>IF</sub><sub>EQ</sub> 等跳转指令处会针
对 branch target 处的指令进行 common<sub>updateProfile</sub> 的检查. 跳转指令的
branch target 通常会做为 trace head. 例如下面的代码:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = 0;
    <span style="color: #859900;">for</span> (<span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 1000; i++) {
        result += i;
    }
}
</pre>
</div>

<p>
循环对应的 byte code 为:
</p>
<div class="org-src-container">

<pre class="src src-text">0 :goto_2
1 const/16
2 if-ge v0, v2, :cond_a
3 add-int/2addr v1, v0
4 add-int/lit8 v0, v0, 0x1
5 goto :goto_2
</pre>
</div>

<p>
第 3 行因为是第 2 行的 branch target, 所以会成为一个 trace head. 而
trace 只会结束于条件跳转(非 goto 的跳转), invoke, return, throw 或 too
large (1000 条trace), 所以第 3 行开始的 trace 最终会结束于第 2 行
if-ge, 最终这条 trace 的结果是:
</p>

<div class="org-src-container">

<pre class="src src-text">09-22 09:59:18.340 D/dalvikvm( 2259): Compiler: Building trace for main, offset 0x6
09-22 09:59:18.340 D/dalvikvm( 2259): 0xa986f1f4: 0x00b0 add-int/2addr v1, v0, (#0)
09-22 09:59:18.340 D/dalvikvm( 2259): 0xa986f1f6: 0x00d8 add-int/lit8 v0, v0, (#1)
09-22 09:59:18.340 D/dalvikvm( 2259): 0xa986f1fa: 0x0028 goto (-7)
09-22 09:59:18.340 D/dalvikvm( 2259): 0xa986f1ec: 0x0013 const/16 v2, (#1000), (#0)
09-22 09:59:18.340 D/dalvikvm( 2259): 0xa986f1f0: 0x0035 if-ge v0, v2, (+6)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">common_updateProfile:
  // &#36825;&#37324;&#36127;&#36131;&#20174; thread-&gt;pJitProfTable &#20013;&#33719;&#24471;&#35813; rPC &#23545;&#24212;&#30340; threshold (&#21021;&#22987;&#20026;&#26368;&#22823;&#20540; 40, &#27599;&#21629;&#20013;&#19968;&#27425;&#20943;&#19968;)
  // &#33509; threshold &#24050;&#32463;&#20026; 0, &#35828;&#26126;&#35813;&#20195;&#30721;&#26159; hot &#30340;, &#28982;&#21518;&#20250;&#36339;&#21040; common_Profile &#36827;&#34892; JIT &#30456;&#20851;&#25805;&#20316;. &#21542;&#21017;&#30452;&#25509;
  // &#36890;&#36807; GOTO_NEXT &#32487;&#32493;&#25191;&#34892; interp
  common_Profile:
    // &#26681;&#25454; pc &#26597;&#25214;&#35813; trace &#26159;&#21542;&#24050;&#32463;&#34987;&#32534;&#35793;
    call   dvmJitGetTraceAddrThread  # (pc, self)
    // &#33509;&#36824;&#27809;&#26377;&#34987;&#32534;&#35793;&#20986;&#26469;
    // &#36890;&#36807;&#26597;&#30475; interpBreak-&gt;subMode, &#30830;&#23450;&#26159;&#21542;&#24050;&#32463;&#22312;&#32534;&#35793; (kSubModeJitSV)
    movzwl      offThread_subMode(%ebx), %ecx
    and         $(kSubModeJitTraceBuild | kSubModeJitSV), %ecx
    // &#33509;&#24050;&#32463;&#22312;&#32534;&#35793;, &#21017;&#32487;&#32493;&#20197; interp &#26041;&#24335;&#25191;&#34892;
    jne         3f                     # already doing JIT work, continue
    FETCH_INST
    // &#21542;&#21017;
    call dvmJitCheckTraceRequest
      // &#24320;&#22987; trace build &#27169;&#24335;
      dvmEnableSubMode (self, kSubModeJitTraceBuild);
        updateInterpBreak
          // &#20462;&#25913;&#20102; curHandlerTable, &#21518;&#32493; byte code &#30340;&#35299;&#37322;&#20250;&#36890;&#36807;&#36825;&#20010;
          // altHandlerTable &#35299;&#37322;
          newValue.ctl.curHandlerTable = (newValue.ctl.breakFlags) ?
            thread-&gt;altHandlerTable : thread-&gt;mainHandlerTable;
</pre>
</div>

<p>
当 dvmJitCheckTraceRequest 决定开始 trace build 模式后, 后续所有的
byte code 的解释会通过 altHandlerTable 进行, 而 altHandlerTable 对所有
byte code 的解释基本都是一样的, 例如:
</p>

<div class="org-src-container">

<pre class="src src-text">.L_ALT_OP_MOVE: /* 0x01 */
/* File: armv5te/alt_stub.S */
/*
* Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
* any interesting requests and then jump to the real instruction
* handler.    Note that the call to dvmCheckBefore is done as a tail call.
* rIBASE updates won't be seen until a refresh, and we can tell we have a
* stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
* bail to the real handler if breakFlags==0.
*/
ldrb   r3, [rSELF, #offThread_breakFlags]
adrl   lr, dvmAsmInstructionStart + (1 * 64)
ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
cmp    r3, #0
// &#26816;&#26597; interpBreak-&gt;subMode, &#33509;&#19981;&#26159; jni &#27169;&#24335;, &#21017;&#30452;&#25509;&#35843;&#29992;
// mainHandlerTable &#20013;&#30456;&#24212;&#30340; entry (dvmAsmInstructionStart &#23545;&#24212;&#20110; mainHandlerTable)
bxeq   lr                   @ nothing to do - jump to real handler
EXPORT_PC()
mov    r0, rPC              @ arg0
mov    r1, rFP              @ arg1
mov    r2, rSELF            @ arg2
// &#21542;&#21017;, &#35843;&#29992; dvmCheckBefore &#36827;&#34892; trace build
b      dvmCheckBefore       @ (dPC,dFP,self) tail call
  if (self-&gt;interpBreak.ctl.subMode &amp; kSubModeJitTraceBuild):
    dvmCheckJit(pc, self);
      // &#33509; trace build &#27491;&#22312;&#36827;&#34892;
      if self-&gt;jitState == kJitTSelect:
        self-&gt;trace[self-&gt;currTraceRun].info.frag.numInsts++;
        self-&gt;totalTraceLen++;
        self-&gt;currRunLen += len;
      else if self-&gt;jitState == kJitTSelectEnd:
      // trace build &#32467;&#26463;, &#25552;&#20132;&#32473; compiler &#32534;&#35793;
        dvmCompilerWorkEnqueue
</pre>
</div>
<p>
而 jitState 变为 kJitTSelectEnd 的时机实际上就是 trace 结束的条件: 条件跳转(非 goto 的跳转), invoke, return, throw 或 too
large (1000 条trace), 主要是 dvmCheckJit 中的这段代码:
</p>

<div class="org-src-container">

<pre class="src src-cpp">dvmCheckJit
  <span style="color: #859900;">if</span> (<span style="color: #dc322f;">!</span>dexIsGoto(flags) &amp;&amp;
    ((flags &amp; (kInstrCanBranch |
               kInstrCanSwitch |
               kInstrCanReturn |
               kInstrInvoke)) != 0)):
    self-&gt;jitState = kJitTSelectEnd;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> dvmCompileTrace</h3>
<div class="outline-text-3" id="text-1-2">
<p>
common<sub>updateProfile</sub> 会导致一条 trace 被记录下来, 最终会通过
dvmCompileTrace 进行编译.
</p>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> BasicBlock</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
dvmCompileTrace 的第一步是构造各种 BasicBlock, 并且将这些 BasicBlock通
过 block-&gt;taken 和 block-&gt;fallThrough 连接起来. 最终这些 block 构造成
一个树型结构.
</p>

<p>
这些 BasicBlock 中, 有一些代表着 trace 中一个 trace run对应的 MIR, 有
一些只是虚拟的 block, 本身并不对应于 trace 中具体指令, 但它们会通过
block 的 type 被后续 MIR2LIR 部分的代码识别, 编译出一些特殊的 LIR.
</p>

<p>
首先, 生成一个 entry block, 然后对每一个 trace run , 生成一个
kDalvikByteCode 类型的 BasicBlock, 且这些 BasicBlock 的 MIR 链表中会包
含通过 parseInsn 生成的 MIR (每个 MIR 结构对应一个 opcode 及其参数)
</p>

<p>
所有 kDalvikByteCode 类的 BasicBlock 生成后, 需要扫描这些 BasicBlock,
使它们通过 block-&gt;taken 和 block-&gt;fallThrough 连接起来. 扫描的方法就是
若BasicBlock A 的 targetOffset 和另一个 BasicBlock B 的 startOffset
相同, 则 A-&gt;taken = B, 若 A-&gt;fallThroughOffset == C-&gt;startOffset, 则
A-&gt;fallThrough = C.
</p>

<p>
若 BasicBlock 是因为 trace 过长结束, 或者 BasicBlock 的 taken 和
fallthrough 需要引用的 BasicBlock 在这些BasicBlock 中不存在, 则上一步
无法生成 taken 和 fallThrough 连接. 这时需要生成一些称之为 chaining
cell 的虚 BasicBlock, 这些 BasicBlock 的类型为 kChainingCellNormal, 本
身并不包含任何 MIR. 后续 MIR2LIR 时会将这些 chaining cell 翻译为
dvmJitToInterpNormal 调用, 而 dvmJitToInterpNormal 会负责从
JitCodeCache 中查找是否存在一个真正 BasicBlock 与该 chaining cell 引用
的地址一致, 若存在, 则通过 dvmJitChain 用真正的 BasicBlock 对应的
JitCodeCache 地址替换 chaining cell 对应的地址, 否则就切换到解释器模式
去解释执行后续的代码.
</p>

<p>
当 BasicBlock 以及 taken, fallThrough, 包括 chaining cell 建立完成后,
就可以进行下一步操作了.
</p>

<p>
以一个简单的两条指令的 trace 为例:
</p>
<div class="org-src-container">

<pre class="src src-text">const/16 v2, (#1000), (#0)
if-ge v0, v2, (+6)
</pre>
</div>

<p>
最终生成 BasicBlock 的情况如下:
</p>
<pre class="example">
Block 0 (Entry Block) (insn 0002 - 0002 empty)
  Fallthrough : block 1 (0002)
Block 1 (Code Block) (insn 0002 - 0004)
  Taken branch: block 3 (000a)
  Fallthrough : block 2 (0006)
Block 2 (Normal Chaining Cell) (insn 0006 - 0006 empty)
Block 3 (Normal Chaining Cell) (insn 000a - 000a empty)
Block 4 (PC Reconstruction) (insn 0000 - 0000 empty)
Block 5 (Exception Handling) (insn 0000 - 0000 empty)
</pre>

<p>
其中只有 Block 1 是 kDalvikByteCode 类型的 code block.
</p>

<p>
Block 2, Block 3 是生成的 chaining cell, 分别做为 Block 1 的 taken 和
fallthrough.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> mir -&gt; lir</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
BasicBlock 生成后, 即 MIR 生成后, 会通过 dvmCompilerMIR2LIR 生成
LIR.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> lir -&gt; assemble</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
生成 LIR 后, 通过 dvmCompilerAssembleLIR 生成机器码, 并安装于
JitCodeCache 中;
</p>

<p>
以上面提到的两条指令的 trace 为例, 最终生成的机器码如下:
</p>
<pre class="example">
Dumping LIR insns
installed code is at 0xa756d078
total size is 80 bytes
0xa756d078 (0000): data    0xd09c(53404)
0xa756d07a (0002): data    0xb7bb(47035)
0xa756d07c (0004): data    0x0034(52)
0xa756d07e (0006): ldr     r0, [r15pc, -#8]
0xa756d082 (000a): ldr     r1, [r0, #0]
0xa756d084 (000c): adds    r1, r1, #1
0xa756d086 (000e): str     r1, [r0, #0]
-------- entry offset: 0x0002
L0xb7baedfc:
-------- dalvik offset: 0x0002 @ const/16 v2, (#1000), (#0)
0xa756d088 (0010): ldr     r1, [r5, #0]
0xa756d08a (0012): mov     r0, #1000 [0x3e8]
-------- dalvik offset: 0x0004 @ if-ge v0, v2, (+6)
0xa756d08e (0016): cmp     r1, r0
0xa756d090 (0018): str     r0, [r5, #8]
0xa756d092 (001a): bge     0xa756d0a4 (L0xb7baee7c)  --------+
0xa756d096 (001e): b       0xa756d098 (L0xb7baee3c)  ---+    |
Exception_Handling:                                     |    |
0xa756d098 (0020): .align4                              |    |
L0xb7baee3c:                                            |    |
-------- chaining cell (normal): 0x0006              &lt;--+    |
0xa756d098 (0020): b       0xa756d09c (L0xb7baf578)          |
0xa756d09a (0022): orrs    r0, r0                            |
L0xb7baf578:                                                 |
0xa756d09c (0024): ldr     r0, [r6, #100]                    |
0xa756d09e (0026): blx     r0                                |
0xa756d0a0 (0028): data    0x71f4(29172)                     |
0xa756d0a2 (002a): data    0xffffa988(-22136)                |
0xa756d0a4 (002c): .align4                                   |
L0xb7baee7c:                                                 |
-------- chaining cell (normal): 0x000a              &lt;-------+
0xa756d0a4 (002c): b       0xa756d0a8 (L0xb7baf778)
0xa756d0a6 (002e): orrs    r0, r0
L0xb7baf778:
0xa756d0a8 (0030): ldr     r0, [r6, #100]
0xa756d0aa (0032): blx     r0
0xa756d0ac (0034): data    0x71fc(29180)
0xa756d0ae (0036): data    0xffffa988(-22136)
-------- end of chaining cells (0x0038)
End LTest;main, 2 Dalvik instructions
</pre>

<p>
其中两个 chaining cell 的代码实际是跳转到 [r6, #100], 这个地址实际就是
dvmJitToInterpNormal, 后者负责进行 dvmJitChain 或将控制交还给解释器. 
</p>

<p>
若 JitCodeCache 中存在对应于两个 chaining cell 的 startOffset (0x0006
和 0x000a)的代码, dvmJitChain 会将 chaining cell 中的跳转地址
(0xa756d09c 和 0xa756d0a8) 替换为真正的地址. 
</p>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> JIT template</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
dalvik JIT 是一个 template based JIT. 对于一些简单的指令, 例如
add-int, 会直接在 MIR2LIR 阶段生成对应的 LIR. 对于复杂一些的指令, 会使
用 template 生成, 以 monitor-enter 指令为例:
</p>

<div class="org-src-container">

<pre class="src src-text">genMonitorEnter:
  genNullCheck(cUnit, rlSrc.sRegLow, r1, mir-&gt;offset, NULL);                     
  newLIR3(cUnit, kThumb2Ldrex, r2, r1,
          offsetof(Object, lock) &gt;&gt; 2); // Get object-&gt;lock
  opRegImm(cUnit, kOpLsl, r3, LW_LOCK_OWNER_SHIFT); // Align owner
  // Is lock unheld on lock or held by us (==threadId) on unlock?
  newLIR4(cUnit, kThumb2Bfi, r3, r2, 0, LW_LOCK_OWNER_SHIFT - 1);
  newLIR3(cUnit, kThumb2Bfc, r2, LW_HASH_STATE_SHIFT,
          LW_LOCK_OWNER_SHIFT - 1);
  hopBranch = newLIR2(cUnit, kThumb2Cbnz, r2, 0);                          ;; cbnz    r2,0xa7567038 (L0xb7c68198)
  newLIR4(cUnit, kThumb2Strex, r2, r3, r1, offsetof(Object, lock) &gt;&gt; 2);   ;; strex   r2,r3, [r1, #4]
  dvmCompilerGenMemBarrier(cUnit, kSY);                                    ;; dmb     #sy
  branch = newLIR2(cUnit, kThumb2Cbz, r2, 0);                              ;; cbz     r2,0xa756704a (L0xb7c683d8)

  hopTarget = newLIR0(cUnit, kArmPseudoTargetLabel);
  hopTarget-&gt;defMask = ENCODE_ALL;
  hopBranch-&gt;generic.target = (LIR *)hopTarget;

  newLIR3(cUnit, kThumb2StrRRI8Predec, r3, r5FP,                           ;; ldr     r3, [r15pc, #196]
          sizeof(StackSaveArea) -                                          ;; ldr     r4, [r15pc, #188] 
          offsetof(StackSaveArea, xtra.currentPc));                        ;; str     r3, [r5, #-8]
  /* Call template, and don't return */
  genRegCopy(cUnit, r0, r6SELF);                                           ;; movs    r0, r6
  genDispatchToHandler(cUnit, TEMPLATE_MONITOR_ENTER);                     ;; blx_1   0xa75664c0
</pre>
</div>

<p>
其中最后的 blx<sub>1</sub> 就是跳转到 MONITOR-ENTER 对应的模板, 这里显示的地址
0xa75664c0 实际位于 JitCodeCache 的最开始的部分.
</p>

<p>
dvmCompilerSetupCodeCache 的这段代码负责将
CompilerTemplateAsm-armv7-a-neon.S 中定义的对应各个 template 的代码复
制到 JitCodeCache 的开头:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa198;">dvmCompilerSetupCodeCache</span>:
  <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">Copy the template code into the beginning of the code cache */</span>
  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">templateSize</span> = (<span style="color: #b58900;">intptr_t</span>) dvmCompilerTemplateEnd -
      (<span style="color: #b58900;">intptr_t</span>) dvmCompilerTemplateStart;
  memcpy((<span style="color: #b58900;">void</span> *) gDvmJit.codeCache,
         (<span style="color: #b58900;">void</span> *) dvmCompilerTemplateStart,
         templateSize);
</pre>
</div>

<p>
所以 0xa75664c0 这个地址位于 JitCodeCache 最开头部分, 其内容实际上
dvmCompiler<sub>TEMPLATE</sub><sub>MONITOR</sub><sub>ENTER</sub> @
CompilerTemplateAsm-armv7-a-neon.S 的拷贝.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> AOT</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-09-26 Fri 10:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.50.4 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
