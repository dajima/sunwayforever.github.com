<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Java Lightweight Lock</title>
<!-- 2014-01-30 Thu 13:23 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Java Lightweight Lock</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Java Lightweight Lock</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Java Lightweight Lock</h2>
<div class="outline-text-2" id="text-1">
<p>
Lightweight Lock 是java 1.6提供的一种锁优化机制, Dalvik 看起来也使用了这种机制. 
在虚拟机中, synchronized 对应的具体指令是 MonitorEnter/MonitorExit, 例如:
</p>
<pre lang="java" line="1">
    Object obj=new Object ();
    synchronized (obj) {
      System.out.println("");
    }
</pre>
<p>
对应的byte code是:
</p>
<pre lang="java" line="1">
        ...
   10:  astore_2
   11:  monitorenter
   12:  getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;
   15:  ldc     #4; //String 
   17:  invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   20:  aload_2
   21:  monitorexit
</pre>

<p>
Dalvik 的 MonitorEnter() 的源码:
</p>
<pre lang="c" line="1">
    MonitorEnter:
      dvmLockObject(_self, obj);
        threadId = self->threadId;
        thinp = &obj->lock; // 每个object都有一个四字节的lock成员,在hotspot虚拟机, 这个u4长度的lock和hash code等一起,放在对象头的Mark Word中 
        if LW_SHAPE(thin) == LW_SHAPE_THIN:  // LW_SHAPE 实际是取 thin 这个 u4的最低位, 若为0, 表示这是一个thin lock ,否则, 为fat lock
          if LW_LOCK_OWNER(thin) == threadId:
            obj->lock += 1 << LW_LOCK_COUNT_SHIFT;
          else if LW_LOCK_OWNER(thin) == 0:
            ATOMIC_CMP_SWAP((int32_t *)thinp, thin, newThin)
          else:
            for (;;):
              if LW_SHAPE(thin) == LW_SHAPE_THIN:
                if ATOMIC_CMP_SWAP:
                  break;
              else:
                sched_yield() ;; lock is inflated by another thread to FAT_LOCK
              ;; we have acquired the lock, FATTEN it.
              mon = dvmCreateMonitor(obj);
            lockMonitor(self, mon);b
            thin |= (u4)mon | LW_SHAPE_FAT;
        else: // is a FAT_LOCK
          lockMonitor(self, LW_MONITOR(obj->lock));
</pre>
<ul class="org-ul">
<li>所谓thin lock, fat lock:

<p>
在Lightweight Lock中, 同一个对象的锁可能处于两种状态:thin, fat; thin lock 是指该锁可以使用CAS (Compare And Swap) 这种轻量级的指令直接获得或释放,开销很小. 
fat lock 是指该锁必须使用操作系统提供的mutex进行获取或释放,开销较大.
</p>
</li>
<li>CAS

<p>
Compare And Swap, 意思是比较两个值,若不等,则进行交换, 这个指令的关键是比较与赋值这两个操作是原子的, 不需要再加锁.在不同的平台中都有直接的机器指令与之对应,
如x86中的cmpxchg指令. CAS的开销很小,而且两个操作是原子的不用加锁,经常用来实际各种lock-free算法 
</p>
</li>
<li>lock-free, 就是避免加锁,如最简单的环形缓冲区方法
</li>
<li>上面代码显示的Lightweight Lock的实现中,关键的几点是:

<ul class="org-ul">
<li>若一个锁是thin且尚未锁定,则使用CAS加锁(实际只是修改lock的owner为当前线程,并没有什么耗时的加锁动作)
</li>
<li>若一个锁是thin且已锁定,则把它作为一个spinlock在死循环,直到之前持有thin lock的线程将thin lock释放
这里提到的thin lock的判断锁定,加锁,解锁开销都很小, 例如通过判断lock owner 判断是否加锁, 使用CAS加锁,解锁 
</li>
<li>进行spin的的线程在获得thin lock后, 会将锁升级为fat lock；thin lock此时被升级为fat lock, 是因为系统发现锁出现了竞争, 再使用spinlock很有可能会白白浪费CPU. 
</li>
<li>thin lock一旦变成fat lock, Lightweight Lock的使命就结束了, 之后对这个锁的使用操作都会使用pthread<sub>mutex</sub><sub>xxx</sub>
</li>
<li>Lightweight Lock机制没有办法把fat lock降级为thin lock 
</li>
</ul>
</li>
<li>spinlock

<p>
spinlock,即自旋锁, 线程在等待spinlock时, 不会被挂起,而是执行一个while(true)的死循环,并在这个死循环中不停的检测锁是否释放. 
spinlock适用于锁持有时间较短的情况,并且主要用在SMP的情况; 但在单处理器的情况下,就无法避免进程切换了, 因为要
退出spin, 只能靠别的进程来修改spin的flag.
</p>
</li>
<li>pthread<sub>mutex</sub><sub>xxx</sub>

<p>
pthread提供的mutex；现在linux都使用futex(Fast Usermode muTex) 来实现mutex, 开销也比以前通过syscall进入内核的方法好多了.
</p>
</li>
</ul>

<p>
总结:
</p>
<ul class="org-ul">
<li>因为Lightweight Lock机制, java的synchronized比想象的要高效, 特别是没有锁冲突的情况下,只是简单一条CAS指令,几乎没有额外开销.
</li>
<li>Lightweight Lock过程
<ol class="org-ol">
<li>T1 is the first thread acquiring the lock, so it will using CAS to acquire the THIN<sub>LOCK</sub>
</li>
<li>while T1 holding the lock, T2,T3 come to request the lock, they both will spin on the THIN<sub>LOCK</sub>
</li>
<li>when T2 acquire the lock, it will inflate the lock from THIN<sub>LOCK</sub> to FAT<sub>LOCK</sub>, and use mutex to accquire the lock; 
after that, T3 will use mutex to accquire the lock
</li>
<li>once a lock is inflated to FAT<sub>LOCK</sub>, there is no way for it to com back as THIN<sub>LOCK</sub>.
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-01-30 Thu 13:23</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
