<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Jni</title>
<!-- 2014-03-21 Fri 19:32 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Jni</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Jni</a>
<ul>
<li><a href="#sec-1-1">1.1. ScopedJniThreadState</a></li>
<li><a href="#sec-1-2">1.2. RegisterNatives</a></li>
<li><a href="#sec-1-3">1.3. JNI Call Bridge</a></li>
<li><a href="#sec-1-4">1.4. JNI Calling Conventions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Jni</h2>
<div class="outline-text-2" id="text-1">
<p>
jni.cpp 中包含 jni spec 中规定的各种接口的实现.
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> ScopedJniThreadState</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在调用任何 jni spec 中规定的接口之前, 都需要初始化一个
ScopedJniThreadState, 这个类主要作用是在初始化时调用
dvmChangeStatus(Thread.RUNNING), 在析构时调用
dvmChangeStatus(Thread.NATIVE), 因为:
"
All JNI methods must start by changing their thread status to
THREAD<sub>RUNNING</sub>, and finish by changing it back to THREAD<sub>NATIVE</sub> before
returning to native code.  The switch to "running" triggers a thread
suspension check.
"
</p>

<p>
之所以这样, 是因为 dvmChangeStatus(Thread.RUNNING) 时会有一个检查: 若
vm 当前因为 debugger, trace 等原因被 suspend, 则这个 dvmChangeStatus 也
会 block, 阻止 native 代码访问任何 java 对象
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> RegisterNatives</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在 System.loadLibrary 时, lib 中的 JNI<sub>OnLoad</sub> 会被调用, 这里 lib 通常
会通过 env-&gt;RegisterNatives 注册 jni 函数.
</p>
<div class="org-src-container">

<pre class="src src-text">// Register a method that uses JNI calling conventions.
// &#25152;&#35859;&#30340; JNI calling conventions, &#26159;&#25351;&#19978;&#23618; java &#35843;&#29992; jni &#20989;&#25968;&#26102;&#20351;
// &#29992;&#30340; calling conventions, &#21363;: &#19978;&#23618; java &#22914;&#20309;&#21521; jni &#20256;&#36882;&#21442;&#25968;, &#22914;&#20309;&#22788;
// &#29702; jni &#36820;&#22238;&#20540;&#31561;
dvmRegisterJNIMethod(ClassObject* clazz, char * methodName, char * sig, void * fnPtr)
  Method* method = dvmFindDirectMethodByDescriptor(clazz, methodName, signature);
  if method == null:
    method = dvmFindVirtualMethodByDescriptor(clazz, methodName,signature);
  if (method-&gt;nativeFunc != dvmResolveNativeMethod):
    // already registered
  dvmUseJNIBridge(method, fnPtr);
    // Point "method-&gt;nativeFunc" at the JNI bridge, and overload "method-&gt;insns"
    // to point at the actual function.
    DalvikBridgeFunc bridge = dvmCallJNIMethod;
    dvmSetNativeFunc(method, bridge, (const u2*) func);
    // method-&gt;nativeFunc &#20250;&#34987;&#35774;&#32622;&#20026;&#36825;&#20010; bridge function, &#30495;&#27491;&#30340;
    // native func &#20250;&#34987;&#20445;&#23384;&#21040; method-&gt;insns. &#24403;&#19978;&#23618;&#38656;&#35201;&#35843;&#29992; &#20219;&#20309; jni &#20989;&#25968;&#26102;
    // &#37117;&#20250;&#20808;&#35843;&#29992;&#21040; dvmCallJNIMethod &#36825;&#20010; bridge &#20989;&#25968;, &#32780;
    // dvmCallJNIMethod &#36890;&#36807;&#26368;&#32456;&#30340; dvmPlatformInvoke &#23558; JNI &#30340; calling
    // conventions &#36716;&#25442;&#20026; arch &#30456;&#20851;&#30340; calling conventions &#21518;&#20877;&#35843;&#29992;&#30495;&#27491;
    // &#30340; jni &#20989;&#25968;.
    // dvmPlatformInvoke &#26159; arch &#30456;&#20851;&#30340;, &#19968;&#33324;&#20351;&#29992;&#24179;&#21488;&#30456;&#20851;&#30340;&#27719;&#32534;&#20889;&#25104;,
    // &#20363;&#22914; Call386ABI.S
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Lazy register natives (dvmResolveNativeMethod)</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
当 lib 中没有实现 JNI<sub>OnLoad</sub> 时, lib 中的 jni 函数都是没有注册的. 但
dvm 中有一个 dvmResolveNativeMethod 方法, 可以在调用 jni 函数时临时去
解析. 
</p>

<p>
具体的做法是: 
OO/Class.cpp 在加载 class 和 methods 时, 会将 `method-&gt;nativeFunc =
dvmResolveNativeMethod`, 此后如果没有调用过 RegisterNatives, 则
dvmCallMethodV 时会最终调用到 dvmResolveNativeMethod, 从而实现 lazy
register. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> JNI Call Bridge</h3>
<div class="outline-text-3" id="text-1-3">
<p>
dvm 中大部分代码都是使用 portable C 写的, 但 JNI Call Bridge (即
dvmPlatformInvoke) 不是, 因为它的作用是将 JNI Calling Conventions 转换
为 arch 相关的 Calling Conventions (x86, arm, mips &#x2026;), 虽然使用
libffi 可以用 portable C 的方式实现 bridge, 但速度较慢, 所以 android 对
每一个支持的 arch 都用 asm 实现了一个 bridge. JNI Call Bridge 的入口函
数是 dvmCallJNIMethod
</p>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> JNI Calling Conventions</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>dvmCallMethodV
</li>
<li>dvmCallJNIMethod
</li>
<li>dvmInterpret
</li>
</ul>

<p>
任何支持函数的语言都要定义其 calling conventions, Jni calling
conventions 主要体现在 dvmCallMethodV 函数中, 简单说来, 在调用任何函数
(java 或 jni) 函数时,参数都会根据 signature 被"打包"在一个 u4 类型的数
组,并被置于当前 java 栈帧的某个位置. java 或 jni 函数会从这个 u4 数组中
根据 signature "解包" 出原始的参数. 相应的, 返回值也会做类似处理.
</p>

<div class="org-src-container">

<pre class="src src-text">dvmCallMethodV()
  // &#22788;&#29702;&#21442;&#25968;
  while (*desc != '\0'):
    switch (*(desc++)) {
      case 'L': {     /* 'shorty' descr uses L for all refs, incl array */
        jobject argObj = reinterpret_cast&lt;jobject&gt;(arg);
        if (fromJni)
            *ins++ = (u4) dvmDecodeIndirectRef(self, argObj);
        else
            *ins++ = (u4) argObj;
        break;
      }
  if (dvmIsNativeMethod(method)):
    dvmCallJNIMethod(pResult)
  else:
    dvmInterpret(pResult);
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">dvmCallJNIMethod
  // dvmCallJNIMethod &#22312; dvmPlatformInvoke &#20043;&#21069;, &#23558; object &#36716;&#25442;&#20026;
  // IndirectRefTable reference
  while (*shorty != '\0'):
    switch (*shorty++) {
      case 'L':
        modArgs[idx] = (u4) addLocalReference(self, (Object*) modArgs[idx]);

  dvmChangeStatus(self, THREAD_NATIVE);      
  dvmPlatformInvoke(ins);
  dvmChangeStatus(self, THREAD_RUNNING);
  // &#22788;&#29702;&#36820;&#22238;&#20540;
  convertReferenceResult(pResult);
    pResult-&gt;l = dvmDecodeIndirectRef(self, (jobject) pResult-&gt;l);
</pre>
</div>

<p>
可见, 由于Jni IndirectRefTable 的存在, 需要对于类型为 `L` 的参数要额外
处理:
</p>

<ol class="org-ol">
<li>若调用本身就是来自于 jni 调用 (例如在 jni 代码中再调用 java 类的函
数), 则参数并不是对象本身的地址 (argObj), 因为这里的argObj
并不是一个有效的地址, 而是相当于 IndirectRefTable 中的一个索引, 所以
需要通过 dvmDecodeIndirectRef 获得对象真正的地址后再传递给 jni
</li>

<li>若调用不是来自于 jni, 则 argObj 本身就是对象的地址, 可以直接传递给
jni
</li>
</ol>

<p>
在通过 dvmPlatformInvoke 调用真正的 jni 函数之前, dvmCallJNIMethod 会先
用 addLocalReference(self, (Object*) argObj) 生成一个 jobject 索引后再
调用 dvmPlatformInvoke, 所以, 一切 jni 函数的参数中的 jobject, jclass
等都是 IndirectRefTable 中的 reference 而不是真正的地址.
</p>

<p>
而若 jni 函数需要返回一个 Java Object 给 java 时, dvmCallJNIMethod 最
后的 convertReferenceResult 会负责将 jobject 转换为真正的对象的地址. 
</p>

<p>
综上:
</p>
<ol class="org-ol">
<li>上层 java 调用 jni 函数 (dvmCallMethodV) 时, 参数打包时使用的是对象
的实际地址.
</li>
<li>dvmCallJNIMethod 会先将对象保存到 IndirectRefTable 中, 然后再调用 dvmPlatformInvoke
</li>
<li>dvmPlatformInvoke (或真正的 jni 函数) 看到的对象都是
IndirectRefTable 中的 reference
</li>
<li>jni 返回给 java 层的对象会通过 IndirectRefTable 转换为实际的对象地
址. 
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-03-21 Fri 19:32</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
