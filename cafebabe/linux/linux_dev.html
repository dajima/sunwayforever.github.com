<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Linux Development</title>
<!-- 2014-01-22 Wed 16:04 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Development</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Linux Dev</a>
<ul>
<li><a href="#sec-1-1">1.1. IBM ICU and HanziToPinyin in android</a></li>
<li><a href="#sec-1-2">1.2. <span class="done DONE">DONE</span> UTC,GMT,Wall Time and so on</a></li>
<li><a href="#sec-1-3">1.3. <span class="done DONE">DONE</span> 程序运行时进行IO重定向</a></li>
<li><a href="#sec-1-4">1.4. setuid() &amp; SETUID flag</a></li>
<li><a href="#sec-1-5">1.5. <span class="done DONE">DONE</span> uuid</a></li>
<li><a href="#sec-1-6">1.6. 同步,互斥,信号量</a></li>
<li><a href="#sec-1-7">1.7. pthread<sub>mutex</sub><sub>lock</sub> 开销</a></li>
<li><a href="#sec-1-8">1.8. 关于ctors,init&#x2026;</a></li>
<li><a href="#sec-1-9">1.9. 静态库与.o还是有区别的</a></li>
<li><a href="#sec-1-10">1.10. ld链接器脚本</a></li>
<li><a href="#sec-1-11">1.11. 修改了.so或executable，正在运行的程序会有啥影响？</a></li>
<li><a href="#sec-1-12">1.12. 外部对.so的修改是如何让正在使用.so的程序崩溃的</a></li>
<li><a href="#sec-1-13">1.13. abi for register</a></li>
<li><a href="#sec-1-14">1.14. man 7 signal</a></li>
<li><a href="#sec-1-15">1.15. libnotify</a></li>
<li><a href="#sec-1-16">1.16. pid,ppid,tgid,pgid,sid, and signal</a></li>
<li><a href="#sec-1-17">1.17. SIGSTOP与SIGCONT</a></li>
<li><a href="#sec-1-18">1.18. objcopy 将数据文件保存在目标文件中</a></li>
<li><a href="#sec-1-19">1.19. self-modification code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></a></li>
<li><a href="#sec-1-20">1.20. How main() is executed on Linux</a></li>
<li><a href="#sec-1-21">1.21. 静态库</a></li>
<li><a href="#sec-1-22">1.22. getsockname getpeername</a></li>
<li><a href="#sec-1-23">1.23. raw socket中如何指定源地址</a></li>
<li><a href="#sec-1-24">1.24. SOCK<sub>RAW</sub>, NF<sub>PACKET</sub>, sniffer</a></li>
<li><a href="#sec-1-25">1.25. weak symbol</a></li>
<li><a href="#sec-1-26">1.26. pthread signal,wait,lock,unlock顺序&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></a></li>
<li><a href="#sec-1-27">1.27. How do I get a core dump from a running program?</a></li>
<li><a href="#sec-1-28">1.28. nohup,SIGHUP,daemon关系</a></li>
<li><a href="#sec-1-29">1.29. brk 与 sbrk&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></a></li>
<li><a href="#sec-1-30">1.30. 读取elf信息的几个程序</a></li>
<li><a href="#sec-1-31">1.31. pmap看进程的内存映射</a></li>
<li><a href="#sec-1-32">1.32. 关于linux共享库&#xa0;&#xa0;&#xa0;<span class="tag"><span class="SharedLibrary">SharedLibrary</span></span></a></li>
<li><a href="#sec-1-33">1.33. valgrind</a></li>
<li><a href="#sec-1-34">1.34. distcc</a></li>
<li><a href="#sec-1-35">1.35. switch..case中变量的声明</a></li>
<li><a href="#sec-1-36">1.36. <span class="done DONE">DONE</span> 数组与指针 ( array vs. pointer)</a></li>
<li><a href="#sec-1-37">1.37. c的参数与返回值</a></li>
<li><a href="#sec-1-38">1.38. sync,fsync,fflush的区别</a></li>
<li><a href="#sec-1-39">1.39. Non-blocking synchronization (Lock-free)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></a></li>
<li><a href="#sec-1-40">1.40. <span class="done DONE">DONE</span> gcc <span class="underline"><span class="underline">attribute</span></span> syntax</a></li>
<li><a href="#sec-1-41">1.41. <span class="done DONE">DONE</span> what is weak reference</a></li>
<li><a href="#sec-1-42">1.42. <span class="done DONE">DONE</span> zero copy and Scatter/Gather IO</a></li>
<li><a href="#sec-1-43">1.43. <span class="done DONE">DONE</span> -shared与-fPIC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="SharedLibrary">SharedLibrary</span></span></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Linux Dev</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> IBM ICU and HanziToPinyin in android</h3>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> <span class="done DONE">DONE</span> UTC,GMT,Wall Time and so on</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2011-01-24 Mon 10:20]</span></span>
UTC = Universal Time Coordinate
GMT = Greenwich Mean Time
UTC and GMT are almost identical, but UTC use atomic clock.
Wall Time, unix RTC time, measured from 1970/1/1 0:00:00
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> <span class="done DONE">DONE</span> 程序运行时进行IO重定向</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2011-03-01 Tue 10:59]</span></span>
</li>
</ul>
<pre class="example">
$&gt;gdb
(gdb) attach pid
(gdb) p close(1)
(gdb) p open("/tmp/xxx",1,0755)
(gdb) q
</pre>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> setuid() &amp; SETUID flag</h3>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> <span class="done DONE">DONE</span> uuid</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>State "DONE"       from "DOING"      <span class="timestamp-wrapper"><span class="timestamp">[2011-07-01 Fri 13:44]</span></span>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 同步,互斥,信号量</h3>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> pthread<sub>mutex</sub><sub>lock</sub> 开销</h3>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> 关于ctors,init&#x2026;</h3>
<div class="outline-text-3" id="text-1-8">
<p>
main.cpp:
  A a,b,c;
  B x;
  main() {&#x2026;}
最终生成的./a.out中, 有一个<sub>global</sub><sub>I</sub><sub>a的函数</sub>,它会调用<sub>static</sub><sub>init</sub><sub>global</sub>_&#x2026;函数,这个函数会负责初始化a,b,c,x
另外,在.init section中,会调用_<sub>do</sub><sub>global</sub><sub>ctors</sub><sub>aux</sub>,后者会从.ctors section中读出几个地址,顺序执行. 而.ctors section中
会保存<sub>global</sub><sub>I</sub><sub>a的地址</sub>. 由于所有全局变量的初始化都放在一个<sub>static</sub><sub>init</sub><sub>global</sub>..函数中,所以.ctors section一般只需要保存一个4
字节的数据.
</p>

<p>
另外,_<sub>attribute</sub>_<sub>((contructor))</sub>和_<sub>attribute</sub>_<sub>((section (".ctors")))</sub>可以给.ctors section添加新数据,使程序执行或so载入时可
以执行额外的函数
</p>
</div>


<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> atexit,.init,.fini是什么关系</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
void foo() _<sub>attribute</sub>_<sub>((destructor))</sub>;
T t;
int main() {}
</p>

<p>
执行的结果是: main之前,t的ctor先执行,正常退出时,t的dtor先执行,foo再执行
原因:
_start &#x2014; _<sub>libc</sub><sub>start</sub><sub>main</sub> (main,argc,argv,init,fini ..)
而_<sub>libc</sub><sub>start</sub><sub>main大致为</sub>:
 if (fini)
    atexit (fini);
 if (init)
    (*init) ();
 exit ((*main) (argc, argv, _<sub>environ</sub>));
 即_<sub>libc</sub><sub>start</sub><sub>main会先将</sub>.fini段中的<sub>fini函数用atexit注册</sub>,然后执行.init段中的<sub>init函数</sub>,而<sub>init函数一般是</sub>:调用.ctors段中的ctor,例如前面提到的
 _global<sub>I</sub><sub>a</sub>..函数,这个函数最终会调用各个全局变量的构造函数,然后用atexit注册相应的析构函数
</p>

<p>
因为atexit先注册的后执行,所以exit时析构函数先执行,然后<sub>fini才执行</sub>(注:析构函数并不在.fini中)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> 静态库与.o还是有区别的</h3>
<div class="outline-text-3" id="text-1-9">
<pre class="example">
foo.cpp:
class A {
public:
    A() {cout&lt;&lt;"a"&lt;&lt;endl;}
};
A a,b,c;
main.cpp
main(){}

g++ main.cpp foo.cpp时,a会被初始化
ar cr libfoo.a foo.o
g++ main.cpp -L./ -lfoo时,a不会被初始化
另外,
g++ foo.cpp -shared -fPIC -o libfoo.so
g++ main.cpp -L./ -lfoo时,a会被初始化
</pre>

<p>
究其原因:
情况1. main.cpp foo.cpp中的全局变量被.init段的代码初始化,这是elf针对c++专门设计的
情况2. 由于main.cpp没有引用foo.cpp中的任何东西,导致libfoo.a中的foo.o根本不会被链接到./a.out中
情况3. 在main执行之前,libfoo.so被ld.so动态载入后,由ld.so负责调用.init段的初始化代码初始全局变量
</p>

<p>
另外,静态库链接到程序时,是以.o为单位的,即若main.cpp需要libfoo.a的foo.o的一个函数时,foo.o中的所有东西
都会链接进来.
</p>

<p>
另外,由于一个编译单元中所有全局变量的初始化都是在一个函数中完成的(<i>ctor</i>),所以foo.o被链接后,所有全局变量都会被初
始化,而不是只有main.cpp中用到的变量被初始化
</p>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> ld链接器脚本</h3>
<div class="outline-text-3" id="text-1-10">
<p>
<a href="http://hi.baidu.com/chosin/blog/item/be1a507b02eb54f70bd18712.html">http://hi.baidu.com/chosin/blog/item/be1a507b02eb54f70bd18712.html</a>
ld &#x2013;verbose 显示默认链接器脚本
链接器脚本可以:
</p>
<ul class="org-ul">
<li>确定把各目标文件中的哪些section合并,如 .data : { *(mydata) } 即把所有文件中的mydata section合并成.data section
</li>
<li>确定合并后的section的起始地址,如
. = 0x8049095;
.data : { *(mydata) }
即是使.data section的起始地址为0x8049095;
</li>
<li>设定生成的可执行文件的entry
ENTRY (<sub>start</sub>)
</li>
<li>对符号赋值
.data : {*(.data)}
_edata = .;
即添加了一个<sub>edata符号</sub>,$<sub>edata即</sub>.data段的末尾的地址
1.c:
int a;
lds:
a = 3;
则1.c中a变量的地址会变成3
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> 修改了.so或executable，正在运行的程序会有啥影响？</h3>
<div class="outline-text-3" id="text-1-11">
<p>
executable使用exec一类函数映射到进程地址空间
.so使用mmap映射到进程地址,使用的参数类似于:
    mmap2(NULL, 44424, PROT<sub>READ|PROT</sub><sub>EXEC</sub>, MAP<sub>PRIVATE|MAP</sub><sub>DENYWRITE</sub>, 3, 0)
</p>

<p>
MAP<sub>PRIVATE表示私有映射</sub>,即本进程对文件的修改不会反映到对应的文件上
但外部程序(如MAP<sub>PUBLIC的mmap</sub>,或cp..)对.so文件的修改会反映到本进程,因而可能影响程序的正常运行.
</p>

<p>
mmap的参数MAP<sub>DENYWRITE本来用意就是阻止外部程序对mmap映射的文件的修改的</sub>,但这个
mmap的选项在用户态已经被ignored了(但这个选项在内核还是有效的)&#x2026;.据说是因为会
有dos风险
</p>

<p>
所以.so被mmap后,外部的修改会影响已经mmap的.so,使程序崩溃
有一个patch可以保护.so,其实就是不管有没有MAP<sub>DENYWRITE选项</sub>,内核都对带PROT<sub>EXEC的mmap加DENYWRITE</sub>:
ETXTBUSY on shared libs (patch included)
<a href="http://lkml.indiana.edu/hypermail/linux/kernel/9808.2/1046.html">http://lkml.indiana.edu/hypermail/linux/kernel/9808.2/1046.html</a>
</p>

<p>
与.so不同的是,executable被mmap后,内核可以保证executable文件不能被其他程序修改,其
他程序打开文件时,会返回ETXTBUSY
</p>

<p>
executable被保护,是因为:
executable都是通过sys<sub>execve</sub>-&gt;do<sub>execve</sub>-&gt;open<sub>exec映射到内存的</sub>,open<sub>exec中有一段</sub>:
</p>

<pre class="example">
494 err = deny_write_access(file);
495 if (err) {
496   fput(file);
497   file = ERR_PTR(err);
</pre>
<p>
所以executable可以被denywrite保护
</p>

<p>
综上:
.so在加载后可能被外部程序修改(比如cp),linux没有什么办法保护.so,唯一的办法就是注意不要无意修改.so,例如:
安装新版本的.so时,不要直接cp,而要先rm .so,再cp .so,或使用install
</p>
</div>
</div>
<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> 外部对.so的修改是如何让正在使用.so的程序崩溃的</h3>
<div class="outline-text-3" id="text-1-12">
<ul class="org-ul">
<li>so都是用MAP<sub>PRIVATE进行mmap的</sub>,在Linux的实现中,外部对.so的修改会反映到mmap的
</li>
</ul>
<p>
区域中,不管是MAP<sub>PRIVATE还是MAP</sub><sub>SHARED</sub>,即使MAP<sub>PRIVATE使用了COW使程序只是修改</sub>
原so的附本,外部对.so的修改还是会反映到附本的区域&#x2026;.穷追不舍啊
</p>
<ul class="org-ul">
<li>loader将so载入时,不仅仅要用mmap把so映射进来,还要对映射的区域的一些内容进行修改,根据
so类型的不同(是否使用了-fPIC选项),修改也会有所不同
</li>
</ul>
<p>
外部程序修改了so使正在使用so的程序崩溃的原因是:外部程序的修改直接反映到mmap区域,loader载入so时
对mmap区域的一些修改因此丢失,而这些修改是关键的,因此程序崩溃
</p>

<ul class="org-ul">
<li>loader对mmap区域的修改:
<ul class="org-ul">
<li>so用-fPIC编译时:
so中对全局变量的引用使用GOT表,对自己无法解析的其他函数的调用使用PLT表,这两个表都在.data段中,初始为空
loader将so载入时,会填充GOT表,并将PLT表的所有entry置为loader自己的地址,将so初次调用PLT表的函数时,loader会
负责查找这个函数的真正地址,用它替换掉entry中自己的地址,并调用之,这也是一种lazy evaluation.
</li>
<li>so没用-fPIC编译时:
so中对全局变量的引用和无法解析的函数的调用都是0,load在载入so时,会修改这些值,即会同时修改.data和.text
</li>
</ul>
</li>
</ul>
<p>
因为外部程序修改so时,原来loader对mmap区域的修改都丢失了,导致so中全局变量和函数调用都变成空,出现段错误
</p>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> abi for register</h3>
<div class="outline-text-3" id="text-1-13">
<p>
<code>=========i386 ABI / function calling sequence =========</code>
</p>

<p>
All registers on the Intel386 are global and
thus visible to both a calling and a
called function. Registers %ebp, %ebx, %edi,
%esi, and %esp 'belong' to the calling
function. In other words, a called function
must preserve these registers' values for
its caller. Remaining registers 'belong' to
the called function. If a calling
function wants to preserve such a register
value across a function call, it must
save the value in its local stack frame.
</p>


<p>
Some registers have assigned roles in the standard calling sequence:
</p>

<p>
%esp
The stack pointer holds the limit of the current stack frame, which
is the address of the stack’s bottom-most, valid word. At all
times, the stack pointer should point to a word-aligned area.
</p>

<p>
%ebp
The frame pointer optionally holds a base address for the current G
stack frame. Consequently, a function has registers pointing to
both ends of its frame. Incoming arguments reside in the previous
frame, referenced as positive offsets from %ebp, while local
variables reside in the current frame, referenced as negative
offsets from %ebp. A function must preserve this register’s value
for its caller.
</p>

<p>
%eax
Integral and pointer return values appear in %eax. A function that
returns a struct or union value places the address of the result
in %eax. Otherwise this is a scratch register.
</p>


<p>
%ebx
As described below, this register serves as the global offset table
base register for position-independent code. For absolute code,
%ebx serves as a local register and has no specified role in the
function calling sequence. In either case, a function
must preserve the register value for the caller.
</p>

<p>
%esi and %edi
These local registers have no specified role in the function calling sequence.
A function must preserve their values for the
caller.
</p>

<p>
%ecx and %edx
Scratch registers have no specified role in the standard calling sequence.
Functions do not have to preserve their values for
the caller.
</p>



<p>
%st(0)
Floating-point return values appear on the top of the floatingpoint
register stack; there is no difference in the representation
of single- or double-precision values in floating-point registers.
If the function does not return a floating-point value, then this
register must be empty. This register must be empty before G
entry to a function.
</p>

<p>
%st(1) through %st(7)
Floating-point scratch registers have no specified role in the standard
calling sequence. These registers must be empty before
entry and upon exit from a function.
</p>

<p>
EFLAGS
The flags register contains the system flags, such as the direction
flag and the carry flag. The direction flag must be set to the
‘‘forward’’ (that is, zero) direction before entry and upon exit
from a function. Other user flags have no specified role in the
standard calling sequence and are not preserved.
</p>

<p>
Floating-Point Control Word
The Intel387 control word contains the floating-point flags, such
as the rounding mode and exception masking.
</p>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> man 7 signal</h3>
<div class="outline-text-3" id="text-1-14">
<p>
standard signal
real-time signal
    信号队列
    siginfo<sub>t包含额外的信息</sub>,如信号发送方的uid
可重入系统调用
可靠信号
sigqueue/kill
sigsuspend/pause
</p>
</div>
</div>
<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> libnotify</h3>
</div>
<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> pid,ppid,tgid,pgid,sid, and signal</h3>
<div class="outline-text-3" id="text-1-16">
<ul class="org-ul">
<li>pid 是进程/线程的唯一标识,但getpid并不是返回task<sub>struct的pid字段</sub>,而是返回
task<sub>struct</sub>-&gt;tgid,因为posix规定一个进程创建的多个线程的getpid的结果是一样的,都是那个进程的id
gettid返回真正的pid
</li>
<li>ppid 父进程
线程创建时使用了CLONE<sub>PARENT</sub>,所以各个线程和主线程的的ppid都是主线程的ppid
#&gt;ps -meo cmd,pid,ppid,pgid,tid
./a.out                     23874 23237 23874     -
<ul class="org-ul">
<li>-     -     - 23874
</li>
<li>-     -     - 23875
</li>
</ul>
<p>
而若a.out使用进程来创建子进程,相当于clone没指定CLONE<sub>PARENT</sub>
#&gt;ps -meo cmd,pid,ppid,pgid,tid
./a.out                     23885 23237 23885     -
</p>
<ul class="org-ul">
<li>-     -     - 23885
</li>
</ul>
<p>
./a.out                     23886 23885 23885     -
</p>
<ul class="org-ul">
<li>-     -     - 23886
</li>
</ul>
</li>

<li>tgid是线程组id,getpid返回tgid
</li>
<li>pgid,组id. 子进程继承pgid,shell管道中各个进程有相同的pgid,kill -9 -pgid 可以给所有组id是pgid的进程发SIGKILL,
而kill -9 pid只给pid是pid的进程发SIGKILL.
If pid is less than -1, then sig is sent to every process in the process group whose ID is -pid.
pgid可以使我们同时管理一组进程,比如发信号,另外,shell的作业控制也使用了pgid,比如tcsetpgrp(fd,pgid)使得所有组id为pgid的进程
处于前台(即C-c给这个进程发SIGINT,这些进程的stdin,stdout为fd&#x2026;) 另外, 要将一个进程daemonize通常需要关闭stdin/stdout,setpgid为自已的pid,
setsid为自己的pid,其中setpgid的作用就是让进程脱离父进程的进程组,以免kill -SIG 时误杀daemon进程
</li>
<li>sid,会话id,完全和shell有关的id,一个shell启动的所有进程的sid一样,当shell退出时,shell会向同一个会话id的进程发SIGHUP
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-17" class="outline-3">
<h3 id="sec-1-17"><span class="section-number-3">1.17</span> SIGSTOP与SIGCONT</h3>
<div class="outline-text-3" id="text-1-17">
<p>
kill -SIGSTOP pid 可以将一个进程置于STOP状态,只有收到SIGCONT才能继续执行. 与各
种sleep,mutex,阻塞而置于STOP状态不同的是,因SIGSTOP停止的进程不会因为SIGCONT以
外的其他条件而苏醒
SIGSTOP与SIGKILL一样不能修改handler
</p>
</div>
</div>
<div id="outline-container-sec-1-18" class="outline-3">
<h3 id="sec-1-18"><span class="section-number-3">1.18</span> objcopy 将数据文件保存在目标文件中</h3>
<div class="outline-text-3" id="text-1-18">
<pre class="example">
#&gt; objcopy -I binary  -O elf32-i386 -B i386 source.c sourcefile.o
#&gt; nm -a sourcefile.o|grep source.c
00000179 D _binary_source_c_end
00000179 A _binary_source_c_size
00000000 D _binary_source_c_start

#&gt; cat source.c
#include &lt;stdio.h&gt;
extern char _binary_source_c_start,  _binary_source_c_end;
int main(void) {
    char * start=(char *)&amp;_binary_source_c_start;
    char * end=(char *)&amp;_binary_source_c_end;
    while (start++!=end) {
        printf ("%c",*start);
    }
    return 0;
}


#&gt;gcc source.c sourcefile.o -o ./a.out
#&gt; a.out 显示source.c的内容
</pre>
<p>
ps. c语言中的变量名和汇编语言中的符号的关系:
变量名和汇编符号是对应的,不过直接引用变量名取到的是值,而直接引用汇编符号取到的是地址
</p>
</div>
</div>
<div id="outline-container-sec-1-19" class="outline-3">
<h3 id="sec-1-19"><a id="ewhabz210oe0-sunway-lab.bupt.edu.cn" name="ewhabz210oe0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.19</span> self-modification code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-19">
<p>
Note:mprotect is the key
<a href="http://en.wikipedia.org/wiki/Self-modifying_code">http://en.wikipedia.org/wiki/Self-modifying_code</a>
self-modifying code的作用:
</p>

<p>
The method is frequently used for conditionally invoking test/debugging code
without requiring additional overhead for every input/output cycle and also
in just-in-time (JIT) compilers.
</p>

<p>
能够避免使用 if (flag..) then ..这种语句,因为当flag发生时,代码已经被修改,后面
的执行不需要再判断flag,用来优化和状态相关的循环
</p>

<p>
例如:
</p>
<ul class="org-ul">
<li>c++的多态.实际就是通过修改vtbl将条件直接通过代码的修改体现
</li>
<li>elf对共享库的函数的调用. 调用库函数时通过plt调用,例如foo@plt初始时实际是
loader的代码,第一次执行foo时loader负责把foo@plt修改为真正的foo的位置
</li>
<li>对函数指针的修改也可以看作是更高层次上的self-modifying code
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-20" class="outline-3">
<h3 id="sec-1-20"><span class="section-number-3">1.20</span> How main() is executed on Linux</h3>
<div class="outline-text-3" id="text-1-20">
<p>
Starting
</p>

<p>
The question is simple: how does linux execute my main()?
Through this document, I'll use the following simple C program to illustrate how it works. It's called "simple.c"
</p>

<p>
main()
{
   return(0);
}
</p>


<p>
Build
</p>

<p>
gcc -o simple simple.c
</p>


<p>
What's in the executable?
</p>

<p>
To see what's in the executable, let's use a tool "objdump"
</p>

<p>
objdump -f simple
</p>

<p>
simple:     file format elf32-i386
architecture: i386, flags 0x00000112:
EXEC<sub>P</sub>, HAS<sub>SYMS</sub>, D<sub>PAGED</sub>
start address 0x080482d0
</p>

<p>
The output gives us some critical information about the executable.
 First of all, the file is "ELF32" format. Second of all, the start address is "0x080482d0"
What's ELF?
</p>

<p>
ELF is acronym for Executable and Linking Format. It's one of several object and executable file formats used on Unix systems. For our discussion, the interesting thing about ELF is its header format. Every ELF executable has ELF header, which is the following.
</p>

<p>
typedef struct
{
        unsigned char        e<sub>ident[EI</sub><sub>NIDENT]</sub>;        <i>* Magic number and other info *</i>
        Elf32<sub>Half</sub> e<sub>type</sub>;                        <i>* Object file type *</i>
        Elf32<sub>Half</sub> e<sub>machine</sub>;                <i>* Architecture *</i>
        Elf32<sub>Word</sub> e<sub>version</sub>;                <i>* Object file version *</i>
        Elf32<sub>Addr</sub> e<sub>entry</sub>;                <i>* Entry point virtual address *</i>
        Elf32<sub>Off</sub> e<sub>phoff</sub>;                <i>* Program header table file offset *</i>
        Elf32<sub>Off</sub> e<sub>shoff</sub>;                <i>* Section header table file offset *</i>
        Elf32<sub>Word</sub> e<sub>flags</sub>;                <i>* Processor-specific flags *</i>
        Elf32<sub>Half</sub> e<sub>ehsize</sub>;                <i>* ELF header size in bytes *</i>
        Elf32<sub>Half</sub> e<sub>phentsize</sub>;                <i>* Program header table entry size *</i>
        Elf32<sub>Half</sub> e<sub>phnum</sub>;                <i>* Program header table entry count *</i>
        Elf32<sub>Half</sub> e<sub>shentsize</sub>;                <i>* Section header table entry size *</i>
        Elf32<sub>Half</sub> e<sub>shnum</sub>;                <i>* Section header table entry count *</i>
        Elf32<sub>Half</sub> e<sub>shstrndx</sub>;                <i>* Section header string table index *</i>
} Elf32<sub>Ehdr</sub>;
</p>

<p>
In the above structure, there is "e<sub>entry</sub>" field, which is starting address of an executable.
What's at address "0x080482d0", that is, starting address?
</p>

<p>
For this question, let's disassemble "simple". There are several tools to disassemble an executable. I'll use objdump for this purpose.
</p>

<p>
objdump &#x2013;disassemble simple
</p>

<p>
The output is a little bit long so I'll not paste all the output from objdump. Our intention is see what's at address 0x080482d0. Here is the output.
</p>

<p>
080482d0 &lt;<sub>start</sub>&gt;:
 80482d0:       31 ed                   xor    %ebp,%ebp
 80482d2:       5e                      pop    %esi
 80482d3:       89 e1                   mov    %esp,%ecx
 80482d5:       83 e4 f0                and    $0xfffffff0,%esp
 80482d8:       50                      push   %eax
 80482d9:       54                      push   %esp
 80482da:       52                      push   %edx
 80482db:       68 20 84 04 08          push   $0x8048420
 80482e0:       68 74 82 04 08          push   $0x8048274
 80482e5:       51                      push   %ecx
 80482e6:       56                      push   %esi
 80482e7:       68 d0 83 04 08          push   $0x80483d0
 80482ec:       e8 cb ff ff ff          call   80482bc &lt;<sub>init</sub>+0x48&gt;
 80482f1:       f4                      hlt
 80482f2:       89 f6                   mov    %esi,%esi
</p>

<p>
Looks like some kind of starting routine called "<sub>start</sub>" is at the starting address. What it does is clear a register, push some values into stack and call a function. According to this instruction, the stack frame should look like this.
</p>

<p>
Stack Top        -&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
                0x80483d
</p>
<hr  />
<p>
esi
</p>
<hr  />
<p>
ecx
</p>
<hr  />
<p>
0x8048274
</p>
<hr  />
<p>
0x8048420
</p>
<hr  />
<p>
edx
</p>
<hr  />
<p>
esp
</p>
<hr  />
<p>
eax
</p>
<hr  />


<p>
Now, as you already wonder,we've got a few questions regarding this stack frame.
</p>



<ol class="org-ol">
<li>What are those hex values about?
</li>
<li>What's at address 80482bc, which is called by _start?
</li>
<li>Looks like the assembly instructions doesn't initialize any register with possibly meaningful values. Then who initializes the registers?
</li>
</ol>



<p>
Let's answer these questions one by one.
</p>

<p>
Q1&gt;The hexa values.
</p>

<p>
If you look at disassembled output from objdump carefully, you can answer this question easily.
</p>

<p>
Here is answer.
</p>

<p>
0x80483d0 :        This is the address of our main() function.
</p>

<p>
0x8048274 :         _init function.
</p>

<p>
0x8048420 :        _fini function _init and _fini is initialization/finalization function provided by GCC.
</p>

<p>
Right now, let's not care about these stuffs. And basically, all those hexa values are function pointers.
</p>

<p>
Q2&gt;What's at address 80482bc?
</p>

<p>
Again, let's look for address 80482bc from the disassembly output.
If you look for it, the assembly is
</p>

<p>
80482bc:        ff 25 48 95 04 08            jmp    *0x8049548
</p>


<p>
Here *0x8049548 is a pointer operation.
 It just jumps to an address stored at address 0x8049548.
</p>


<p>
More about ELF and dymanic linking
</p>

<p>
With ELF, we can build an executable linked dynamically with libraries.
Here "linked dynamically" means the actual linking process happens at runtime. Otherwise we'd have to build a huge executable containing all the libraries it calls (a "statically-linked executable). If you issue the command
</p>

<p>
"ldd simple"
</p>

<p>
libc.so.6 =&gt; /lib/i686/libc.so.6 (0x42000000)
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)
</p>

<p>
You can see all the libraries dynamically linked with simple. And all the dynamically linked data and functions have "dynamic relocation entry".
</p>

<p>
The concept is roughly like this.
</p>


<ol class="org-ol">
<li>We don't know actual address of a dynamic symbol at link time. We can know the actual address of the symbol only at runtime.
</li>
<li>So for the dynamic symbol, we reserve a memory location for the actual address.
The memory location will be filled with actual address of the symbol at runtime by loader.
</li>
<li>Our application sees the dynamic symbol indirectly with the momeory location by using kind of pointer operation. In our case, at address 80482bc, there is just a simple jump instruction.
And the jump location is stored at address 0x8049548 by loader during runtime.
We can see all dynamic link entries with objdump command.

<p>
objdump -R simple
</p>

<p>
simple:     file format elf32-i386
</p>

<p>
DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
0804954c R<sub>386</sub><sub>GLOB</sub><sub>DAT</sub>    <span class="underline"><span class="underline">gmon<sub>start</sub></span></span>
08049540 R<sub>386</sub><sub>JUMP</sub><sub>SLOT</sub>   _<sub>register</sub><sub>frame</sub><sub>info</sub>
08049544 R<sub>386</sub><sub>JUMP</sub><sub>SLOT</sub>   _<sub>deregister</sub><sub>frame</sub><sub>info</sub>
08049548 R<sub>386</sub><sub>JUMP</sub><sub>SLOT</sub>   _<sub>libc</sub><sub>start</sub><sub>main</sub>
</p>

<p>
Here address 0x8049548 is called "jump slot", which perfectly makes sense. And according to the table, actually we want to call _<sub>libc</sub><sub>start</sub><sub>main</sub>.
</p>
</li>
</ol>


<p>
What's _<sub>libc</sub><sub>start</sub><sub>main</sub>?
</p>

<p>
Now the ball is on libc's hand. _<sub>libc</sub><sub>start</sub><sub>main</sub> is a function in libc.so.6. If you look for _<sub>libc</sub><sub>start</sub><sub>main</sub> in glibc source code, the prototype looks like this.
</p>

<p>
extern int BP<sub>SYM</sub> (_<sub>libc</sub><sub>start</sub><sub>main</sub>) (int (<b>main) (int, char *</b>, char **),
                int argc,
                char *_<sub>unbounded</sub> *_<sub>unbounded</sub> ubp<sub>av</sub>,
                void (*init) (void),
                void (*fini) (void),
                void (*rtld<sub>fini</sub>) (void),
                void *_<sub>unbounded</sub> stack<sub>end</sub>)
<span class="underline"><span class="underline">attribute</span></span> ((noreturn));
</p>

<p>
And all the assembly instructions do is set up argument stack and call _<sub>libc</sub><sub>start</sub><sub>main</sub>.
What this function does is setup/initialize some data structures/environments and call our main().
Let's look at the stack frame with this function prototype.
</p>

<p>
Stack Top     -&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
                        0x80483d0                               main
</p>
<hr  />
<p>
esi                                            argc
</p>
<hr  />
<p>
ecx                                           argv
</p>
<hr  />
<p>
0x8048274                             _init
</p>
<hr  />
<p>
0x8048420                             _fini
</p>
<hr  />
<p>
edx                                         _rtlf<sub>fini</sub>
</p>
<hr  />
<p>
esp                                         stack<sub>end</sub>
</p>
<hr  />
<p>
eax                                         this is 0
</p>
<hr  />

<p>
According to this stack frame, esi, ecx, edx, esp, eax registers should be filled with appropriate values before _<sub>libc</sub><sub>start</sub><sub>main</sub>() is executed. And clearly this registers are not set by the startup assembly instructions shown before. Then, who sets these registers? Now I guess the only thing left. The kernel.
Now let's go back to our third question.
Q3&gt;What does the kernel do?
</p>

<p>
When we execute a program by entering a name on shell, this is what happens on Linux.
</p>


<ol class="org-ol">
<li>The shell calls the kernel system call "execve" with argc/argv.
</li>
<li>The kernel system call handler gets control and start handling the system call. In kernel code, the handler is "sys<sub>execve</sub>". On x86, the user-mode application passes all required parameters to kernel with the following registers.

<ul class="org-ul">
<li>ebx : pointer to program name string
</li>
<li>ecx : argv array pointer
</li>
<li>edx : environment variable array pointer.
</li>
</ul>
</li>

<li>The generic execve kernel system call handler, which is do<sub>execve</sub>, is called. What it does is set up a data structure and copy some data from user space to kernel space and finally calls search<sub>binary</sub><sub>handler</sub>(). Linux can support more than one executable file format such as a.out and ELF at the same time. For this functionality, there is a data structure "struct linux<sub>binfmt</sub>", which has a function pointer for each binary format loader. And search<sub>binary</sub><sub>handler</sub>() just looks up an appropriate handler and calls it. In our case, load<sub>elf</sub><sub>binary</sub>() is the handler. To explain each detail of the function would be lengthy/boring work. So I'll not do that. If you are interested in it, read a book about it. As a picture tells a thousand words, a thousand lines of source code tells ten thousand words (sometimes). Here is the bottom line of the function. It first sets up kernel data structures for file operation to read the ELF executable image in. Then it sets up a kernel data structure: code size, data segment start, stack segment start, etc. And it allocates user mode pages for this process and copies the argv and environment variables to those allocated page addresses. Finally, argc, the argv pointer, and the envrioronment variable array pointer are pushed to user mode stack by create<sub>elf</sub><sub>tables</sub>(), and start<sub>thread</sub>() starts the process execution rolling.
</li>
</ol>




<p>
When the _start assembly instruction gets control of execution, the stack frame looks like this.
</p>

<p>
Stack Top        -&#x2014;&#x2014;&#x2014;&#x2014;
                            argc
</p>
<hr  />
<p>
argv pointer
</p>
<hr  />
<p>
env pointer
</p>
<hr  />

<p>
And the assembly instructions gets all information from stack by
</p>

<p>
pop %esi                 &lt;&#x2014; get argc
move %esp, %ecx                &lt;&#x2014; get argv
                          actually the argv address is the same as the current
                          stack pointer.
</p>

<p>
And now we are all set to start executing.
What about the other registers?
</p>

<p>
For esp, this is used for stack end in application program. After popping all necessary information, the _start rountine simply adjusts the stack pointer (esp) by turning off lower 4 bits from esp register. This perfectly makes sense since actually, to our main program, that is the end of stack. For edx, which is used for rtld<sub>fini</sub>, a kind of application destructor, the kernel just sets it to 0 with the following macro.
</p>

<p>
#define ELF<sub>PLAT</sub><sub>INIT</sub>(<sub>r</sub>)        do { \
        _r-&gt;ebx = 0; _r-&gt;ecx = 0; _r-&gt;edx = 0; \
        _r-&gt;esi = 0; _r-&gt;edi = 0; _r-&gt;ebp = 0; \
        _r-&gt;eax = 0; \
} while (0)
</p>

<p>
The 0 means we don't use that functionality on x86 linux.
About the assembly instructions
</p>

<p>
Where are all those codes from? It's part of GCC code. You can usually find all the object files for the code at
/usr/lib/gcc-lib/i386-redhat-linux/XXX and
/usr/lib where XXX is gcc version.
File names are crtbegin.o,crtend.o, gcrt1.o.
</p>


<p>
Summing up
</p>

<p>
Here is what happens.
</p>


<ol class="org-ol">
<li>GCC build your program with crtbegin.o/crtend.o/gcrt1.o And the other default libraries are dynamically linked by default. Starting address of the executable is set to that of _start.
</li>
<li>Kernel loads the executable and setup text/data/bss/stack, especially, kernel allocate page(s) for arguments and environment variables and pushes all necessary information on stack.
</li>
<li>Control is pased to _start. _start gets all information from stack setup by kernel, sets up argument stack for _<sub>libc</sub><sub>start</sub><sub>main</sub>, and calls it.
</li>
<li>_<sub>libc</sub><sub>start</sub><sub>main</sub> initializes necessary stuffs, especially C library(such as malloc) and thread environment and calls our main.
</li>
<li>our main is called with main(argv, argv) Actually, here one interesting point is the signature of main. _<sub>libc</sub><sub>start</sub><sub>main</sub> thinks main's signature as main(int, char <b>*, char *</b>) If you are curious, try the following prgram.

<p>
main(int argc, char** argv, char** env)
{
    int i = 0;
    while(env[i] != 0)
    {
       printf("%s\n", env[i++]);
    }
    return(0);
}
</p>
</li>
</ol>


<p>
Conclusion
</p>

<p>
On Linux, our C main() function is executed by the cooperative work of GCC, libc and Linux's binary loader.
</p>

<p>
References
</p>

<p>
objdump                         "man objdump"
</p>

<p>
ELF header                     /usr/include/elf.h
</p>

<p>
_<sub>libc</sub><sub>start</sub><sub>main</sub>          glibc source
                                       ./sysdeps/generic/libc-start.c
</p>

<p>
sys<sub>execve</sub>                     linux kernel source code
                                       arch/i386/kernel/process.c
</p>

<p>
do<sub>execve</sub>                      linux kernel source code
                                       fs/exec.c
</p>

<p>
struct linux<sub>binfmt</sub>       linux kernel source code
                                       include/linux/binfmts.h
</p>

<p>
load<sub>elf</sub><sub>binary</sub>             linux kernel source code
                                       fs/binfmt<sub>elf</sub>.c
</p>

<p>
create<sub>elf</sub><sub>tables</sub>           linux kernel source code
                                       fs/binfmt<sub>elf</sub>.c
</p>

<p>
start<sub>thread</sub>                   linux kernel source code
                                      include/asm/processor.h
</p>
</div>
</div>

<div id="outline-container-sec-1-21" class="outline-3">
<h3 id="sec-1-21"><span class="section-number-3">1.21</span> 静态库</h3>
<div class="outline-text-3" id="text-1-21">
<p>
ar cr libfoo.a 1.o 2.o
</p>
</div>
</div>

<div id="outline-container-sec-1-22" class="outline-3">
<h3 id="sec-1-22"><span class="section-number-3">1.22</span> getsockname getpeername</h3>
</div>
<div id="outline-container-sec-1-23" class="outline-3">
<h3 id="sec-1-23"><span class="section-number-3">1.23</span> raw socket中如何指定源地址</h3>
<div class="outline-text-3" id="text-1-23">
<p>
虽然man raw说明,如果指定源地址为0,则内核会自动加上正确的源地址, 但我在ipv6上试没有成功&#x2026;在raw socket中得到正确的源地址的方法是:
</p>
<pre class="example">
 void probeSrcAddr () {
  int probeFd = socket(AF_INET6, SOCK_DGRAM, 0);
  if (connect (probeFd, (struct sockaddr*)&amp;toAddr, sizeof(toAddr))==-1) {
      perror ("connect");
  }
  struct sockaddr_in6 source;
  bzero (&amp;source,sizeof(struct sockaddr_in6));
  socklen_t sourceLen=sizeof(struct sockaddr_in6);
  if (getsockname(probeFd, (struct sockaddr*)&amp;source, &amp;sourceLen)==-1) {
      perror ("getsockname");
  }
  memcpy (srcAddr,(char *)&amp;source.sin6_addr,16);
}
</pre>

<p>
iputils中的ping6.c ping.c都是用的这种方法
</p>
</div>
</div>
<div id="outline-container-sec-1-24" class="outline-3">
<h3 id="sec-1-24"><span class="section-number-3">1.24</span> SOCK<sub>RAW</sub>, NF<sub>PACKET</sub>, sniffer</h3>
<div class="outline-text-3" id="text-1-24">
<p>
使用raw socket能够:
</p>
<ul class="org-ul">
<li>修改整个Ip包
</li>
<li>自定义四层协议,如ospf
</li>
<li>监听所有的tcp,udp,icmp包,但不能拦截
</li>
</ul>
<p>
int sockfd=socket (PF<sub>INET</sub>,SOCK<sub>RAW</sub>,protocol),根据protocal的不同,有不同的功能:
</p>
<ul class="org-ul">
<li>当protocol为IPPROTOCOL<sub>TCP</sub>,IPPROTO<sub>UDP</sub>,IPPROTO<sub>ICMP时</sub>,这个socket被限定了用来收发tcp/udp/icmp包,即
<ul class="org-ul">
<li>向sockfd写时,Ip包的协议字段自动被重写为tcp/udp/icmp
</li>
<li>从sockfd读时,可以读到所有收到的tcp/udp/icmp包,注意,这个sockfd并没有像SOCK<sub>STREAM一样绑定端口号</sub>,也没有像
SOCK<sub>DGRAM一样sendto后绑定一个随机端口</sub>. SOCK<sub>RAW没有端口号的概念</sub>. 所以 sockfd可以读到所有收到的tcp/udp/icmp包
</li>
</ul>
</li>
<li>当protocol为SOCK<sub>RAW</sub> (0) 的其它数值时,可以用来实现自己的四层协议
<ul class="org-ul">
<li>向sockfd写时,ip包的协议字段自动重写为protocol的值
</li>
<li>从sockfd读时,可以读到ip层收到的所有Protocol为相应的值的ip包
所以本质上这种情况和情况1是一样的,只不过对于tcp/udp/icmp,系统本身已经提供了直接的支持,注:对于某个协议,可以注册多个raw socket,
ip层收到属于这个协议的ip包后,会依次传给每个raw socket处理. 这就是为什么 指定protocol为IPPROTOCOL<sub>TCP后</sub>,我们自己的sockfd可以
读到这个tcp包,而且不影响系统自身对tcp包的处理. 链路层的PF<sub>PACKET</sub>(sniffer)也是这种处理方法,所以sniffer只能监听,而不能拦截
</li>
</ul>
</li>
<li>总结:protocol的值对wirte sockfd的影响主要是:ip头中的协议字段会被自动修改为protocol的值,对read sockfd的影响:ip头为协议字段为protocol的包会被读到
</li>
<li>当protocol为IPPROTOCOL<sub>RAW</sub>(0)时
<ul class="org-ul">
<li>向sockfd写时,ip包完全不会被修改
</li>
<li>系统限制不能从这种sockfd中读,要实现这个功能,需要用 PF<sub>PACKET</sub>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-25" class="outline-3">
<h3 id="sec-1-25"><span class="section-number-3">1.25</span> weak symbol</h3>
<div class="outline-text-3" id="text-1-25">
<p>
<a href="http://www.tortall.net/projects/yasm/manual/html/objfmt-elf-directives.html">http://www.tortall.net/projects/yasm/manual/html/objfmt-elf-directives.html</a>
ref <i>c++ inline function</i> <i>gcc <span class="underline"><span class="underline">attribute</span></span> extension</i>
ELF allows defining certain symbols as “weak”. Weak symbols are similar to
global symbols, except during linking, weak symbols are only chosen after
global and local symbols during symbol resolution. Unlike global symbols,
multiple object files may declare the same weak symbol, and references to a
symbol get resolved against a weak symbol only if no global or local symbols
have the same name.
</p>

<p>
This functionality is primarily useful for libraries that want to provide
common functions but not come into conflict with user programs. For example,
libc has a syscall (function) called “read”. However, to implement a threaded
process using POSIX threads in user-space, libpthread needs to supply a
function also called “read” that provides a blocking interface to the
programmer, but actually does non-blocking calls to the kernel. To allow an
application to be linked to both libc and libpthread (to share common code),
libc needs to have its version of the syscall with a non-weak name like
“<sub>sys</sub><sub>read”</sub> with a weak symbol called “read”. If an application is linked
against libc only, the linker won't find a non-weak symbol for “read”, so it
will use the weak one. If the same application is linked against libc and
libpthread, then the linker will link “read” calls to the symbol in
libpthread, ignoring the weak one in libc, regardless of library link
order. If libc used a non-weak name, which “read” function the program ended
up with might depend on a variety of factors; a weak symbol is a way to tell
the linker that a symbol is less important resolution-wise.
</p>

<p>
The `weak' attribute causes the declaration to be emitted as a weak
  symbol rather than a global.  This is primarily useful in defining
  library functions which can be overridden in user code, though it
  can also be used with non-function declarations.  Weak symbols are
  supported for ELF targets, and also for a.out targets when using
  the GNU assembler and linker.
</p>
</div>
</div>
<div id="outline-container-sec-1-26" class="outline-3">
<h3 id="sec-1-26"><a id="bxibmeh0bge0-sunway-lab.bupt.edu.cn" name="bxibmeh0bge0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.26</span> pthread signal,wait,lock,unlock顺序&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-26">
</div>
</div>
<div id="outline-container-sec-1-27" class="outline-3">
<h3 id="sec-1-27"><span class="section-number-3">1.27</span> How do I get a core dump from a running program?</h3>
<div class="outline-text-3" id="text-1-27">
<ul class="org-ul">
<li>abort()
</li>
<li>SIGABRT
</li>
<li>gcore
</li>
<li>gdb generate-core-file
</li>
</ul>

<p>
If you just want a program to terminate now and dump core, you can use the
SIGABRT signal. This signal can be send from another process using kill. Or it
can be send by the process itself using, kill, raise, or abort. If you want a
core dump without killing the process, things start getting more tricky. You
can create a child process by using the fork system call, and let the child
dump core. The init program actually does this in its signal handlers. From the
outside, the kernel offers no simple way to get a core dump from a process
without killing it. But gdb have a gcore command that will do the hard work. On
Fedora Core you can also call gcore from your shell (in which case it is just a
script that call gdb).
</p>
</div>
</div>

<div id="outline-container-sec-1-28" class="outline-3">
<h3 id="sec-1-28"><span class="section-number-3">1.28</span> nohup,SIGHUP,daemon关系</h3>
<div class="outline-text-3" id="text-1-28">
<ul class="org-ul">
<li>SIGHUP 当终端关闭时，它会向本进程组发送SIGHUP信号,该终端进程组的所有进程都会收到
</li>
<li>nohup foo.sh 可以使foo.sh忽略SIGHUP信号
</li>
<li>daemon
一个进程要成为daemon需要：
后台运行(通过fork)
setsid() ;;退出原来的进程组(一般是终端)，以免接收到发往原进程组的信号(如SIGHUP)
chdir("/")
umask(0)
一般还要关闭各个fd
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-29" class="outline-3">
<h3 id="sec-1-29"><a id="trz9m8l0xfe0-sunway-lab.bupt.edu.cn" name="trz9m8l0xfe0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.29</span> brk 与 sbrk&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-29">
</div>
</div>
<div id="outline-container-sec-1-30" class="outline-3">
<h3 id="sec-1-30"><span class="section-number-3">1.30</span> 读取elf信息的几个程序</h3>
<div class="outline-text-3" id="text-1-30">
<ul class="org-ul">
<li>size
</li>
<li>readelf
</li>
<li>ldd
</li>
<li>objdump
</li>
<li>strings
</li>
<li>nm
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-31" class="outline-3">
<h3 id="sec-1-31"><span class="section-number-3">1.31</span> pmap看进程的内存映射</h3>
<div class="outline-text-3" id="text-1-31">
<p>
或cat /proc/&lt;pid&gt;/maps
</p>
</div>
</div>

<div id="outline-container-sec-1-32" class="outline-3">
<h3 id="sec-1-32"><span class="section-number-3">1.32</span> 关于linux共享库&#xa0;&#xa0;&#xa0;<span class="tag"><span class="SharedLibrary">SharedLibrary</span></span></h3>
<div class="outline-text-3" id="text-1-32">
<ul class="org-ul">
<li>ldconfig,ld.so与ld.so.cache
</li>
<li>/usr/lib
</li>
<li>LD<sub>LIBRARY</sub><sub>PATH</sub>
</li>
<li>LD<sub>DEBUG</sub>
</li>
<li>gcc &#x00ad;L选项
</li>
<li>ld -rpath选项
</li>
</ul>

<p>
ld.so.cache只在运行时起作用
LD<sub>LIBRARY</sub><sub>PATH只在运行时起作用</sub>
\/usr/lib在编译时和运行时都起作用
gcc &#x00ad;L只在编译时起作用.
ld的 -rpath 在运行时起作用,告诉加载器到哪去找so. gcc以前也有这个选项,现在这个选项只在ld中,在gcc中可以这样指定这个rpath选项:
    gcc &#x2026; -Wl,rpath,/home/sunway
</p>

<p>
ld.so的作用:
在程序运行之前载入共享库,库查找的顺序是
</p>
<ol class="org-ol">
<li>LD<sub>LIBRARY</sub><sub>PATH</sub>
</li>
<li>ld.so.cache
</li>
<li>/usr/lib
</li>
</ol>

<p>
ldconfig &#x00ad;v 可以显示更新cache的过程,ldconfig &#x00ad;p可以查看cache的内容
</p>

<p>
综上:
</p>
<ul class="org-ul">
<li>如果要在编译时使用某个库,可以用gcc &#x00ad;L选项,或者把so复制到/usr/lib
</li>
<li>如果要在运行时使用某个库,可以设定LD<sub>LIBRARY</sub><sub>PATH</sub>,或复制到ld.so.conf指定的目录并ldconfig,或复制到/usr/lib,或使用ld的 -rpath 选项
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-33" class="outline-3">
<h3 id="sec-1-33"><span class="section-number-3">1.33</span> valgrind</h3>
</div>
<div id="outline-container-sec-1-34" class="outline-3">
<h3 id="sec-1-34"><span class="section-number-3">1.34</span> distcc</h3>
</div>
<div id="outline-container-sec-1-35" class="outline-3">
<h3 id="sec-1-35"><span class="section-number-3">1.35</span> switch..case中变量的声明</h3>
<div class="outline-text-3" id="text-1-35">
<pre class="example">
switch (b) {
int a=0;
case 1:
   int c=0;
   break;
case 2:
   {
      int d=0;
   }
}
</pre>

<p>
int a是合法的,int c是非法的,int d是合法的
</p>

<p>
因为case 1并不一定被执行,而整个switch都属于一个作用域,编译器如何知道case 1能不能
被执行?如果不能,引用了c的语句(包括整个switch结构)怎么办?编译器从逻辑上禁止了在
case里声明变量.
</p>

<p>
int a是合法的,因为它在所有case之间,肯定会被执行.
</p>

<p>
int d是合法的,因为它属于单独的作用域.
</p>

<p>
这个问题关键一点是:整个switch使用同一个作用域,而每个case不一定被执行.
</p>
</div>
</div>
<div id="outline-container-sec-1-36" class="outline-3">
<h3 id="sec-1-36"><span class="section-number-3">1.36</span> <span class="done DONE">DONE</span> 数组与指针 ( array vs. pointer)</h3>
<div class="outline-text-3" id="text-1-36">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2011-04-08 Fri 15:06]</span></span>
</li>
</ul>
<p>
数组与指针的混淆,最根本的原因是这种语法糖:
</p>
<pre class="example">
char * pointer=array;
</pre>

<p>
本来,做为C/C++中的一种基本类型, int a<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> 和 int x; 并没有明显的区别, a, x都是变量,都有地址和值, 但由于数组的值的结构与指针的相似性,C提供了上面提到的语法糖,即:
要使用数组变量的地址时,不必再加&amp;符号,而可以直接使用数组名字 (访问数组的值时使用a<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>这种语法,所以不会混淆).
</p>

<p>
数组名即地址,所以给a再赋值是违法的,正如 &amp;x 不能再赋值一样.
</p>

<p>
另外,为何数组不能做为函数返回值:
函数返回值有两种方式:
</p>
<ul class="org-ul">
<li>通过寄存器直接返回,如各种基本类型和指针类型
</li>
<li>通过named-return-value返回,如结构体
</li>
</ul>
<p>
或函数可以返回,只能通过第二种情况, 但是, 由于数组大小不定,若 caller 和 callee 的数组长度不同,如何处理?
</p>
</div>
</div>

<div id="outline-container-sec-1-37" class="outline-3">
<h3 id="sec-1-37"><span class="section-number-3">1.37</span> c的参数与返回值</h3>
<div class="outline-text-3" id="text-1-37">
<p>
除了数组,任何类型都可以做为函数的返回值,包括结构等
</p>
<ul class="org-ul">
<li>对于&lt;=32位的返回值,如int,short,float,指针等,直接通过%eax返回
</li>
<li>对于64位的返回值,通常通过两个寄存器返回,如%eax,%edx
</li>
<li>对于更大的结构体,通常在函数调用时把返回值的地址作为第一个参数,函数直接给这个指针赋值
</li>
</ul>

<p>
任何类型都可做为函数的参数,但数组有些例外:数组做为参数时弱化为指针
</p>
</div>
</div>

<div id="outline-container-sec-1-38" class="outline-3">
<h3 id="sec-1-38"><span class="section-number-3">1.38</span> sync,fsync,fflush的区别</h3>
<div class="outline-text-3" id="text-1-38">
<ul class="org-ul">
<li>sync Force changed blocks to disk, update the super block.
</li>
<li>fsync(int fd),和sync作用类似，不过只针对一个fd
</li>
<li>fflush(FILE *) 刷新FILE *的缓存。例如：
</li>
</ul>
<p>
printf("test");
fflush(stdout);
sleep(2);
在sleep前test因为fflush而被显示出来。
缓存（包括全缓存，行缓存）是标准IO库的概念，fflush只对标准IO起作用。
对于write(STDOUT<sub>FILENO</sub>,"test",5),没有缓存的概念，test直接被显示出来。
</p>

<p>
综上：
sync,fsync对应的是OS的磁盘cache,fflush对应的是标准IO库的缓存。标准IO的缓存在磁盘cache之上，当
用fflush()刷新一个流时，可能仍需要用sync可能保证内容被写到磁盘上。
</p>
</div>
</div>

<div id="outline-container-sec-1-39" class="outline-3">
<h3 id="sec-1-39"><a id="n7ga2qc0xfe0-sunway-lab.bupt.edu.cn" name="n7ga2qc0xfe0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.39</span> Non-blocking synchronization (Lock-free)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-39">
<p>
<a href="http://en.wikipedia.org/wiki/Non-blocking_synchronization">http://en.wikipedia.org/wiki/Non-blocking_synchronization</a>
With few exceptions, non-blocking algorithms use atomic read-modify-write
primitives that the hardware must provide, the most notable of which is
compare and swap (CAS). Ultimately, all synchronizing algorithms must use
these;
</p>
</div>
<div id="outline-container-sec-1-39-1" class="outline-4">
<h4 id="sec-1-39-1"><span class="section-number-4">1.39.1</span> Live-lock</h4>
<div class="outline-text-4" id="text-1-39-1">
<p>
<a href="http://en.wikipedia.org/wiki/Livelock#Livelock">http://en.wikipedia.org/wiki/Livelock#Livelock</a>
</p>

<p>
A livelock is similar to a deadlock, except that the states of the
processes involved in the livelock constantly change with regard to one
another, none progressing. <sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> Livelock is a special case of resource
starvation; the general definition only states that a specific process is
not progressing. <sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>

<p>
A real-world example of livelock occurs when two people meet in a narrow
corridor, and each tries to be polite by moving aside to let the other
pass, but they end up swaying from side to side without making any progress
because they both repeatedly move the same way at the same time.  RCU
</p>
</div>
</div>
<div id="outline-container-sec-1-39-2" class="outline-4">
<h4 id="sec-1-39-2"><span class="section-number-4">1.39.2</span> CAS</h4>
<div class="outline-text-4" id="text-1-39-2">
<p>
<a href="http://en.wikipedia.org/wiki/Compare-and-swap">http://en.wikipedia.org/wiki/Compare-and-swap</a>
In computer science, the compare-and-swap CPU instruction ("CAS") (or the
Compare &amp; Exchange - CMPXCHG instruction in the x86 and Itanium
architectures) is a special instruction that atomically compares the contents
of a memory location to a given value and, if they are the same, modifies the
contents of that memory location to a given new value.
</p>

<p>
CAS是所有Lock-free算法(数据结构)的基础
</p>

<p>
一个用c++表示的cas算法如下:
bool CAS(int* addr, int expected, int fresh) {
           if (*addr != expected) return false;
           *addr = fresh;
           return true;
}
实际上cas都是用的CPU支持的单条汇编指令,如CMPXCHG
用CAS实现lock-free算法一般如下实现:
要修改Data时:
Data * p_;
Data * pOld, * pNew = new Data;
do {
           pOld = p_;
           *pNew=*p_;
           //在这里修改 *pNew
           //另:CAS的参数都是指针,因为CAS对应的汇编指令参数是处理内存地址
} while (!CAS(&amp;p_, pOld, pNew));
</p>

<p>
CAS的例子见附件cas.c
注意:当使用-O2编译cas.c时,volatile关键字是必须的,参考<i>volatile</i>
</p>
</div>
</div>
<div id="outline-container-sec-1-39-3" class="outline-4">
<h4 id="sec-1-39-3"><span class="section-number-4">1.39.3</span> Implementations of Lock-free data structures</h4>
<div class="outline-text-4" id="text-1-39-3">
</div><div id="outline-container-sec-1-39-3-1" class="outline-5">
<h5 id="sec-1-39-3-1"><span class="section-number-5">1.39.3.1</span> 由于结构简单或功能受限不需要CAS的Lock-free数据结构</h5>
<div class="outline-text-5" id="text-1-39-3-1">
</div><ol class="org-ol"><li>RCU<br  /><div class="outline-text-6" id="text-1-39-3-1-1">
<p>
<a href="http://en.wikipedia.org/wiki/Read-copy-update">http://en.wikipedia.org/wiki/Read-copy-update</a>
<a href="http://www-128.ibm.com/developerworks/cn/linux/l-rcu/">http://www-128.ibm.com/developerworks/cn/linux/l-rcu/</a>
</p>
</div>
</li>

<li>Circular buffer<br  /><div class="outline-text-6" id="text-1-39-3-1-2">
<p>
<a href="http://en.wikipedia.org/wiki/Circular_buffer">http://en.wikipedia.org/wiki/Circular_buffer</a>
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-39-3-2" class="outline-5">
<h5 id="sec-1-39-3-2"><span class="section-number-5">1.39.3.2</span> Lock-free stack,list,etco</h5>
<div class="outline-text-5" id="text-1-39-3-2">
<p>
见附件 L32<sub>lockfree</sub>.pdf
</p>

<p>
例:lock-free stack的push操作
</p>

<pre class="example">
void push(int t) {
     Node* node = new Node(t);
     do {
         node-&gt;next = head;
     } while (!cas(&amp;head, node-&gt;next, node));
 }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-40" class="outline-3">
<h3 id="sec-1-40"><span class="section-number-3">1.40</span> <span class="done DONE">DONE</span> gcc <span class="underline"><span class="underline">attribute</span></span> syntax</h3>
<div class="outline-text-3" id="text-1-40">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2008-09-21 日 14:08]</span></span>
     <a href="http://www.ohse.de/uwe/articles/gcc-attributes.html">http://www.ohse.de/uwe/articles/gcc-attributes.html</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-41" class="outline-3">
<h3 id="sec-1-41"><span class="section-number-3">1.41</span> <span class="done DONE">DONE</span> what is weak reference</h3>
<div class="outline-text-3" id="text-1-41">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2008-10-13 一 22:34]</span></span>
</li>
</ul>
<p>
<a href="http://mindtrove.info/articles/python-weak-references/">http://mindtrove.info/articles/python-weak-references/</a>
<a href="http://en.wikipedia.org/wiki/Weak_reference">http://en.wikipedia.org/wiki/Weak_reference</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-42" class="outline-3">
<h3 id="sec-1-42"><span class="section-number-3">1.42</span> <span class="done DONE">DONE</span> zero copy and Scatter/Gather IO</h3>
<div class="outline-text-3" id="text-1-42">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2009-01-05 一 14:19]</span></span>
     <a href="http://www.linuxjournal.com/article/6345">http://www.linuxjournal.com/article/6345</a>
     <a href="http://en.wikipedia.org/wiki/Zero-copy">http://en.wikipedia.org/wiki/Zero-copy</a>
     <a href="http://www.ibm.com/developerworks/library/j-zerocopy/index.html">http://www.ibm.com/developerworks/library/j-zerocopy/index.html</a>
</li>
</ul>

<pre class="example">
normal read/write copy
  |
  +-&gt;mmap
      |
      +-&gt;sendfile syscall
	   |
	   +--&gt;sendfile together with Gather/Scatter IO (Zero copy)
</pre>
</div>
</div>
<div id="outline-container-sec-1-43" class="outline-3">
<h3 id="sec-1-43"><span class="section-number-3">1.43</span> <span class="done DONE">DONE</span> -shared与-fPIC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="SharedLibrary">SharedLibrary</span></span></h3>
<div class="outline-text-3" id="text-1-43">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2008-12-29 一 09:10]</span></span>
</li>
</ul>
<p>
<a href="http://bottomupcs.sourceforge.net/csbu/x3809.htm">http://bottomupcs.sourceforge.net/csbu/x3809.htm</a>
</p>

<p>
对于共享库,代码本身就是位置无关的,但共享库中用到的全局数据是位置相关的,由于共享库的地址在运行时才能确定,所以共享库中要访问的全局数据的地址
都是不确定的,全局数据的地址在运行时由loader确定. 比如:
</p>
<pre class="example">
lib.c:
  extern int a;
  void fun() {
      a=1;
  }
  main.c:
  int a;
  main () {
      fun();
  }
</pre>

<p>
gcc -shared -fPIC (or not)  lib.c -o lib.so
lib.so中全局数据a的地址编译时不确定,运行后a的地址由Loader添加到lib.so在内存的映像中
至于loader如何将a的地址添加到lib.so中,可能有两种方法:
</p>
<ol class="org-ol">
<li>a在a.out的.bss中,地址为A,loader载入lib.so后负责把lib.so .text段中所有对a的引用的地址改写成A
这种方法需要改写lib.so的 .text段,导致lib.so的.text段无法被共享
编译时不指定-fPIC时就是这种情况
</li>
<li>lib.so中对a的引用的地址是"GOT基址+偏移量"的形式,GOT即global offset table,loader载入lib.so后会把
a的地址加入GOT表中对应于a的地方. 显示这种方法不需要修改lib.so的.text段,所以.text段可能被共享
编译时指定-fPIC时是这种情况
每个共享库都有一个GOT表
GOT基址通常保存在一个寄存器中,如ebx,每次函数共享库的函数时,都会重设ebx使其指向相应的so的GOT基址
lib.so每次访问a时真要先查GOT表才能确定a的地址,即多一次内存访问
GOT紧跟在lib.so的.text之后,lib.so的.text编译时确定,所以lib.so被载入内存后,GOT基址也是确定的
如图:
lib.so载入前:
</li>
</ol>
<pre class="example">
+---------+
| lib.so  |
| .text段 o-----a的地址为(GOT+OFFSET(a)),例如 OFFSET(a)=1
+---------+
| GOT     |
+---------+
| .data   |
| .bss    |
+---------+
</pre>
<p>
lib.so载入后:
</p>
<pre class="example">
               /----lib.so被载入到0xXXX
+---------+----
| lib.so  |
| .text段 |----a的地址没变,还是(GOT+OFFSET(a)),但GOT的地址已经确定为len of .text+0xXXX
+---------+	      而且GOT的第OFFSET(a)个表项的值已经被loader改写为a的地址
| GOT     |
+---------+
| .data   |
| .bss    |
+---------+
</pre>

<p>
-fPIC指将库编译成"位置无关代码",这里的"位置"并不是指lib.so被映射到线性地址空间的位置,而是指lib.so中引用的
全局数据的地址是位置无关的
</p>

<p>
另外,
main.c:
extern int a;
main() {
    a=1;
}
lib.c:
int a;
如果main中要使用lib.so中定义的全局变量,链接后a还是在a.out的.bss段,而不是在lib.so的.bss段,否则如果另一个lib2.so
要使用a还要去lib.so中找lib.so?
</p>

<p>
另:strace的结果也显示出不加-fPIC时lib.so无法被共享
没加-fPIC时,strace ./a.out的部分结果:
</p>
<pre class="example">
...
open("./libmy.so", O_RDONLY)            = 3
read(3,"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\3\0\0004\0\0\0\300"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=48065, ...}) = 0
getcwd("/home/sunway"..., 128)          = 13
mmap2(NULL, 44424, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) =0xb7efe000
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mmap2(0xb7eff000, 40960, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0xb7eff000
..
mprotect(0xb7efe000, 4096, PROT_READ|PROT_WRITE) = 0
mprotect(0xb7efe000, 4096, PROT_READ|PROT_EXEC) = 0
..
</pre>

<p>
加了-fPIC:
</p>
<pre class="example">
..
open("./libmy.so", O_RDONLY)            = 3
read(3,"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\3\0\0004\0\0\0\240"..., 512)= 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=48072, ...}) = 0
getcwd("/home/sunway"..., 128)          = 13
mmap2(NULL, 44392, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) =0xb7f22000
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mmap2(0xb7f23000, 40960, PROT_READ|PROT_WRITE,
MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0xb7f23000
..
mprotect(0xb7f07000, 4096, PROT_READ)   = 0
munmap(0xb7f0d000, 84037)               = 0
..
</pre>

<p>
唯一的区别就是末尾的mprotect(0xb7efe000, 4096, PROT<sub>READ|PROT</sub><sub>WRITE</sub>) = 0.
没加-fPIC时,libmy.so的.text用MAP<sub>PRIVATE参数map进来</sub>,但后面又用mprotect设为可写..
然后dynamic loader会修改这个内存区(以便确定全局数据的真实地址),然后就copy on
write了
</p>

<p>
静态库-&gt;硬盘占的多,内存占的多,加载快,运行快
不加fPIC的动态库-&gt;硬盘占的不多,内存占的多,加载慢,运行快
加了fPIC的动态库-&gt;硬盘占的不多,内存占的不多,加载慢,运行慢
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-01-22 Wed 16:04</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.2 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
