<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ActivityManagerService</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="ActivityManagerService"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-05-20T21:16+0800"/>
<meta name="author" content="sunway"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>    <link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">ActivityManagerService</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 ActivityManagerService</a>
<ul>
<li><a href="#sec-1-1">1.1 Intent and IntentFilter</a></li>
<li><a href="#sec-1-2">1.2 Activity</a></li>
<li><a href="#sec-1-3">1.3 Service</a></li>
<li><a href="#sec-1-4">1.4 Broadcast</a></li>
<li><a href="#sec-1-5">1.5 ProcessRecord</a></li>
<li><a href="#sec-1-6">1.6 AppDeathRecipient</a></li>
<li><a href="#ActivityThread">1.7 ActivityThread</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> ActivityManagerService</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Intent and IntentFilter &nbsp;&nbsp;&nbsp;<span class="tag"><span class="intent">intent</span></span></h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Intent.setPackage(pkg)</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>     only match Activities in this `pkg`
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Intent.component</h4>
<div class="outline-text-4" id="text-1-1-2">

</div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> IntentFilter.priority</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>     candidates ARE sorted by IntentFilter.priority when resolving intent, but
</p><ul>
<li>when resolve activity, ResolveActivity will reorder candidates in alphabet order&hellip;.so nothing
</li>
<li>when resolve service, only candidate with the highest priority are selected
</li>
<li>when resolve broadcast, candidate priority are considered for OrderedBroadcast
</li>
</ul>

</div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> IntentFilter matching</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>      <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2011-01-19 Wed 16:07</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2011-01-19 Wed 16:07</span></span>
</li>
</ul>

<p>     how startActivity(or startService, sendBrocast) use Intent.{category,action,data} to find the correct intent receiver?
     AMS use <a href="#PackageManager">PackageManager</a> to resolve intent to get intent's component
</p>
</div>

<div id="outline-container-1-1-4-1" class="outline-5">
<h5 id="sec-1-1-4-1"><span class="section-number-5">1.1.4.1</span> startActivity</h5>
<div class="outline-text-5" id="text-1-1-4-1">




<pre class="src src-text">AMS:startActivity()
    AMS:startActivityMayWait()
        PM:resolveIntent()
            PM:queryIntentActivities()
                // explicit intent
                if (intent.getCommponent())
                    return the component
                // implicit intent
                if (intent.getPackage()==null)
                    PM:mActivities.queryIntent()
                        foreach activity:
                          buildResolveList()
                             foreach IntentFilter:
                               filter.match()
                               make sure filter has DEFAULT category
                else
                    PM:mActivities.queryIntentForPackage()
                      foreach activity:
                          buildResolveList()
                             foreach IntentFilter:
                               filter.match()
                               make sure filter has DEFAULT category
            PM:chooseBestActivity()
                // candidates here are sorted by [[IntentFilter.priority][IntentFilter.priority]]
                if (candidates.size() == 1)
                    return it;
                if we have saved a preference for a preferred activity
                    return findPreferredActivity()
                else
                    return ResolverActivity // although candidates are sorted by IntentFilter.priority, ResolverActivity will
                                            // reorder them in alphabet order...weired~~
        Intent.setComponent()
        AMS:startActivityLocked()
          checkComponentPermission();
        ...
</pre>

<ul>
<li>PM:resolveIntent
        when PackagetManager need to detect whether there are activities in a certain package matching the Intent, it will resolve the inent as:
<ol>
<li>PM calls queryIntentForPackage, which will take a List of activities in the package as param
</li>
<li>for every activity, call buildResolveList, which take a List of all IntentFilters of the activity as param
</li>
<li>for every IntentFilter, call filter.match( intent.getAction(), resolvedType, scheme, intent.getData(), categories, TAG); to determine whether
           the IntentFilter matches the Intent, if so, add the activity to the candidates.  Note that categories is a list of Category in the intent, since
           intent can call addCategory() to add serveral categories requirement
</li>
<li>filter.match() will check
<ol>
<li>action
              intent action mustn't be null and must be in the IntentFilter's actions list
</li>
<li>data
              data must be a subset of IntentFilter's data list
</li>
<li>category
              if intent's categories is a subset of filter's categories, or intent's category is null , return ok
</li>
</ol>

</li>
<li>if filter.match() match, there is still one last check:
<ol>
<li>if the defaultOnly flag is set (in fact, startActivity will always set the flag when resolveIntent), and the candidate intentFilter also
              has the DEFAULT category, returns ok.  this is just as if the Intent has added the DEFAULT category by default. BUT, since it is restriction
              imposed by AMS, we can't override the behaviour by calling intent.removeCategory(DEFAULT)
</li>
<li>note: the DEFAULT<sub>ONLY</sub> flag and intentFilter's default category is mainly used by startActivity, use PM standalone (e.g. resolveActivity) doesn't
              impose this restriction.
</li>
</ol>

</li>
</ol>

</li>
<li>PM:chooseBestActivity
        after PM:resolveIntent, a list of candidates are available, PM will choose the best activity
<ol>
<li>if there is only ONE candidates, return it
</li>
<li>else, call findPreferredActivity to find if we have saved a preference for a preferred activity for this intent
</li>
<li>else, return a ResolverActivity, which will show a ResolverActivity and promp user for the prefered activity. ResolverActivity will sort candidates
           in alphabet order, regardless of IntentFilter's priority.
</li>
</ol>

</li>
<li>At last, if PM returns a ResolverActivity, AMS will actually start ResolverActivity, ResolverActivity's onClick will call startActivity() to start the real user prefered activity.
</li>
</ul>


</div>

</div>

<div id="outline-container-1-1-4-2" class="outline-5">
<h5 id="sec-1-1-4-2"><span class="section-number-5">1.1.4.2</span> startService</h5>
<div class="outline-text-5" id="text-1-1-4-2">




<pre class="example">AMS:startServiceLocked()
  AMS:retrieveServiceLocked()
      if ret=mServicesByIntent.get(intent)
          return ret; //      * All currently running services indexed by the Intent used to start them.
      else
          PM:resolveService()  // just like resolveActivity
              PM:queryIntentServices()
                  if intent.getComponent()
                      use it;
                  else
                      PM:queryIntent() // return a list of candidates, note that the list is sorted according to [[IntentFilter.priority][IntentFilter.priority]]
              if candidates&gt;1      // more than ONE candidate
                  use candidate.get(0)  // pick the first one. because the candidates are sorted according
                                           // to IntentFilter.priority, so the candidate with the highest priority is selected.
      checkComponentPermission()
</pre>


</div>

</div>

<div id="outline-container-1-1-4-3" class="outline-5">
<h5 id="sec-1-1-4-3"><span class="section-number-5">1.1.4.3</span> sendBroadcast</h5>
<div class="outline-text-5" id="text-1-1-4-3">

<p>just as startService, priority are considered, and a list of all candidates are return to support OrderedBroadcast
</p></div>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Activity &nbsp;&nbsp;&nbsp;<span class="tag"><span class="activity">activity</span></span></h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> AMS side</h4>
<div class="outline-text-4" id="text-1-2-1">


</div>

<div id="outline-container-1-2-1-1" class="outline-5">
<h5 id="sec-1-2-1-1"><span class="section-number-5">1.2.1.1</span> finishedActivityLocked</h5>
<div class="outline-text-5" id="text-1-2-1-1">

<p>      finishCurrentActivity eventually will not stop and destroy activity at once, it will pose it in an array, when idle, it will call activityIdle to purge the activities.
      When is idle? There are 2 scen:
</p><ol>
<li>thread.scheduleResumeActivity will pose one 'Idler' in the msg queue after onResume is finished. Idler will invoke AMS.activityIdle
         2)AMS is smart enough to pose on one delayed IDLE<sub>TIMEOUT</sub><sub>MSG</sub> to the handler in case there is no Idler since onResume hangs. The delayed timeout is 10s.

<p>
         That is, onStop and onDestroy may be delayed for 10s after another activity's onResume is called.
         11/23/10 11:40 am
         finishActivityLocked
         startPausing
</p>
<p>
         &hellip;
</p>
<p>
         activityPaused
         finishCurrentActivity &ndash;&gt; mark the activity for destroy
         resumeTopActivity
         &hellip;
         activity resumed &ndash;&gt; pose idler timer to destroy activity marked befored
</p>
<p>
         11/17/10 6:46 pm
         assume that when A is finished and B will be resumed: first, A is paused, then B is resumed, and A is stopped and destroyed at last
</p></li>
</ol>



<p>
         11/17/10 6:37 pm
         To prevent if activity.onPause doesn't return in a period of time(500ms), AMS will call sendMessageDelayed() in startPausingLocked() to send itself one PAUSE<sub>TIMEOUT</sub> msg to force itself call activityPaused().
</p>
<p>         
         That is, although activity.onPause() may block, AMS is assured to resume       next activity in 500ms.
</p>

<ol>
<li>activity.finish() will call AMS's finishActivity() through
         AIDL, providing activity's IBinder as parameter so that AMS
         can recognize the corresponding HistoryRecord in AMS.

</li>
<li>AMS calls
         finishActivityLocked()
         startPausingLocked()
         thread.schedulePauseActivity()

</li>
<li>thread.schedulePauseActivity() will call activity.onPause(),
         then notify AMS that activity is paused through
         AMS.activityPaused()

</li>
<li>activityPaused()
         completePauseActivity()
         mark activity for stop when idle
         resumeTopActivity()
</li>
</ol>


</div>

</div>

<div id="outline-container-1-2-1-2" class="outline-5">
<h5 id="sec-1-2-1-2"><span class="section-number-5">1.2.1.2</span> attachApplication</h5>
<div class="outline-text-5" id="text-1-2-1-2">


<p>
attachApplication is the 3rd step to start a new
activity. (1. startPausing, 2. activityPaused.)
</p>
<p>
When one new activityThread is created, after calling onCreate,
activityThread will invoke AMS.attachApplication to notify AMS that
process is OK, then AMS can call realStartActivity to launch the
activity.
</p>
</div>

</div>

<div id="outline-container-1-2-1-3" class="outline-5">
<h5 id="sec-1-2-1-3"><span class="section-number-5">1.2.1.3</span> activityPaused</h5>
<div class="outline-text-5" id="text-1-2-1-3">


<p>
activityPaused is called by ActivityThread to notity AMS that the
mResumed activity is paused(or onPause is timeout)
</p>
<p>
after that, if prev should be finished (when finish activity), it will
call finishCurrentActivity to finish prev activity. Then
resumeTopActivity will be called again to really resume another
activity.
</p>
</div>

</div>

<div id="outline-container-1-2-1-4" class="outline-5">
<h5 id="sec-1-2-1-4"><span class="section-number-5">1.2.1.4</span> startActivityLocked</h5>
<div class="outline-text-5" id="text-1-2-1-4">


<p>
11/22/10 2:08 pm
AMS.startActivityLocked() is the very begining  entry to start activity.
</p>
<p>
Stack trace:
AMS side:
</p>


<pre class="example">startActivity
  startActivityUnchecked
     moveTaskToFront
        finishTaskMoved
            resumeTopActivity
</pre>


<p>
when resumeTopActivity, it will firstly call startPausing to pause mResumedActivity A.
</p>
<p>
after A's onPause return, ActivityThread will notify AMS through AMS.ActivityPaused, which will then call resumeTopActivity again to resume  activity.
</p>
<p>
When invoked for the 2nd time, it will try call r.app.thread.scheduleResumeActivity to resume our activity,  then return. but before calling onResume, AMS
will firstly invoke mWindowManager.setAppVisibility(next, true) if the activity is invisible, which will call onRestart and onStart before onResume.
</p>
<p>
If exception occurs, it means the activity is already finished, or it's process is not started at all, it will call
</p>


<pre class="example">startSpecificActivityLocked,
  realStartActivityLocked
    thread.scheduleLaunchActivity

or
startSpecificActivityLocked,
  startProcessLocked
</pre>


<p>
for the 2nd scenero, when activityThread is started in
startProcessLocked, it will call AMS.attachApplication to notify AMS
that the process is ready, attachApplication will then call
realStartActivity again to real kaunch the activity.
</p>
</div>

</div>

<div id="outline-container-1-2-1-5" class="outline-5">
<h5 id="sec-1-2-1-5"><span class="section-number-5">1.2.1.5</span> resumeTopActivityLocked</h5>
<div class="outline-text-5" id="text-1-2-1-5">


<p>
11/22/10 6:38 pm
resumeTopActivity will firstly call startPausing to pause the mResumedActivity, then return directory.
</p>
<p>
When mResumedActivity is paused or timeout (500ms), AMS.activityPaused will be called, which will invoke resumeTopActivity again to finally resume(or launch) the activity.
</p>
</div>

</div>

<div id="outline-container-1-2-1-6" class="outline-5">
<h5 id="sec-1-2-1-6"><span class="section-number-5">1.2.1.6</span> Timeout</h5>
<div class="outline-text-5" id="text-1-2-1-6">

<ul>
<li id="sec-1-2-1-6-1">Pause timeout<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-1-6-2">Idle timeout<br/>
       11/23/10 3:49 pm
       idle timeout is the timeout to stop and destroy activity A after activity B is resumed.
       in the normal case, B's scheduleResumeActivity will pose an Idler after onResume to ensure that A will be finish via activityIdle.
       Howerer, if B's onResume hangs, a delay IDLE<sub>TIMEOUT</sub><sub>MSG</sub> is a must for AMS to make sure A will be finished in 10s.

</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-1-7" class="outline-5">
<h5 id="sec-1-2-1-7"><span class="section-number-5">1.2.1.7</span> HistoryRecord</h5>
<div class="outline-text-5" id="text-1-2-1-7">

<p>      HistoryRecord is used in two ways:
</p><ul>
<li>it is the shadow structure of `Activity` in AMS
</li>
<li>it is used as a IBinder token by AMS, e.g. when AMS want to resume activity, it will send the activity's corresponding HistoryRecord as a token to
        ActivityThread, so that ActivityThread knows which activity to resume.
<ul>
<li>r.app.thread
</li>
<li>r.resultRecord
</li>
<li>r.sourceRecord
</li>
<li>r.intent
</li>
</ul>

</li>
</ul>

<ul>
<li id="sec-1-2-1-7-1">AMS.mHistory stores all the HistoryRecord of AMS.<br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-1-8" class="outline-5">
<h5 id="sec-1-2-1-8"><span class="section-number-5">1.2.1.8</span> startPausingLocked</h5>
<div class="outline-text-5" id="text-1-2-1-8">

<p>11/22/10 6:43 pm
startPausing is called in resumeTopActivity to pause the mResumed activity before resume or launch the target activity
</p></div>

</div>

<div id="outline-container-1-2-1-9" class="outline-5">
<h5 id="sec-1-2-1-9"><span class="section-number-5">1.2.1.9</span> startSpecificActivity</h5>
<div class="outline-text-5" id="text-1-2-1-9">

<p>11/23/10 1:06 pm
it is called when resumeTopActivity (2nd time when prev is paused) to start (instead of resume) target activity.
</p>
<p>
It may call realStartActivity to start the activity or call startProcess to start a new process.
</p><ul>
<li id="sec-1-2-1-9-1">startProcess<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-1-9-2">realStartActiviry<br/>
11/23/10 1:10 pm
real start an activity instead of resume or start a new process.

<p>
This is called in 2 scen:
</p><ol>
<li>startSpecificActivity in resumeTopActivity
</li>
<li>attachApplication, since when attachApplication, the process
   definitly exist and activity is surely not started
   yet. resumeTopActivity is redunctant, calling realStartActivity is
   enough.
</li>
</ol>

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> ActivityThread side</h4>
<div class="outline-text-4" id="text-1-2-2">


</div>

<div id="outline-container-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1"><span class="section-number-5">1.2.2.1</span> ActivityRecord</h5>
<div class="outline-text-5" id="text-1-2-2-1">


<p>
ActivityRecord will save the real Activity instance and some other
info.  It corresponds to AMS::HistoryRecord. ActivityRecord use one
Map&lt;IBinder,ActivityRecord&gt; to save process's all activities.
</p>
<p>
Evey ActivityThread.scheduleXxx () takes an 'Token' (an IBinder) as
para so that ActivityThread can get the corres ActivityRecord from the
map.
</p>
</div>

</div>

<div id="outline-container-1-2-2-2" class="outline-5">
<h5 id="sec-1-2-2-2"><span class="section-number-5">1.2.2.2</span> IApplicationThread</h5>
<div class="outline-text-5" id="text-1-2-2-2">

<ul>
<li id="sec-1-2-2-2-1">schedulePausingActivity<br/>
schedulePausingActivity will firstly call activity.onPaused, and wait for
return, then it will notify AMS through AMS.activityPaused that the
activity is paused.
</li>
</ul>
<ul>
<li id="sec-1-2-2-2-2">scheduleResumeActivity<br/>
it will call onResume, when onResume returns, it will add one Idler to
AMS's queue, to make sure AMS will be norified when queue is idle to stop
and destroy pending need-to-finish act ivies
</li>
</ul>
<ul>
<li id="sec-1-2-2-2-3">scheduleLaunchActivity<br/>
when called by AMS.realStartActivity, scheduleLaunchActivity will
sequencially call onCreate, onStart,
onRestoreInstanceState,onPostCreate,onResume.
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> Activity side</h4>
<div class="outline-text-4" id="text-1-2-3">

<ul>
<li>onStop, onRestart is only related to activity visibility. they
       are invoked by mWindowManager.setAppVisibility() due to
       visibility change.
</li>
<li>onStart may be called due to visibility change or life cycle
       change.
</li>
<li>onPause, onDestroy, onResume is the core concept related to
       activity life cycle, they are called only when life cycle is
       changed.
</li>
</ul>


</div>

<div id="outline-container-1-2-3-1" class="outline-5">
<h5 id="sec-1-2-3-1"><span class="section-number-5">1.2.3.1</span> finish</h5>
<div class="outline-text-5" id="text-1-2-3-1">

</div>

</div>

<div id="outline-container-1-2-3-2" class="outline-5">
<h5 id="sec-1-2-3-2"><span class="section-number-5">1.2.3.2</span> onPause</h5>
<div class="outline-text-5" id="text-1-2-3-2">

<p>      only when starting another <b>Activity</b>, will the former activity's  onPause be called;
      that is, Dialog, PopupWindow will not trigger activity's onPause
</p></div>

</div>

<div id="outline-container-1-2-3-3" class="outline-5">
<h5 id="sec-1-2-3-3"><span class="section-number-5">1.2.3.3</span> onStop</h5>
<div class="outline-text-5" id="text-1-2-3-3">

<p>      may only be called after onPause
      if the paused activity is totally invisible to the user, onStop will be called
      that is, if the resumed activity is opaque, the paused activity's onStop would not be called
</p>
<p>
      resumeTopActivity will call mWindowManager.setAppVisibility(prev, false); // cause prev.onStop be called
      to stop prev activity
</p>
</div>

</div>

<div id="outline-container-1-2-3-4" class="outline-5">
<h5 id="sec-1-2-3-4"><span class="section-number-5">1.2.3.4</span> onDestroy</h5>
<div class="outline-text-5" id="text-1-2-3-4">

</div>

</div>

<div id="outline-container-1-2-3-5" class="outline-5">
<h5 id="sec-1-2-3-5"><span class="section-number-5">1.2.3.5</span> onResume</h5>
<div class="outline-text-5" id="text-1-2-3-5">

</div>

</div>

<div id="outline-container-1-2-3-6" class="outline-5">
<h5 id="sec-1-2-3-6"><span class="section-number-5">1.2.3.6</span> onRestart</h5>
<div class="outline-text-5" id="text-1-2-3-6">

<p>      resumeTopActivity will cal  mWindowManager.setAppVisibility(next, true);  // cause next.onRestart and next.onStart be called
      to call onRestart and onStart
</p></div>

</div>

<div id="outline-container-1-2-3-7" class="outline-5">
<h5 id="sec-1-2-3-7"><span class="section-number-5">1.2.3.7</span> onStart</h5>
<div class="outline-text-5" id="text-1-2-3-7">

</div>

</div>

<div id="outline-container-1-2-3-8" class="outline-5">
<h5 id="sec-1-2-3-8"><span class="section-number-5">1.2.3.8</span> onCreate</h5>
<div class="outline-text-5" id="text-1-2-3-8">

</div>
</div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> Task stack</h4>
<div class="outline-text-4" id="text-1-2-4">

</div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> NativeActivity</h4>
<div class="outline-text-4" id="text-1-2-5">

</div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> Activity Result</h4>
<div class="outline-text-4" id="text-1-2-6">


</div>

</div>

<div id="outline-container-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> PENDING Launcher</h4>
<div class="outline-text-4" id="text-1-2-7">

<p>     see also <a href="#sec-1-2-8-3">Launcher &amp; Task</a>
</p></div>

</div>

<div id="outline-container-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> Task</h4>
<div class="outline-text-4" id="text-1-2-8">


</div>

<div id="outline-container-1-2-8-1" class="outline-5">
<h5 id="sec-1-2-8-1"><span class="section-number-5">1.2.8.1</span> why relaunch an activity A from launcher will bring the task to foreground</h5>
<div class="outline-text-5" id="text-1-2-8-1">

<p>       note that: startActivity from launcher will always use Intent flags of NEW<sub>TASK</sub>
</p>



<pre class="example">startActivityUnchecked()
  if NEW_TASK &amp;&amp; ((MULTIPLE_TASK not set)||...): // see MULTIPLE_TASK flag later, true
    taskTop = findTaskLocked(intent, r.info)
      // findTaskLocked will return the top activity in any existing task matching the given intent
      // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
      // How taskAffinity is null? if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null

    if (taskTop != null): // there is already an existing task for the activity A, true
      if (r.realActivity.equals(taskTop.task.realActivity)): // activity A is the same as the matching task's root activity, true
        if FLAG_ACTIVITY_SINGLE_TOP is set:
          deliverNewIntentLocked(taskTop, r.intent);  // onNewIntent is called
          resumeTopActivityLocked(null);
            mWindowManager.setAppVisibility(prev, false); // cause onStop be called
            mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called
          return START_DELIVERED_TO_TOP;
        else if r.intent.filterEquals(taskTop.task.intent):  // if activity A's calling intent is equal with the intent used to start
                                                             // the task's root activity, intent equality will consider intent action,category,
                                                             // data,type,component..., but *excluding any intent extra*, true
          resumeTopActivity()
            if resumedActivity == topRunningActivity:        // need not resume, in this case, resumedActivity is launcher, while topRunningActivity
                                                             // is Activity A, false
              return;
            else:
              pause resumeActivity and resume topRunningActivity  // true
              mWindowManager.setAppVisibility(prev, false); // cause onStop be called
              mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called

          return START_TASK_TO_FRONT;                        // move the task to foreground
  else: // if NEW_TASK
    if (top.realActivity.equals(r.realActivity)):
      if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
        or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
        or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
        resumeTopActivityLocked(null);
        deliverNewIntentLocked(top, r.intent);
        return START_DELIVERED_TO_TOP;
    create or start the activity                           // false

</pre>


<p>
      To summarize:
      when relaunching an activity from launcher, because the intent used to relaunch the activity is the same as the former task's root activity's intent
      (both are MAIN &amp; LAUNCHER..), AMS will try to resume the activity instead of relaunching it.
      startActivity with <b>NEW_TASK</b> and the <b>same</b> intent as the task's intent will bring the task to foreground (through resumeTopActivity) instead of
      launching it. this behavior is similar with that the task's top activity has the SINGLE_TOP launchMode.
</p>
<p>
      Note about MULTIPLE_TASK intent flag:
      Used in conjunction with FLAG_ACTIVITY_NEW<sub>TASK</sub> to disable the behavior of bringing an existing task to the foreground.  When set,
      a new task is always started to host the Activity for the Intent, regardless of whether there is already an existing task running
      the same thing.
</p>
</div>

</div>

<div id="outline-container-1-2-8-2" class="outline-5">
<h5 id="sec-1-2-8-2"><span class="section-number-5">1.2.8.2</span> startActivityUnchecked &amp; affinity, launchMode, intentFlags</h5>
<div class="outline-text-5" id="text-1-2-8-2">

<p><b>FLAG_ACTIVITY_NEW_TASK</b> is defininitly the most important property related to android task management.
</p><ul>
<li id="sec-1-2-8-2-1">source code comment<br/>



<pre class="example">  1         private final int startActivityUncheckedLocked(HistoryRecord r,
  2              HistoryRecord sourceRecord, Uri[] grantedUriPermissions,
  3              int grantedMode, boolean onlyIfNeeded, boolean doResume) {
  4          Slog.e("sunway","flag");
  5          final Intent intent = r.intent;
  6          final int callingUid = r.launchedFromUid;
  7          int launchFlags = intent.getFlags();
  8
  9          // We'll invoke onUserLeaving before onPause only if the launching
 10          // activity did not explicitly state that this is an automated launch.
 11          mUserLeaving = (launchFlags&amp;Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
 12          if (DEBUG_USER_LEAVING) Slog.v(TAG,
 13                  "startActivity() =&gt; mUserLeaving=" + mUserLeaving);
 14
 15          // If the caller has asked not to resume at this point, we make note
 16          // of this in the record so that we can skip it when trying to find
 17          // the top running activity.
 18          if (!doResume) {
 19              r.delayedResume = true;
 20          }
 21
 22          HistoryRecord notTop = (launchFlags&amp;Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP)
 23                  != 0 ? r : null;
 24
 25          // If the onlyIfNeeded flag is set, then we can do this if the activity
 26          // being launched is the same as the one making the call...  or, as
 27          // a special case, if we do not know the caller then we count the
 28          // current top activity as the caller.
 29          if (onlyIfNeeded) {
 30              HistoryRecord checkedCaller = sourceRecord;
 31              if (checkedCaller == null) {
 32                  checkedCaller = topRunningNonDelayedActivityLocked(notTop);
 33              }
 34              if (!checkedCaller.realActivity.equals(r.realActivity)) {
 35                  // Caller is not the same as launcher, so always needed.
 36                  onlyIfNeeded = false;
 37              }
 38          }
 39
 40          if (grantedUriPermissions != null &amp;&amp; callingUid &gt; 0) {
 41              for (int i=0; i&lt;grantedUriPermissions.length; i++) {
 42                  grantUriPermissionLocked(callingUid, r.packageName,
 43                          grantedUriPermissions[i], grantedMode, r);
 44              }
 45          }
 46
 47          grantUriPermissionFromIntentLocked(callingUid, r.packageName,
 48                  intent, r);
 49
 50          if (sourceRecord == null) {
 51              // This activity is not being started from another...  in this
 52              // case we -always- start a new task.
 53              if ((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
 54                  Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "
 55                        + intent);
 56                  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
 57              }
 58          } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
 59              // The original activity who is starting us is running as a single
 60              // instance...  this new activity it is starting must go on its
 61              // own task.
 62              launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
 63          } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
 64                  || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
 65              // The activity being started is a single instance...  it always
 66              // gets launched into its own task.
 67              launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
 68          }
 69
 70          if (r.resultTo != null &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
 71              // For whatever reason this activity is being launched into a new
 72              // task...  yet the caller has requested a result back.  Well, that
 73              // is pretty messed up, so instead immediately send back a cancel
 74              // and let the new task continue launched as normal without a
 75              // dependency on its originator.
 76              Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");
 77              sendActivityResultLocked(-1,
 78                      r.resultTo, r.resultWho, r.requestCode,
 79                  Activity.RESULT_CANCELED, null);
 80              r.resultTo = null;
 81          }
 82
 83          boolean addingToTask = false;
 84          if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp;
 85                  (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
 86                  || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
 87                  || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
 88              // If bring to front is requested, and no result is requested, and
 89              // we can find a task that was started with this same
 90              // component, then instead of launching bring that one to the front.
 91              if (r.resultTo == null) {
 92                  // See if there is a task to bring to the front.  If this is
 93                  // a SINGLE_INSTANCE activity, there can be one and only one
 94                  // instance of it in the history, and it is always in its own
 95                  // unique task, so we do a special search.
 96
 97                  // sunway:
 98                  // 对于launchMode不为SINGLE_INSTANCE的情况, taskTop是根
 99                  // 据affinity(或activity component)查找到的已存在的task的top activity; 对于
100                  // SINGLE_INSTANCE的情况, taskTop为该single activity
101                  // Q: 系统如何在NEW_TASK时查找是否已经存在一个`密切`的task?
102
103                  HistoryRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE
104                          ? findTaskLocked(intent, r.info)
105                          : findActivityLocked(intent, r.info);
106
107                  // sunway:
108                  // 对于NEW_TASK, 已经找到一个已经存在的TASK或single instance
109                  // activity
110
111                  if (taskTop != null) {
112                      if (taskTop.task.intent == null) {
113                          // This task was started because of movement of
114                          // the activity based on affinity...  now that we
115                          // are actually launching it, we can assign the
116                          // base intent.
117                          taskTop.task.setIntent(intent, r.info);
118                      }
119                      // If the target task is not in the front, then we need
120                      // to bring it to the front...  except...  well, with
121                      // SINGLE_TASK_LAUNCH it's not entirely clear.  We'd like
122                      // to have the same behavior as if a new instance was
123                      // being started, which means not bringing it to the front
124                      // if the caller is not itself in the front.
125
126
127                      HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
128
129                      // sunway:
130                      // our task or single_instance activity is in background,
131                      // move it to front
132
133                      if (curTop.task != taskTop.task) {
134                          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
135                          boolean callerAtFront = sourceRecord == null
136                                  || curTop.task == sourceRecord.task;
137
138                          // sunway:
139                          // 如果: 1. new task 2. task在后台 3. caller在前台 (或
140                          // sourceRecord==null),则将task移到前台, 所以, 一个后台的
141                          // task里的一个thread无法通过 new_task &amp;
142                          // activity.startActivity将task移动到前台
143
144                          if (callerAtFront) {
145                              // We really do want to push this one into the
146                              // user's face, right now.
147                              moveTaskToFrontLocked(taskTop.task, r);
148                          }
149                      }
150                      // If the caller has requested that the target task be
151                      // reset, then do so.
152                      if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
153                          // sunway:
154                          // reset task ... take a deep breath;
155                          taskTop = resetTaskIfNeededLocked(taskTop, r);
156                      }
157                      if (onlyIfNeeded) {
158                          // We don't need to start a new activity, and
159                          // the client said not to do anything if that
160                          // is the case, so this is it!  And for paranoia, make
161                          // sure we have correctly resumed the top activity.
162                          if (doResume) {
163                              resumeTopActivityLocked(null);
164                          }
165                          return START_RETURN_INTENT_TO_CALLER;
166                      }
167
168                      if ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
169                              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
170                              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
171                          // In this situation we want to remove all activities
172                          // from the task up to the one being started.  In most
173                          // cases this means we are resetting the task to its
174                          // initial state.
175
176                          // sunway:
177                          // 在大多数情况下, task或single instance activity
178                          // 在此之前已经被移动到前台,performClearTaskLocked只会
179                          // finish该task中位于r之上的activity, 除非...移动到前台
180                          // 时失败(例如callerAtFront为假,这时会有意想不到的效
181                          // 果)
182
183                          // sunway:
184                          // performClearTaskLocked会finish位于r,top之间的所有
185                          // activity,一般情况下不会finish `基准`activity (对于
186                          // CLEAR_TOP,即是r,对于SINGLE_TASK,SINGLE_INSTANCE,即是
187                          // task的root activity, 除非...基准activity是MULTIPLE
188                          // launch mode且其SINGLE_TOP为假
189
190                          // 总结: 对于一般的startActivity(不包含
191                          // RESET_TASK_IF_NEEDED intent flag), CLEAR_TOP是可以
192                          // finish某些activity的机会,如果想让一个activity在每次
193                          // startActivity时finish掉之前的并create新的且只有一个实
194                          // 例 (例如某些通知功能的activity),可以:
195                          // 1. 使用NEW_TASK和CLEAR_TOP
196                          // 2. launchMode为MULTIPLE,且SINGLE_TOP为假
197                          // 3. 为防止CLEAR_TOP误杀同task的其他activity, 可以设其
198                          // affinity为其他唯一值或者直接使用空串, 确保task中只有
199                          // 它一个activity (类似于singleInstance)
200
201                          // Q: 看起来start SINGLE_TASK 的 root activity 也会导致
202                          // performClearTask .... 并perforClearTask并不
203                          // 能保证developer中声称的SINGLE_TASK的属性:SINGLE_TASK必
204                          // 须是task的root activity; 实际上这段代码的效果是: 设
205                          // A,B的affinity相同, A启动B,其中B是
206                          // SINGLE_TASK,则结果是A,B; B再启动A,结果A,B,A; A再启动
207                          // B, 结果是A,B, 和CLEAR_TOP有啥区别?
208                          // 若想达到文档中声称的SINGLE_TASK效果,必须保证B一开始就
209                          // 是task的root activity.....那只能给它设一个唯一的
210                          // affinity(或affinity为null)才行
211                          // Q: 为什么会有这个问题?
212                          // A: 相比之下,SINGLE_INSTANCE的行为是正常的,根本原因是
213                          // 因为前面对taskTop的查找: 对于SINGLE_INSTANCE, 是从整
214                          // 个mHistory去找唯一的一个activity实例. 而对于
215                          // SINGLE_TASK, 则是从上到下根据affinity找\emph{第一个}
216                          // 匹配的task, 考虑这种情况:
217                          // 有A,B,C,D四个activity, 使用相同的affinity, 其中的A是
218                          // SINGLE_TASK, 设当前有两个task, 'A,C,D'和'B'. 然后另外
219                          // 某处startActivity(B), 假设系统找到第一个匹配的
220                          // task是'A,C,D'... 是否要为B生成一个new task?
221                          // 所以根本原因是task的管理还是过于简单, \emph{task的查找方法
222                          // 无法满足SINGLE_TASK语义}.
223                          // 做为workaround,可以通过确保SINGLE_TASK的activity为唯
224                          // 一的affinity来弥补task查找方法的不足.
225
226
227                          HistoryRecord top = performClearTaskLocked(
228                                  taskTop.task.taskId, r, launchFlags, true);
229
230                          // sunway:
231                          // 若top不为null, 说明CLEAR_TOP真的只是 `clear top`, 则需
232                          // 要调用top的onNewIntent
233
234
235                          if (top != null) {
236                              if (top.frontOfTask) {
237                                  // Activity aliases may mean we use different
238                                  // intents for the top activity, so make sure
239                                  // the task now has the identity of the new
240                                  // intent.
241                                  top.task.setIntent(r.intent, r.info);
242                              }
243                              logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
244                              deliverNewIntentLocked(top, r.intent);
245                          } else {
246                              // sunway:
247                              // 若top为null,说明CLEAR_TOP把`基准`activity也clear掉
248                              // 了...这种情况的发生只有一种可能:`基准`activity是
249                              // MULTIPLE &amp; SINGLE_TOP, `基准`activity被clear掉后,
250                              // 需要通过addingToTask标记通知后续代码:该activity需
251                              // 要重新添加一个新的实例到task中, addingToTask的意思
252                              // 是:addNewInstanceToTask
253
254                              // A special case: we need to
255                              // start the activity because it is not currently
256                              // running, and the caller has asked to clear the
257                              // current task to have this activity at the top.
258                              addingToTask = true;
259                              // Now pretend like this activity is being started
260                              // by the top of its task, so it is put in the
261                              // right place.
262                              sourceRecord = taskTop;
263                          }
264                      } else if (r.realActivity.equals(taskTop.task.realActivity)) {
265                          // sunway:
266                          // 我们想要start的是task的root activity, 若使用的intent
267                          // 也是相同的, 系统认为我们只是想moveTaskToFront, 所以不
268                          // 生新create一个activity,则只是resume这个task的top
269                          // activity.
270                          // 实际上,这段代码反映的是launcher的行为: laucher每次点
271                          // 击桌面图标时,对同一个图标,使用的intent是一样的,且要启
272                          // 动的activity也必然是task的root activity
273                          // 通过模拟launcher的这种行为,我们也可以只是将某个task移
274                          // 动到前台,而不做其他任何事
275
276
277
278                          // In this case the top activity on the task is the
279                          // same as the one being launched, so we take that
280                          // as a request to bring the task to the foreground.
281                          // If the top activity in the task is the root
282                          // activity, deliver this new intent to it if it
283                          // desires.
284                          if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
285                                  &amp;&amp; taskTop.realActivity.equals(r.realActivity)) {
286                              logStartActivity(EventLogTags.AM_NEW_INTENT, r, taskTop.task);
287                              if (taskTop.frontOfTask) {
288                                  taskTop.task.setIntent(r.intent, r.info);
289                              }
290                              deliverNewIntentLocked(taskTop, r.intent);
291                          } else if (!r.intent.filterEquals(taskTop.task.intent)) {
292                              // In this case we are launching the root activity
293                              // of the task, but with a different intent.  We
294                              // should start a new instance on top.
295                              addingToTask = true;
296                              sourceRecord = taskTop;
297                          }
298                      } else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
299                          // sunway:
300                          // 这里基本上是NEW_TASK所判断的最后一个条件了: 若
301                          // RESET_TASK_IF_NEED设置, 则addingToTask为false,阻止了
302                          // 后续的处理. 效果和前面提到的launcher行为类似,但要启动
303                          // 的activity不必是root activity.
304                          // 一般情况下,只有launcher会使用这个标志
305
306
307                          // In this case an activity is being launched in to an
308                          // existing task, without resetting that task.  This
309                          // is typically the situation of launching an activity
310                          // from a notification or shortcut.  We want to place
311                          // the new activity on top of the current task.
312                          addingToTask = true;
313                          sourceRecord = taskTop;
314                      } else if (!taskTop.task.rootWasReset) {
315                          // In this case we are launching in to an existing task
316                          // that has not yet been started from its front door.
317                          // The current task has been brought to the front.
318                          // Ideally, we'd probably like to place this new task
319                          // at the bottom of its stack, but that's a little hard
320                          // to do with the current organization of the code so
321                          // for now we'll just drop it.
322                          taskTop.task.setIntent(r.intent, r.info);
323                      }
324                      if (!addingToTask) {
325                          // We didn't do anything...  but it was needed (a.k.a., client
326                          // don't use that intent!)  And for paranoia, make
327                          // sure we have correctly resumed the top activity.
328                          if (doResume) {
329                              resumeTopActivityLocked(null);
330                          }
331                          return START_TASK_TO_FRONT;
332                      }
333                  }
334              }
335          }
336
337          // sunway:
338          // finally we are here....
339          // 在三种情况下代码会走到这里:
340          // case 1. NEW_TASK为真, 但taskTop为null...说明现在系统里找不到一个已经存在的
341          // `密切`的task, 真的需要`new`一个task了
342          // case 2. NEW_TASK==true, taskTop!=null, 但addingToTask为真, 即需要在taskTop
343          // 上 new activity instance
344          // case 3. 根本没有指定NEW_TASK标志,新的activity使用当前的task (使用当前的
345          // task并不意味着要直接new activity instance, 因为SINGLE_TOP,
346          // CLEAR_TOP...还要考虑)
347          //
348          //
349          //
350          //String uri = r.intent.toURI();
351          //Intent intent2 = new Intent(uri);
352          //Slog.i(TAG, "Given intent: " + r.intent);
353          //Slog.i(TAG, "URI is: " + uri);
354          //Slog.i(TAG, "To intent: " + intent2);
355          if (r.packageName != null) {
356              // If the activity being launched is the same as the one currently
357              // at the top, then we need to check if it should only be launched
358              // once.
359              HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
360              if (top != null &amp;&amp; r.resultTo == null) {
361                  if (top.realActivity.equals(r.realActivity)) {
362                      if (top.app != null &amp;&amp; top.app.thread != null) {
363                          // sunway:
364                          // case 2,3;
365                          // SINGLE_TOP并非NEW_TASK的专利
366                          // A,B,C (c single top)
367                          if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
368                              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
369                              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
370                              logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);
371                              // For paranoia, make sure we have correctly
372                              // resumed the top activity.
373                              if (doResume) {
374                                  resumeTopActivityLocked(null);
375                              }
376                              if (onlyIfNeeded) {
377                                  // We don't need to start a new activity, and
378                                  // the client said not to do anything if that
379                                  // is the case, so this is it!
380                                  return START_RETURN_INTENT_TO_CALLER;
381                              }
382                              deliverNewIntentLocked(top, r.intent);
383                              return START_DELIVERED_TO_TOP;
384                          }
385                      }
386                  }
387              }
388
389          } else {
390              if (r.resultTo != null) {
391                  sendActivityResultLocked(-1,
392                          r.resultTo, r.resultWho, r.requestCode,
393                      Activity.RESULT_CANCELED, null);
394              }
395              return START_CLASS_NOT_FOUND;
396          }
397
398          boolean newTask = false;
399
400          // Should this be considered a new task?
401          if (r.resultTo == null &amp;&amp; !addingToTask
402                  &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
403              // sunway:
404              // case 1, 新建一个task, NEW_TASK
405
406              // todo: should do better management of integers.
407              mCurTask++;
408              if (mCurTask &lt;= 0) {
409                  mCurTask = 1;
410              }
411              r.task = new TaskRecord(mCurTask, r.info, intent,
412                      (r.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
413              if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
414                      + " in new task " + r.task);
415              newTask = true;
416              addRecentTaskLocked(r.task);
417
418          } else if (sourceRecord != null) {
419              if (!addingToTask &amp;&amp;
420                      (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
421                  // sunway
422                  // case 3;
423                  // CLEAR_TOP并非NEW_TASK的专利
424                  // 由于这里没有经过NEW_TASK的 moveToFront, 导致CLEAR_TOP更容易伤
425                  // 到其他task的activity
426
427                  // In this case, we are adding the activity to an existing
428                  // task, but the caller has asked to clear that task if the
429                  // activity is already running.
430
431                  HistoryRecord top = performClearTaskLocked(
432                          sourceRecord.task.taskId, r, launchFlags, true);
433                  if (top != null) {
434                      logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
435                      deliverNewIntentLocked(top, r.intent);
436                      // For paranoia, make sure we have correctly
437                      // resumed the top activity.
438                      if (doResume) {
439                          resumeTopActivityLocked(null);
440                      }
441                      return START_DELIVERED_TO_TOP;
442                  }
443              } else if (!addingToTask &amp;&amp;
444                      (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
445                  // sunway:
446
447                  // case 3;
448                  // REORDER_TO_FRONT是非NEW_TASK的专利
449                  // 若当前task的stack为A,B,C; C调用startActivity(B),则执行后的结
450                  // 果为A,C,B;
451                  // 即B会被reorder to front
452                  //
453                  // 到目前为止可以导致onNewIntent的标志:
454                  // 1. SINGLE_INSTANCE, SINGLE_TASK
455                  // 2. MULTIPLE &amp; SINGLE_TOP
456                  // 3. REORDER_TO_FRONT
457
458
459                  // In this case, we are launching an activity in our own task
460                  // that may already be running somewhere in the history, and
461                  // we want to shuffle it to the front of the stack if so.
462                  int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
463                  if (where &gt;= 0) {
464                      HistoryRecord top = moveActivityToFrontLocked(where);
465                      logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
466                      deliverNewIntentLocked(top, r.intent);
467                      if (doResume) {
468                          resumeTopActivityLocked(null);
469                      }
470                      return START_DELIVERED_TO_TOP;
471                  }
472              }
473              // An existing activity is starting this new activity, so we want
474              // to keep the new one in the same task as the one that is starting
475              // it.
476              r.task = sourceRecord.task;
477              if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
478                      + " in existing task " + r.task);
479
480          } else {
481              // This not being started from an existing activity, and not part
482              // of a new task...  just put it in the top task, though these days
483              // this case should never happen.
484              final int N = mHistory.size();
485              HistoryRecord prev =
486                  N &gt; 0 ? (HistoryRecord)mHistory.get(N-1) : null;
487              r.task = prev != null
488                  ? prev.task
489                  : new TaskRecord(mCurTask, r.info, intent,
490                          (r.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
491              if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
492                      + " in new guessed " + r.task);
493          }
494          if (newTask) {
495              EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.task.taskId);
496          }
497          logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);
498
499          // sunway:
500          //
501          // 经过九九八十一难,到这里才真正调用onCreate;回想前面的种种, 有些
502          // activity被kill掉了, 有些被移动到前台并被resume了, 能收到onNewIntent调
503          // 用都算不错了; 能真正因为startActivity导致onCreate被调用的有多少?
504
505          startActivityLocked(r, newTask, doResume);
506          return START_SUCCESS;
507      }
508
509
510
511
512  private HistoryRecord findTaskLocked(Intent intent, ActivityInfo info) {
513          ComponentName cls = intent.getComponent();
514          if (info.targetActivity != null) {
515              cls = new ComponentName(info.packageName, info.targetActivity);
516          }
517
518          TaskRecord cp = null;
519
520          final int N = mHistory.size();
521          for (int i=(N-1); i&gt;=0; i--) {
522              HistoryRecord r = (HistoryRecord)mHistory.get(i);
523              if (!r.finishing &amp;&amp; r.task != cp
524                      &amp;&amp; r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
525
526                  // sunway:
527                  // launchMode!=SINGLE_INSTANCE这个条件可用避免这种情况:
528                  // 当前mHistory对于同一个affinity有多个task (只有一种可能:一个为正常的task,
529                  // 其他的均为SINGLE_INSTANCE); 通过这个条件判断,可以避免findTask
530                  // 时找到SINGLE_INSTANCE的task (这种task即使找到也不可能往上添加
531                  // 其他activity, 结果还是要新建一个task, 但实际上该
532                  // SINGLE_INSTANCE下面明明有一个可用的`正常`task...最后会导致task越
533                  // 来越多)
534
535                  cp = r.task;
536                  //Slog.i(TAG, "Comparing existing cls=" + r.task.intent.getComponent().flattenToShortString()
537                  //        + "/aff=" + r.task.affinity + " to new cls="
538                  //        + intent.getComponent().flattenToShortString() + "/aff=" + taskAffinity);
539                  if (r.task.affinity != null) {
540                      if (r.task.affinity.equals(info.taskAffinity)) {
541                          //Slog.i(TAG, "Found matching affinity!");
542                          return r;
543                      }
544                  } else if (r.task.intent != null
545                          &amp;&amp; r.task.intent.getComponent().equals(cls)) {
546                      //Slog.i(TAG, "Found matching class!");
547                      //dump();
548                      //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
549                      return r;
550                  } else if (r.task.affinityIntent != null
551                          &amp;&amp; r.task.affinityIntent.getComponent().equals(cls)) {
552                      //Slog.i(TAG, "Found matching class!");
553                      //dump();
554                      //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
555                      return r;
556                  }
557              }
558          }
559
560          return null;
561      }
562
563
564      private final HistoryRecord resetTaskIfNeededLocked(HistoryRecord taskTop,
565              HistoryRecord newActivity) {
566          // sunway:
567          // resetTaskIfNeeded, 是RESET_TASK_IF_NEED intent flag导致的调用
568          // launcher在启动activity时会使用NEW_TASK &amp; RESET_TASK_IF_NEED 标志
569          // 所以该标志和launch有关, 实际上, activity的四个属性:
570          // 1. CLEAR_TASK_ON_LAUNCH
571          // 2. FINISH_ON_TASK_LAUNCH
572          // 3. ALLOW_TASK_REPARENTING
573          // 4. ALWAYS_RETAIN_TASK_STATE
574          // 都只是和这个标志有关
575          // 另外, CLEAR_WHEN_TASK_RESET intent flag 也只和这个标志有关.
576          // Q: RESET_TASK是干什么?
577          // Q: IF_NEEDED是什么意思?
578
579          boolean forceReset = (newActivity.info.flags
580                  &amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
581
582          // sunway:
583          // ACTIVITY_INACTIVE_RESET_TIME 为 30 分钟
584          // 当task.getInactiveDuration &gt; 30 min时, 表示该task需要被forceReset了, 这也
585          // 许就是IF_NEEDED的要表达的意思(之一)?
586
587
588          if (taskTop.task.getInactiveDuration() &gt; ACTIVITY_INACTIVE_RESET_TIME) {
589              if ((newActivity.info.flags
590                      &amp;ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
591                  // sunway:
592                  // 若root activity设置了这个属性,可以避免空闲30分钟后整个task被
593                  // reset (reset case 1)
594                  // 但对case 2,3 无效
595                  forceReset = true;
596              }
597          }
598
599          // sunway:
600          // 所谓 reset task, 是指要从当前task中找出哪些activity需要被reset
601          // (finish), 主要分为三种情况:
602          // case 1. 整个task的所有activity被需要被reset
603          // case 2. 某个或某些activity需要被reset
604          // case 3. 还要考虑更复杂的ALLOW_TASK_REPARENTING属性
605
606          final TaskRecord task = taskTop.task;
607
608          // We are going to move through the history list so that we can look
609          // at each activity 'target' with 'below' either the interesting
610          // activity immediately below it in the stack or null.
611          HistoryRecord target = null;
612          int targetI = 0;
613          int taskTopI = -1;
614          int replyChainEnd = -1;
615          int lastReparentPos = -1;
616
617          // sunway:
618          // 遍历mHistory的所有activity, top --&gt; bottom
619
620          for (int i=mHistory.size()-1; i&gt;=-1; i--) {
621              HistoryRecord below = i &gt;= 0 ? (HistoryRecord)mHistory.get(i) : null;
622
623              if (below != null &amp;&amp; below.finishing) {
624                  continue;
625              }
626              if (target == null) {
627                  target = below;
628                  targetI = i;
629                  // If we were in the middle of a reply chain before this
630                  // task, it doesn't appear like the root of the chain wants
631                  // anything interesting, so drop it.
632                  replyChainEnd = -1;
633                  continue;
634              }
635
636              final int flags = target.info.flags;
637
638              // sunway:
639              // 当前activity需要被finish on task launch?
640              // IF_NEEDED (之二)?
641
642              final boolean finishOnTaskLaunch =
643                  (flags&amp;ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
644              final boolean allowTaskReparenting =
645                  (flags&amp;ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
646
647              if (target.task == task) {
648                  // sunway:
649                  // 我们只能reset要reset的task, 其他的task不能碰
650
651                  // We are inside of the task being reset...  we'll either
652                  // finish this activity, push it out for another task,
653                  // or leave it as-is.  We only do this
654                  // for activities that are not the root of the task (since
655                  // if we finish the root, we may no longer have the task!).
656                  if (taskTopI &lt; 0) {
657                      taskTopI = targetI;
658                  }
659                  if (below != null &amp;&amp; below.task == task) {
660                      final boolean clearWhenTaskReset =
661                              (target.intent.getFlags()
662                                      &amp;Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
663                      if (!finishOnTaskLaunch &amp;&amp; !clearWhenTaskReset &amp;&amp; target.resultTo != null) {
664                          // If this activity is sending a reply to a previous
665                          // activity, we can't do anything with it now until
666                          // we reach the start of the reply chain.
667                          // XXX note that we are assuming the result is always
668                          // to the previous activity, which is almost always
669                          // the case but we really shouldn't count on.
670                          if (replyChainEnd &lt; 0) {
671                              replyChainEnd = targetI;
672                          }
673                      } else if (!finishOnTaskLaunch &amp;&amp; !clearWhenTaskReset &amp;&amp; allowTaskReparenting
674                              &amp;&amp; target.taskAffinity != null
675                              &amp;&amp; !target.taskAffinity.equals(task.affinity)) {
676
677                          // sunway:
678                          // 若当前处理的activity是从别的地方`收养`的
679                          // (allowTaskReparenting为真,且它的affinity和要reset的
680                          // task的affinity不同), 而且它不想死,那么放了它(从哪来的
681                          // 回哪去,或者自立门户)
682                          //
683                          //
684                          // If this activity has an affinity for another
685                          // task, then we need to move it out of here.  We will
686                          // move it as far out of the way as possible, to the
687                          // bottom of the activity stack.  This also keeps it
688                          // correctly ordered with any activities we previously
689                          // moved.
690                          HistoryRecord p = (HistoryRecord)mHistory.get(0);
691                          if (target.taskAffinity != null
692                                  &amp;&amp; target.taskAffinity.equals(p.task.affinity)) {
693                              // If the activity currently at the bottom has the
694                              // same task affinity as the one we are moving,
695                              // then merge it into the same task.
696                              target.task = p.task;
697                              if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
698                                      + " out to bottom task " + p.task);
699                          } else {
700                              mCurTask++;
701                              if (mCurTask &lt;= 0) {
702                                  mCurTask = 1;
703                              }
704                              target.task = new TaskRecord(mCurTask, target.info, null,
705                                      (target.info.flags&amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
706                              target.task.affinityIntent = target.intent;
707                              if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
708                                      + " out to new task " + target.task);
709                          }
710                          mWindowManager.setAppGroupId(target, task.taskId);
711                          if (replyChainEnd &lt; 0) {
712                              replyChainEnd = targetI;
713                          }
714                          int dstPos = 0;
715                          for (int srcPos=targetI; srcPos&lt;=replyChainEnd; srcPos++) {
716                              p = (HistoryRecord)mHistory.get(srcPos);
717                              if (p.finishing) {
718                                  continue;
719                              }
720                              if (DEBUG_TASKS) Slog.v(TAG, "Pushing next activity " + p
721                                      + " out to target's task " + target.task);
722                              task.numActivities--;
723                              p.task = target.task;
724                              target.task.numActivities++;
725                              mHistory.remove(srcPos);
726                              mHistory.add(dstPos, p);
727                              mWindowManager.moveAppToken(dstPos, p);
728                              mWindowManager.setAppGroupId(p, p.task.taskId);
729                              dstPos++;
730                              if (VALIDATE_TOKENS) {
731                                  mWindowManager.validateAppTokens(mHistory);
732                              }
733                              i++;
734                          }
735                          if (taskTop == p) {
736                              taskTop = below;
737                          }
738                          if (taskTopI == replyChainEnd) {
739                              taskTopI = -1;
740                          }
741                          replyChainEnd = -1;
742                          addRecentTaskLocked(target.task);
743                      } else if (forceReset || finishOnTaskLaunch
744                              || clearWhenTaskReset) {
745
746                          // sunway:
747                          // 经过若干次循环后,确定了要reset的activity的范围,开始reset
748                          // 其中, CLEAR_WHEN_TASK_RESET和CLEAR_TOP行为相似,都使
749                          // 该activity以上被finish,但前者会限制上限为当前task
750
751                          // If the activity should just be removed -- either
752                          // because it asks for it, or the task should be
753                          // cleared -- then finish it and anything that is
754                          // part of its reply chain.
755                          if (clearWhenTaskReset) {
756                              // In this case, we want to finish this activity
757                              // and everything above it, so be sneaky and pretend
758                              // like these are all in the reply chain.
759                              replyChainEnd = targetI+1;
760                              while (replyChainEnd &lt; mHistory.size() &amp;&amp;
761                                      ((HistoryRecord)mHistory.get(
762                                                  replyChainEnd)).task == task) {
763                                  replyChainEnd++;
764                              }
765                              replyChainEnd--;
766                          } else if (replyChainEnd &lt; 0) {
767                              replyChainEnd = targetI;
768                          }
769                          HistoryRecord p = null;
770                          for (int srcPos=targetI; srcPos&lt;=replyChainEnd; srcPos++) {
771                              p = (HistoryRecord)mHistory.get(srcPos);
772                              if (p.finishing) {
773                                  continue;
774                              }
775                              if (finishActivityLocked(p, srcPos,
776                                      Activity.RESULT_CANCELED, null, "reset")) {
777                                  replyChainEnd--;
778                                  srcPos--;
779                              }
780                          }
781                          if (taskTop == p) {
782                              taskTop = below;
783                          }
784                          if (taskTopI == replyChainEnd) {
785                              taskTopI = -1;
786                          }
787                          replyChainEnd = -1;
788                      } else {
789                          // If we were in the middle of a chain, well the
790                          // activity that started it all doesn't want anything
791                          // special, so leave it all as-is.
792                          replyChainEnd = -1;
793                      }
794                  } else {
795                      // Reached the bottom of the task -- any reply chain
796                      // should be left as-is.
797                      replyChainEnd = -1;
798                  }
799
800              } else if (target.resultTo != null) {
801                  // If this activity is sending a reply to a previous
802                  // activity, we can't do anything with it now until
803                  // we reach the start of the reply chain.
804                  // XXX note that we are assuming the result is always
805                  // to the previous activity, which is almost always
806                  // the case but we really shouldn't count on.
807                  if (replyChainEnd &lt; 0) {
808                      replyChainEnd = targetI;
809                  }
810
811              } else if (taskTopI &gt;= 0 &amp;&amp; allowTaskReparenting
812                      &amp;&amp; task.affinity != null
813                      &amp;&amp; task.affinity.equals(target.taskAffinity)) {
814                  // sunway:
815                  // 如果其它task中有从当前task`过继`过去的activity, 那么也会reset
816                  // 它,或者会把它move回当前task (根据IF_NEEDED)
817
818                  // We are inside of another task...  if this activity has
819                  // an affinity for our task, then either remove it if we are
820                  // clearing or move it over to our task.  Note that
821                  // we currently punt on the case where we are resetting a
822                  // task that is not at the top but who has activities above
823                  // with an affinity to it...  this is really not a normal
824                  // case, and we will need to later pull that task to the front
825                  // and usually at that point we will do the reset and pick
826                  // up those remaining activities.  (This only happens if
827                  // someone starts an activity in a new task from an activity
828                  // in a task that is not currently on top.)
829                  Slog.e("sunway", "AMS:206");
830                  if (forceReset || finishOnTaskLaunch) {
831                      Slog.e("sunway", "AMS:208");
832                      if (replyChainEnd &lt; 0) {
833                          replyChainEnd = targetI;
834                      }
835                      HistoryRecord p = null;
836                      for (int srcPos=targetI; srcPos&lt;=replyChainEnd; srcPos++) {
837                          p = (HistoryRecord)mHistory.get(srcPos);
838                          if (p.finishing) {
839                              continue;
840                          }
841                          Slog.e("sunway", "AMS:218");
842                          if (finishActivityLocked(p, srcPos,
843                                  Activity.RESULT_CANCELED, null, "reset")) {
844                              taskTopI--;
845                              lastReparentPos--;
846                              replyChainEnd--;
847                              srcPos--;
848                          }
849                      }
850                      replyChainEnd = -1;
851                  } else {
852                      Slog.e("sunway", "AMS:229");
853                      if (replyChainEnd &lt; 0) {
854                          replyChainEnd = targetI;
855                      }
856                      for (int srcPos=replyChainEnd; srcPos&gt;=targetI; srcPos--) {
857                          HistoryRecord p = (HistoryRecord)mHistory.get(srcPos);
858                          if (p.finishing) {
859                              continue;
860                          }
861                          if (lastReparentPos &lt; 0) {
862                              lastReparentPos = taskTopI;
863                              taskTop = p;
864                          } else {
865                              lastReparentPos--;
866                          }
867                          mHistory.remove(srcPos);
868                          p.task.numActivities--;
869                          p.task = task;
870                          mHistory.add(lastReparentPos, p);
871                          if (DEBUG_TASKS) Slog.v(TAG, "Pulling activity " + p
872                                  + " in to resetting task " + task);
873                          task.numActivities++;
874                          mWindowManager.moveAppToken(lastReparentPos, p);
875                          mWindowManager.setAppGroupId(p, p.task.taskId);
876                          if (VALIDATE_TOKENS) {
877                              mWindowManager.validateAppTokens(mHistory);
878                          }
879                      }
880                      replyChainEnd = -1;
881
882                      // Now we've moved it in to place...  but what if this is
883                      // a singleTop activity and we have put it on top of another
884                      // instance of the same activity?  Then we drop the instance
885                      // below so it remains singleTop.
886                      if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
887                          for (int j=lastReparentPos-1; j&gt;=0; j--) {
888                              HistoryRecord p = (HistoryRecord)mHistory.get(j);
889                              if (p.finishing) {
890                                  continue;
891                              }
892                              if (p.intent.getComponent().equals(target.intent.getComponent())) {
893                                  if (finishActivityLocked(p, j,
894                                          Activity.RESULT_CANCELED, null, "replace")) {
895                                      taskTopI--;
896                                      lastReparentPos--;
897                                  }
898                              }
899                          }
900                      }
901                  }
902              }
903
904              target = below;
905              targetI = i;
906          }
907
908          return taskTop;
909          // sunway:
910          // 总结:
911          // RESET_TASK是指有些activity会被finish,有些会被move (ALLOW_TASK_REPARENTING)
912          // IF_NEEDED因为有三层含义:
913          //   1. task inactive超过30 min后会被CLEAR_TASK_ON_LAUNCH
914          //   2. 有些activity若设置了FINISH_ON_TASK_LAUNCH属性或有
915          //      CLEAR_WHEN_TASK_RESET intent flag, 会被finish
916          //   3. 有些activity若设置了ALLOW_TASK_REPARENTING, 会被moved, 或者被finish
917          // 一般只有launcher会 reset task
918      }
</pre>

</li>
</ul>
<ul>
<li id="sec-1-2-8-2-2">analysis<br/>



<pre class="example">startActivityUnchecked(HistoryRecord r, HistoryRecord sourceRecord, ...)
// r is the activity to be start; sourceRecord is the activity that issues the startActivity, for notification, service..., sourceRecord is null
  if (sourceRecord==null):
  // This activity is not being started from another...  in this case, always start new task
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
  else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
  // original Activity is SINGLE_INSTANCE launchMode
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
  else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
           or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;

  if (r.resultTo != null &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
    // NEW_TASK is set, but requires Activity result, so just cancel the result
    sendActivityResultLocked(-1,...)

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 ...):
    HistoryRecord taskTop=findTaskLocked(intent, r.info);
       // find the target task complies with r, according to affinity, compnent, .... from mHistory, top --&gt; bottom
       // findTaskLocked will return the top activity in any existing task matching the given intent
       // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
       // How taskAffinity is null? if activity's taskAffinity property is set to "" (see `Notification`), then it's taskAffinity will be set to null
    if (taskTop!=null):
    // found an target task, may try to foreground the task
    // else jump to endif of ..launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK..
      HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
      // find the current top activity's task
      if (curTop.task != taskTop.task):
      // target task is in background, will try to foreground target task, unless ...
        boolean callerAtFront = sourceRecord == null  || curTop.task == sourceRecord.task;
        // whether the startActivity action is issued from an obscured activity
        // we prefer that an obscured activity can't moveTaskToFront
        if (callerAtFront):
          moveTaskToFrontLocked(taskTop.task, r);
          // move all the activities belonging to target task to the top of mHistory
        if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0):
          // reset task if need, another dragon~
          taskTop = resetTaskIfNeededLocked(taskTop, r);
      if ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
           or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
           or r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
        HistoryRecord top = performClearTaskLocked(taskTop.task.taskId, r, launchFlags, true);
        // clear the *mHistory* from top to the target *artivity*
        // note that: if target is successfully moved to front beforehand,
        // clearTask will actually only clear the target task, instead of the whole mHistory
          // for each activity from mHistory.top downto target activity, finish it!
          // for the target activity, if it has the SINGLE_TOP flag, do nothing and return it, else finish it!
        if (top!=null):
          // target activity has the SINGLE_TOP flag, thus not finished
          deliverNewIntentLocked(top, r.intent);
        else:
          // target activity has been finished, place a new one on the task
          addingToTask = true;  // future actions will be taken if addingToTask is true, which means we need add the target activity to target task
                                // addingToTask means `startNewActivity`
      else if (r.realActivity.equals(taskTop.task.realActivity)): // else of clear_top
        // In this case the top activity on the task is the
        // same as the one being launched, so we take that
        // as a request to bring the task to the foreground.
        if (!r.intent.filterEquals(taskTop.task.intent)):
        // we are trying to restart target task's root activity, but with a different intent, we should start a new instance on top
        // else, do nothing (since the target task is already brought to front)
          addingToTask = true;
      // if CLEAR_TOP ends here
      if (!addingToTask):
      // new instance should not be started, e.g. CLEAR_TOP will SINGLE_TOP; starting target task's root activity with the same intent
        resumeTopActivity()
        return;
  // if NEW_TASK end here

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // when we reach here:
  // 1. activity w/o NEW_TASK
  // 2. activity w/ NEW_TASK but doesn't found the target task

  HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
  if (top.realActivity.equals(r.realActivity)):
    if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
      or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
      or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
        resumeTopActivityLocked(null);
        deliverNewIntentLocked(top, r.intent);
        return;
  if (!addingToTask  &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
    // case 2.
    r.task = new TaskRecord(mCurTask, r.info, intent,...)
  else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0):
    // case 1.
    HistoryRecord top = performClearTaskLocked(sourceRecord.task.taskId, r, launchFlags, true);
    if (top != null):
      deliverNewIntentLocked(top, r.intent);
      return;
  else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0):
    // case 1.
    // In this case, we are launching an activity in our own task
    // that may already be running somewhere in the history, and
    // we want to shuffle it to the front of the stack if so.
    int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
      // if sourceRecord.task is not the top task in mHistory, return -1, else return the index of r in mHistory
    HistoryRecord top = moveActivityToFrontLocked(where);
    deliverNewIntentLocked(top, r.intent);
    resumeTopActivityLocked(null);
    return;
  // if NEW_TASK ends here

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // all launchMode and flag is considered, if control flow still reach here ... startActivity!
  startActivityLocked(r, newTask, doResume);
  return;
</pre>

<p>
      simplified procedure:
</p>



<pre class="example">if NEW_TASK:
  if found target task:
    moveTaskToFront()
    clearTop
    starting with the same intent with target task?
single_top
new task
clear_top
reorder_to_front
startActivity
</pre>


<p>
      To summarize:
</p><ol>
<li>FLAG_ACTIVITY_NEW_TASK may be set implicitly, e.g.
<ul>
<li>starting activity from service, notification &hellip;, where sourceRecord==null
</li>
<li>target activity is SINGLE_INSTANCE, SINGLE_TASK
</li>
<li>sourceRecord is in SINGLE_INSTANCE
</li>
</ul>

</li>
<li>FLAG_ACTIVITY_NEW_TASK has two means:
<ol>
<li>if target task exists: `moveTaskToFront`
</li>
<li>if not: start new task
</li>
</ol>

</li>
<li>moveTaskToFront must meet 3 conditions:
<ol>
<li>NEW_TASK
</li>
<li>target task exists and is in background
</li>
<li>sourceRecord is null or sourceRecord is the top activity,
            that is, only notification, service and curTop activity can move a background task to front through NEW_TASK
</li>
</ol>

</li>
<li>CLEAR_TOP
         CLEAR_TOP will clear all the activities in <b>mHistory</b> on top of target activity, so  CLEAR_TOP should be used in two ways:
<ol>
<li>in most cases, CLEAR_TOP should be used in conjunction with NEW_TASK, so that, before clear top, the target task is moveTaskToFront,
            thus the succeeding CLEAR_TOP will be restrict to the target task
</li>
<li>CLEAR_TOP can be used w/o NEW_TASK, but make sure the sourceRecord is the foreground task, or else all the activities on top of it will
            be finished.
</li>
</ol>

</li>
<li>REORDER_TO_FRONT
<ol>
<li>should <b>ONLY</b> be called by foreground task, or else the flag will not take effect
</li>
</ol>

<p>         because CLEAR_TOP condition is judged before REORDER_TO_FRONT, so if CLEAR_TOP is set, REORDER_TO_FRONT is ignored
         What's more: REORDER_TO_FRONT will only take effect if NEW_TASK
</p></li>
<li>deliverNewIntent
         deliverNewIntent will occurs in two cases:
<ol>
<li>SINGLE_TOP, w/ or w/o NEW_TASK
</li>
<li>REORDER_TO_FRONT
</li>
</ol>

</li>
</ol>

</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-8-3" class="outline-5">
<h5 id="sec-1-2-8-3"><span class="section-number-5">1.2.8.3</span> Launcher &amp; Task</h5>
<div class="outline-text-5" id="text-1-2-8-3">

</div>

</div>

<div id="outline-container-1-2-8-4" class="outline-5">
<h5 id="sec-1-2-8-4"><span class="section-number-5">1.2.8.4</span> resetTaskIfNeededLocked</h5>
<div class="outline-text-5" id="text-1-2-8-4">

<p>      FLAG_ACTIVITY_NEW_TAKS &amp;&amp; FLAG_ACTIVITY_RESET_TASK_IF_NEEDED will trigger resetTaskIfNeededLocked
</p>
<p>
      Typically, only launcher will set those two flags to resetTaskIfNeededLocked, but we still can set those flags manually to
      trigger resetTaskIfNeededLocked
</p>



<pre class="example">resetTaskIfNeededLocked
  // whether the launching activity has the property `CLEAR_TASK_ON_LAUNCH`
  boolean forceReset = (newActivity.info.flags &amp;ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  // if the target task has been inactive for ACTIVITY_INACTIVE_RESET_TIME (30 min)
  // and the target's *root* activity doesn't have the ALWAYS_RETAIN_TASK_STATE property, also set forceReset to true
  // that is what the phrase `IfNeed` means
  if (taskTop.task.getInactiveDuration() &gt; ACTIVITY_INACTIVE_RESET_TIME):
    if ((newActivity.info.flags &amp;ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0):
      forceReset = true;
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  foreach HistoryRecord of the target task in mHistory (from top --&gt; bottom):
    // should the activity be finished on task launch?
    boolean finishOnTaskLaunch = (flags&amp;ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
    // should the activity has ALLOW_TASK_REPARENTING property?
    boolean allowTaskReparenting = (flags&amp;ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
    // should the activity clear it's top when task reset?
    boolean clearWhenTaskReset = (target.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
    if (!finishOnTaskLaunch &amp;&amp; !clearWhenTaskReset &amp;&amp; allowTaskReparenting
        &amp;&amp; !target.taskAffinity.equals(task.affinity)):
      // if the activity is ALLOW_TASK_REPARENTING and it's affinity is different with target task ...
      // that is , the activity is reparent from somewhere else ... , so detach it, instead of kill it.
      // however, ALLOW_TASK_REPARENTING can only overide forceReset: finishOnTaskLaunch and clearWhenTaskReset can still kill it.
      // ALLOW_TASK_REPARENTING is flexible: it can be attached/detached from a TO-BE-RESET task.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (forceReset || finishOnTaskLaunch || clearWhenTaskReset ):
      if (clearWhenTaskReset):
        // finish all the actvities of the target task above the launching activity.
      finish current activity
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (taskTopI &gt;= 0 &amp;&amp; allowTaskReparenting &amp;&amp; task.affinity.equals(target.taskAffinity)):
      // We are inside of another task...  if this activity has an affinity for our task, then either remove it if we are
      // clearing or attach it to our task
</pre>


<p>
      To summarize:
</p><ul>
<li>CLEAR_TASK_ON_LAUNCH property will clear the task when re-launch the task from launcher, (only meaningful for root activity)
</li>
<li>if task has been inactive for 30 min, it will also be CLEAR_TASK_ON_LAUNCH, unless RETAIN_TASK_STATE property is set
        RETAIN_TASK_STATE is closely related to the 30 min thresh-hold, (only meaningful for root activity)
</li>
<li>FINISH_ON_TASK_LAUNCH property vs. CLEAR_WHEN_TASK_RESET intent flag (not only meaningful for root activity)
</li>
<li>ALLOW_TASK_REPARENTING is flexible: it can be detached/attached from a TO-BE-RESET task
</li>
</ul>


</div>

</div>

<div id="outline-container-1-2-8-5" class="outline-5">
<h5 id="sec-1-2-8-5"><span class="section-number-5">1.2.8.5</span> affinity</h5>
<div class="outline-text-5" id="text-1-2-8-5">

<p>      2010-11-15
</p><ol>
<li>One task's affinity is the root activity's task affinity.
</li>
<li>activity's task affinity, if not specified in manifest, is set to the activity's package name, by default.
</li>
<li>activity's task affinity can be <b>null</b>:
         if activity's taskAffinity property is set to "" (see <a href="#Notification">Notification</a>), then it's taskAffinity will be set to null
</li>
<li>Affinity will affect activity in two ways:
<ol>
<li>When activity A calls startActivity(B) to start B activity, B will be
            put into the same task as A, but if the calling intent set the flag
            FLAG<sub>NEW</sub><sub>TASK</sub>
<ol>
<li>if there is already ONE task whose affinity is identical with B's
               affinity (including the origina task), B will be put into that
               task. so, if orig task's affinity is the same as B's affinity,B will still be placed into the orig task
</li>
<li>if there is no task whose affinity is identical with B's
               affinity, B will be put into a new task. So the FLAG<sub>NEW</sub><sub>TASK</sub> is
               a little ambiguous, maybe it should be named
               FLAG<sub>NEW</sub><sub>OR</sub><sub>EXIST</sub><sub>TASK</sub>.
</li>
</ol>

</li>
<li>If A call startActivity(B) to start B activity, and the calling
           task's affinity is same as B's affinity, and B has set the activity
           property: AllowTaskReparenting, then B will be `reparented` to the
           calling task.
</li>
</ol>

</li>
</ol>

</div>

</div>

<div id="outline-container-1-2-8-6" class="outline-5">
<h5 id="sec-1-2-8-6"><span class="section-number-5">1.2.8.6</span> launch mode</h5>
<div class="outline-text-5" id="text-1-2-8-6">

<ul>
<li id="sec-1-2-8-6-1">standard<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-6-2">singleTop<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-6-3">singleInstance<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-6-4">singleTask<br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-8-7" class="outline-5">
<h5 id="sec-1-2-8-7"><span class="section-number-5">1.2.8.7</span> Intent flag</h5>
<div class="outline-text-5" id="text-1-2-8-7">

<ul>
<li id="sec-1-2-8-7-1">FLAG<sub>ACTIVITY</sub><sub>NEW</sub><sub>TASK</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-2">FLAG<sub>ACTIVITY</sub><sub>CLEAR</sub><sub>TOP</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-3">FLAG<sub>ACTIVITY</sub><sub>SINGLE</sub><sub>TOP</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-4">FLAG<sub>ACTIVITY</sub><sub>REORDER</sub><sub>TO</sub><sub>FRONT</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-5">FLAG<sub>ACTIVITY</sub><sub>RESET</sub><sub>TASK</sub><sub>IF</sub><sub>NEEDED</sub> [launch related]<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-6">FLAG<sub>ACTIVITY</sub><sub>CLEAR</sub><sub>WHEN</sub><sub>TASK</sub><sub>RESET</sub> [launch related]<br/>
       stronger CLEAR<sub>TOP</sub>?
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-7">FLAG<sub>ACTIVITY</sub><sub>MULTIPLE</sub><sub>TASK</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-8">FLAG<sub>ACTIVITY</sub><sub>FORWARD</sub><sub>RESULT</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-7-9">FLAG<sub>ACTIVITY</sub><sub>EXCLUDE</sub><sub>FROM</sub><sub>RECENTS</sub><br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-8-8" class="outline-5">
<h5 id="sec-1-2-8-8"><span class="section-number-5">1.2.8.8</span> Properties</h5>
<div class="outline-text-5" id="text-1-2-8-8">

<ul>
<li id="sec-1-2-8-8-1">FINISH<sub>ON</sub><sub>TASK</sub><sub>LAUNCH</sub>  [launch related]<br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-8-2">CLEAR<sub>TASK</sub><sub>ON</sub><sub>LAUNCH</sub>  [launch related]<br/>
       activity must be taks's root activity
</li>
</ul>
<ul>
<li id="sec-1-2-8-8-3">ALLOW<sub>TASK</sub><sub>REPARENTING</sub><br/>
</li>
</ul>
<ul>
<li id="sec-1-2-8-8-4">ALWAYS<sub>RETAIN</sub><sub>TASK</sub><sub>STATE</sub><br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-8-9" class="outline-5">
<h5 id="sec-1-2-8-9"><span class="section-number-5">1.2.8.9</span> moveTaskToBack</h5>
<div class="outline-text-5" id="text-1-2-8-9">

</div>

</div>

<div id="outline-container-1-2-8-10" class="outline-5">
<h5 id="sec-1-2-8-10"><span class="section-number-5">1.2.8.10</span> isTaskRoot</h5>
<div class="outline-text-5" id="text-1-2-8-10">

</div>
</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Service &nbsp;&nbsp;&nbsp;<span class="tag"><span class="service">service</span></span></h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> startService</h4>
<div class="outline-text-4" id="text-1-3-1">




<pre class="example">startServiceLocked()
   retrieveServiceLocked()
     checkComponentPermission()
   bringUpServiceLocked()
      if serviceRecord.app and app.thread is not null,
           sendServiceArgs()
              thread.scheduleServiceArgs()
                  service.onStartCommand()
       else
           getProcessRecord(appName)
           if app or thread is not null (process is ready)
               realStartService()
                  thread.scheduleCreate..
           else
               startProcess()
                  start ActivityThread
               add service to mPendingSer..
</pre>



<pre class="example">New process:
  ActivityThread::attach()
    AMS::attachApplication()
      foreach mPendingServices:
        realStartService()
          thread.scheduleCreate..
</pre>

</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> bindService &amp;  unbindService</h4>
<div class="outline-text-4" id="text-1-3-2">


</div>

<div id="outline-container-1-3-2-1" class="outline-5">
<h5 id="sec-1-3-2-1"><span class="section-number-5">1.3.2.1</span> ServiceConnection</h5>
<div class="outline-text-5" id="text-1-3-2-1">

<p>      ServiceConnection itself is binder proxy, which only implement one method:
</p>


<pre class="example">void connected(ComponentName name, IBinder service) throws RemoteException;
</pre>

<p>
      through ServiceConnection.connected(), service can notify the <b>client</b> about service bound/unbound.
</p>
<p>
      so the client must implement the ServiceConnection stub, actually, ActivityThread maintains one
</p>


<pre class="example">HashMap&lt;Context, HashMap&lt;ServiceConnection, ServiceDispatcher&gt;&gt; mServices
</pre>

<p>
      while ServiceDispatcher maintains the ServiceConnection stub. AMS will notify the client directly through ServiceConnection stub in ActivityThread
      To summarize:
</p><ol>
<li>ServiceConnection is a stub implement in ActivityThread, AMS use it to notify client
</li>
<li>ServiceConnection are maintained by ActivityThread, Activity.destroy will not affect the connection.
</li>
</ol>

</div>

</div>

<div id="outline-container-1-3-2-2" class="outline-5">
<h5 id="sec-1-3-2-2"><span class="section-number-5">1.3.2.2</span> bindService</h5>
<div class="outline-text-5" id="text-1-3-2-2">




<pre class="example">int bindService(IServiceConnection connection,...);; connection is the binder proxy supplied by client
  mServiceConnections.put(binder, c); ;; AMS save the proxy for later use
   if ((flags&amp;Context.BIND_AUTO_CREATE) != 0):  ;; if BIND_AUTO_CREATE flag is set, will bring up the service
     bringUpServiceLocked(s, service.getFlags(), false);
       ;; may start process --&gt; create service --&gt; start service ...
     return 0;
   if (s.app != null &amp;&amp; b.intent.received):
     connection.connected(s.name, b.intent.binder); ;; notify client by onServiceConnected
</pre>

</div>

</div>

<div id="outline-container-1-3-2-3" class="outline-5">
<h5 id="sec-1-3-2-3"><span class="section-number-5">1.3.2.3</span> unbindService</h5>
<div class="outline-text-5" id="text-1-3-2-3">




<pre class="example">mServiceConnections.remove(connection);
s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());
if ((c.flags&amp;Context.BIND_AUTO_CREATE) != 0):
  bringDownServiceLocked(s, false);
    if (!force &amp;&amp; r.startRequested):  // startService will set r.startRequested to true, that why unbindService won't bring down service if it is
                                      // started by startService
      return;
    if (r.connections.size() &gt; 0):
      for each connection:
        if ((cr.flags&amp;Context.BIND_AUTO_CREATE) != 0):  // if there is still any other connection that is BIND_AUTO_CREATE,
                                                          // skip bring down the service
          return;
      for each connection:
        c.conn.connected(r.name, null);   // service is about to be brought down, notify all connections through onServiceDisconnected
  r.app.thread.scheduleStopService(r);
</pre>

<p>
        To summarize:
          unbindService will normally stop service, unless:
</p><ol>
<li>the connection is not a BIND<sub>AUTO</sub><sub>CREATE</sub> connection
</li>
<li>service is started by startService
</li>
<li>that are still other BIND<sub>AUTO</sub><sub>CREATE</sub> connections bound to the service
</li>
</ol>

</div>
</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> ServiceRecord</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>d12/28/10 8:12 pm
similar with AMS::HistoryRecord. mainly save the r.ap and r.app.thread so as to interact with the service's process. .  But there is no correspondant like ActivityRecord in ActivityThread, since service needn't interqact with WMS, and it's life cycle is quite simple. (create, start, stop)
</p></div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> STICKY service</h4>
<div class="outline-text-4" id="text-1-3-4">

<p>STICKY mainly make sense when process has crashed due to uncaught exception.
see also <a href="#Android-Process-Crash-and-Restart">Android Process Crash and Restart</a>
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Broadcast &nbsp;&nbsp;&nbsp;<span class="tag"><span class="broadcast">broadcast</span></span></h3>
<div class="outline-text-3" id="text-1-4">


</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> OrderedBroadcast</h4>
<div class="outline-text-4" id="text-1-4-1">


</div>

<div id="outline-container-1-4-1-1" class="outline-5">
<h5 id="sec-1-4-1-1"><span class="section-number-5">1.4.1.1</span> AbortBroadcast()</h5>
<div class="outline-text-5" id="text-1-4-1-1">

</div>

</div>

<div id="outline-container-1-4-1-2" class="outline-5">
<h5 id="sec-1-4-1-2"><span class="section-number-5">1.4.1.2</span> GetResult..()</h5>
<div class="outline-text-5" id="text-1-4-1-2">

</div>

</div>

<div id="outline-container-1-4-1-3" class="outline-5">
<h5 id="sec-1-4-1-3"><span class="section-number-5">1.4.1.3</span> priority</h5>
<div class="outline-text-5" id="text-1-4-1-3">

<p>broadcast receiver's intent filter's `priority` will be used to by the AMS to determine the order in which the broadcast is send to
</p></div>

</div>

<div id="outline-container-1-4-1-4" class="outline-5">
<h5 id="sec-1-4-1-4"><span class="section-number-5">1.4.1.4</span> SetResult..()</h5>
<div class="outline-text-5" id="text-1-4-1-4">

</div>
</div>

</div>

<div id="outline-container-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> protected-broadcast</h4>
<div class="outline-text-4" id="text-1-4-2">

<p>PACKAGE<sub>REMOVED</sub>/PACKAGE<sub>ADDED</sub>/BOOT<sub>COMPLETED</sub> are all protected-broadcasts, only the process with "system" uid can send the broadcast
</p>


<pre class="example">broadcastIntentLocked()
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) :
    // Always okay.
  else:
    if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) :
      throw new SecurityException(msg);
</pre>


<p>
To summarize: 
</p>
<p>
`protected-broadcasts` means `those broadcasts can only
be sent by SYSTEM,PHONE,SHELL or root`
</p>
</div>

</div>

<div id="outline-container-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> SendBroadcast</h4>
<div class="outline-text-4" id="text-1-4-3">

<p>every call to sendBroadcast will init a new receiver instance.
</p>


<pre class="example">AMS:broadcastIntentLocked()
  // find out who will recv this broadcast
  if intent.getComponent():
    receivers.add(r);
  else:
    if !Intent.FLAG_RECEIVER_REGISTERED_ONLY:
      receivers=PM.queryIntentReceivers();
    registeredReceivers = ReceiverResolver.queryIntent(); ;;ReceiverResolver is a in-memory storage that stores runtime-registered receivers
  // now, `receivers` stores receivers from PM, `registeredReceivers` stores receivers from ReceiverResolver
  if !ordered:
    BroadcastRecord r=new BroadcastRecord(registeredReceivers);
    mParallelBroadcasts.add(r);
    add/update mStickyBroadcasts if the broadcast is STICKY 
    ;; note: mStickyBroadcasts is only re-broadcasted on registerReceiver()
    scheduleBroadcastsLocked()
      sendMessage(BROADCAST_INTENT_MSG);
        processNextBroadcast();
          foreach BroadcastRecord in mParallelBroadcasts:
            foreach receiver in BroadcastRecord:
              deliverToRegisteredReceiver();
                ;; make sure receiver has the requiredPermission imposed by the sender,  e.g. PERMISSION_BOOT_COMPLETED, sender can imposed a
                ;; requiredPermission through sendBroadcast(intent,requiredPermission)
                if r.requiredPermission!=null:
                  checkComponentPermission(r.requiredPermission,filter.receiverList.pid, filter.receiverList.uid, -1);
                ;; make sure the sender has the requiredPermission imposed by the receiver's filter
                if filter.requiredPermission != null:
                  checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1);
                performReceive();
                  if app.thread !=null:
                    app.thread.scheduleRegisteredReceiver();
                      ReceiverDispatcher.performReceive() ;; for registeredReceivers, receiver class are identified by ReceiverDispatcher (which is send to
                                                          ;; AMS during registerReceiver()
                        new Args() {
                          run():
                            receiver.onReceive();
                            if ordered:
                              AMS:finishReceiver(); ;; not called here
                        }
                        H.post(Args);
    registeredReceivers=null; ;; since registeredReceivers is broadcasted already as mParallelBroadcasts, it should not be merged with receivers
  ;; if  !ordered, registeredReceivers are broadcasted all at once, without TIMEOUT consideration! SO, registeredReceivers in non-ordered broadcast
  ;; will never cause ANR!
  ;; if ordered, both registeredReceivers and receivers are merged in a single list, so that both registeredReceivers and receivers are broadcasted in
  ;; order
  merge_into_one_receiver_list();
  scheduleBroadcastsLocked();
    sendMessage();
      processNextBroadcast();
        r=OrderedBroadcast.get(0);
        if r.nextReceiver&gt;r.receivers.size():
          removeMessages(BROADCAST_TIMEOUT_MSG);
        r.receiverTime=now();
        if current receiver is the first one of r:
          sendMessageAtTime(BROADCAST_TIMEOUT_MSG,r.receiverTime+BROADCAST_TIMEOUT);
        if current receiver is a registeredReceivers:
          scheduleBroadcastsLocked(get Current Receiver); ;; direct call
        else:
          if app!=null:
            app.thread.scheduleReceiver();
              handlerReceiver()
                receiver = (BroadcastReceiver)cl.loadClass(component).newInstance(); ;; for static receivers, receivers are identified by component name
                receiver.onReceive(context.getReceiverRestrictedContext(),...)
                AMS:finishReceiver(); ;; notify AMS that it can process next broadcast.
          else:
            startProcess();
            mPendingBroadcast=r; ;; mPendingBroadcast will broadcasted when process is ready and attached to AMS

   BROADCAST_TIMEOUT_MSG's handle Message() will check whether r.receiverTime is updated, if so, that means one of Ra's receiver has returned, so
   handler will not cause an ANR
</pre>

<p>
To summarize:
</p><ol>
<li>dynamic registered receiver
      <b>the same BroadcastReceiver instance is used for Multi-broadcast</b>
<ul>
<li>in non-ordered broadcast
<ol>
<li>doesn't cause ANR
</li>
<li>all dynamic receivers are invoked in parallel manner (by ActivityThread's handler), i.e. one receiver's onReceive() will not block another
           receiver's correspondent.
</li>
</ol>

</li>
<li>in ordered broadcast
        ANR and parallel/serial manner is the same as static registered receivers

</li>
</ul>

</li>
<li>static registered receiver
      <b>every time broadcast is received, a new static registered receiver instance is initiated</b>
<ul>
<li>always invoked in a serial manner, i.e. one static receiver's onReceive() will block other static receiver's correspondents, no matter
        whether it is ordered. (maybe because static receiver's process is not assumed to be running, AMS need a simplified way to start all the processes)
</li>
</ul>

</li>
<li>for a certain broadcast, the ANR timing begins when the first receiver is about to be handled, and ends when the last receiver has been handled,
      and, what's most important: take one broadcast contains 10 static receivers for example, <span style="text-decoration:underline;">the total ANR timing can be 10*10s at most</span>, instead of 10s.
      because although the BROADCAST<sub>TIMEOUT</sub> is set to be 10s, every receiver will update r.receiverTime in AMS.finishReceiver(), and the timeout handler
      will issues an ANR only when <b>now-r.receiverTime &gt; BROADCAST<sub>TIMEOUT</sub> (10s)</b>

</li>
<li>sendBroadcast will make sure both the sender and the receiver has been granted the requiredPermission imposed by the counterpart.
      see also protected-broadcast for another sendBroadcast limitation.

</li>
<li>Intent.FLAG<sub>RECEIVER</sub><sub>REGISTERED</sub><sub>ONLY</sub>
</li>
</ol>

</div>

</div>

<div id="outline-container-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> BroadcastRecord</h4>
<div class="outline-text-4" id="text-1-4-4">

</div>

</div>

<div id="outline-container-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> Sticky</h4>
<div class="outline-text-4" id="text-1-4-5">

</div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> ProcessRecord</h3>
<div class="outline-text-3" id="text-1-5">


</div>

<div id="outline-container-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> processName</h4>
<div class="outline-text-4" id="text-1-5-1">

</div>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> AppDeathRecipient</h3>
<div class="outline-text-3" id="text-1-6">

<p>see also <a href="#binder-s-death">binder's death</a>
see also <a href="#Android-Process-Crash-and-Restart">Android Process Crash and Restart</a>
</p></div>

</div>

<div id="outline-container-ActivityThread" class="outline-3">
<h3 id="ActivityThread"><a name="sec-1-7" id="sec-1-7"></a><span class="section-number-3">1.7</span> ActivityThread</h3>
<div class="outline-text-3" id="text-ActivityThread">

<p>    ActivityThread stands for the client (contract to AMS) side <b>process</b>.
    Actually, the class itself is not a Thread at all. It is a normal java class, and has ONE main(), which act as the entry point of a java process.
    ActivityThread.main()
</p>


<pre class="example">Looper.prepare()
ActivityThread thread = new ActivityThread();
thread.attach(false);
Looper.loop();
</pre>

<p>
    that is ,
</p><ul>
<li>ActivityThread.main() will start loop in the main thread, the looper is the so-call `mainLooper`
</li>
<li>thread.attach() will establish reverse connection (AMS &ndash;&gt; ActivityThread) with AMS, (set IApplicationThread IBinder to AMS.app.thread),
      so that AMS can use the IApplicationThread to interact with ActivityThread, e.g. scheduleResumeaCtivity, scheduleLaunchActivity.
      AMS use <a href="#AppDeathRecipient">@AppDeathRecipient</a> to reset app.thread to null, which means the process has gone.
</li>
</ul>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-05-20T21:16+0800</p>
<p class="author">Author: sunway</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.1 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
