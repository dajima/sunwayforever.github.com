<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>OO</title>
<!-- 2014-09-26 Fri 10:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">OO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. OO</a>
<ul>
<li><a href="#sec-1-1">1.1. ClassObject 与 Object</a></li>
<li><a href="#sec-1-2">1.2. ArrayObject</a></li>
<li><a href="#sec-1-3">1.3. StringObject</a></li>
<li><a href="#sec-1-4">1.4. Class Loading</a></li>
<li><a href="#sec-1-5">1.5. 各种函数的实现</a></li>
<li><a href="#sec-1-6">1.6. 对齐</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> OO</h2>
<div class="outline-text-2" id="text-1">
<p>
Java 本身并没有规定 Object 的内存布局, 例如在 class 文件, 引用某个
instance filed 时完全通过 constant pool 来指定, 不涉及任何实现细节. 但
具体实现 vm 时, 内存布局是必须要考虑的.
</p>

<p>
Dalvik 的 Object Model 定义起来比较简单: 它是用 C++ 语言来描述的. 所以
`一般`不需要关注内存布局中的细节, 但如果涉及到 fast mterp, 还是需要从内
存布局的角度描述 Object Model.
</p>

<p>
Dalvik 使用 C++ 定义了五种对象:
</p>

<ol class="org-ol">
<li>Object
</li>
<li>ArrayObject
</li>
<li>ClassObject
</li>
<li>StringObject
</li>
<li>DataObject
</li>
</ol>

<p>
其中 Object 是其它四种对象的基类.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> ClassObject 与 Object</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900;">struct</span> <span style="color: #b58900;">Object</span> {
    <span style="color: #b58900;">ClassObject</span>*    <span style="color: #268bd2;">clazz</span>;
    <span style="color: #b58900;">u4</span>              <span style="color: #268bd2;">lock</span>;
};

<span style="color: #859900;">struct</span> <span style="color: #b58900;">ClassObject</span> : <span style="color: #b58900;">Object</span> {
    <span style="color: #b58900;">u4</span>              <span style="color: #268bd2;">instanceData</span>[CLASS_FIELD_SLOTS];
    <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>*     <span style="color: #268bd2;">descriptor</span>;
    <span style="color: #b58900;">u4</span>              <span style="color: #268bd2;">accessFlags</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">objectSize &#26159;&#20445;&#23384;&#22312; ClassObject (&#21363; java &#31867;&#20013;), &#32780;&#19981;&#26159;&#20445;&#23384;&#22312;</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">java &#23545;&#35937;&#20013;. &#22240;&#20026;&#21516;&#19968;&#20010;&#31867;&#30340;&#23545;&#35937;&#30340;&#22823;&#23567;&#26159;&#30456;&#21516;&#30340;. &#23454;&#38469;&#19978;&#23601;&#26159; 8 +</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">InstField &#30340;&#22823;&#23567;. </span>
    <span style="color: #b58900;">size_t</span>          <span style="color: #268bd2;">objectSize</span>;
    <span style="color: #b58900;">ClassObject</span>*    <span style="color: #268bd2;">super</span>;
    <span style="color: #b58900;">Object</span>*         <span style="color: #268bd2;">classLoader</span>;
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">interfaceCount</span>;
    <span style="color: #b58900;">ClassObject</span>**   <span style="color: #268bd2;">interfaces</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">directMethod, &#21253;&#25324; private, static, &lt;init&gt; &#31561;</span>
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">directMethodCount</span>;
    <span style="color: #b58900;">Method</span>*         <span style="color: #268bd2;">directMethods</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#34394;&#20989;&#25968;, &#21363;&#38750; directMethods, &#36825;&#20123;&#20989;&#25968;&#19981;&#20250;&#30452;&#25509;&#34987;&#35843;&#29992;:</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#23427;&#20204;&#20250;&#36890;&#36807;&#21518;&#38754;&#30340; vtable &#34987;&#35843;&#29992;. &#21478;&#22806;, virtualMethods &#21482;&#21253;&#21547;&#26412; class &#23454;&#29616;&#30340;&#34394;&#20989;&#25968;.</span>
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">virtualMethodCount</span>;
    <span style="color: #b58900;">Method</span>*         <span style="color: #268bd2;">virtualMethods</span>;
    <span style="color: #586e75; font-style: italic;">/*</span>
<span style="color: #586e75; font-style: italic;">     * Virtual method table (vtable), for use by "invoke-virtual".  The</span>
<span style="color: #586e75; font-style: italic;">     * vtable from the superclass is copied in, and virtual methods from</span>
<span style="color: #586e75; font-style: italic;">     * our class either replace those from the super or are appended.</span>
<span style="color: #586e75; font-style: italic;">     */</span>
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">vtableCount</span>;
    <span style="color: #b58900;">Method</span>**        <span style="color: #268bd2;">vtable</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#25104;&#21592;&#21464;&#37327;</span>
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">ifieldCount</span>;
    <span style="color: #b58900;">InstField</span>*      <span style="color: #268bd2;">ifields</span>;

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">interface table</span>
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">iftableCount</span>;
    <span style="color: #b58900;">InterfaceEntry</span>* <span style="color: #268bd2;">iftable</span>;

    <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">static fields */</span>
    <span style="color: #b58900;">int</span>             <span style="color: #268bd2;">sfieldCount</span>;
    <span style="color: #b58900;">StaticField</span>     <span style="color: #268bd2;">sfields</span>[0]; <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">MUST be last item */</span>
};
</pre>
</div>

<p>
从两个类的定义中, 可以看出:
</p>
<ol class="org-ol">
<li>Object 本身并没有太多的数据, 数据都存在于 ClassObject 中, 实际上,
只有 InstField 会被保存在 Object 中.
</li>
</ol>

<p>
以下面的代码为例:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">class</span> <span style="color: #b58900;">Base</span> {
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">base</span>;
}
<span style="color: #859900;">class</span> <span style="color: #b58900;">Foo</span> <span style="color: #859900;">extends</span> <span style="color: #b58900;">Base</span> {
    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">xxx</span>;
    <span style="color: #859900;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">bcd</span>;
    <span style="color: #859900;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">abc</span>;

    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #b58900;">Foo</span> <span style="color: #268bd2;">f</span> = <span style="color: #859900;">new</span> <span style="color: #b58900;">Foo</span>();
        f.abc= 0x1234;
        System.out.println(<span style="color: #2aa198;">"Hello, foo"</span>+f.abc);
    }
}
</pre>
</div>

<p>
这段代码执行时会生成一个 Object 对象代表 Foo 对象, 以及一个
ClassObject 代表 Foo 类, 一个 ClassObject 代表 Base 类. 其中
ClassObject 的内存布局与 C++ 定义的一致.而 Object 的布局会有一点
tricky:
</p>

<pre class="example">
 Object
-+-------------+      ClassObject
 | ClassObject-+----&gt;+-------------------+
-+-------------+     | ClassObject (NULL)|
 | lock        |    -+-------------------+
-+-------------+     | lock              |
 | base field  |    -+-------------------+
-+-------------+     | instance data     |
 | abc field   |    -+-------------------+
-+-------------+     | descriptor        |
 | bcd field   |    -+-------------------+
-+-------------+     | ....              |
                    -+-------------------+
</pre>

<p>
上面的示意图有几点要注意:
</p>
<ol class="org-ol">
<li>instance field 是直接按一定顺序放在 Object 中的. 虽然 Object本身并没
有定义一个类似于 InstField 的字段.
</li>
<li>基类的 InstField 会插入到 Object 自身的 InstField 之前 (通过
computeFieldOffsets 代码可以确认)
</li>
<li>ClassObject 的开头 8 个字节与 Object 结构相同, 因为它继承自 Object,
这一点要参考 C++ Object Model
</li>
<li>Object 中定义的 lock 字与 hotspot 中的 mark word作用类似, 但与 mark
word 不同的是, lock 并不包含对象的年代信息以及 GC 信息.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> ArrayObject</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">struct</span> <span style="color: #268bd2;">ArrayObject</span> : Object {
    <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">number of elements; immutable after init */</span>
    <span style="color: #b58900;">u4</span>              <span style="color: #268bd2;">length</span>;

    <span style="color: #586e75; font-style: italic;">/*</span>
<span style="color: #586e75; font-style: italic;">     * Array contents; actual size is (length * sizeof(type)).  This is</span>
<span style="color: #586e75; font-style: italic;">     * declared as u8 so that the compiler inserts any necessary padding</span>
<span style="color: #586e75; font-style: italic;">     * (e.g. for EABI); the actual allocation may be smaller than 8 bytes.</span>
<span style="color: #586e75; font-style: italic;">     */</span>
    <span style="color: #b58900;">u8</span>              <span style="color: #268bd2;">contents</span>[1];
};
</pre>
</div>
<p>
可见, 
</p>
<ol class="org-ol">
<li>ArrayObject offset 为 8 的 int 值保存着 Array 的长度. 
</li>
<li>Array 的数据部分保存在它的变长的 contents 区域.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> StringObject</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> intern</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
OP<sub>CONST</sub><sub>STRING</sub>:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">HANDLE_OPCODE</span>(OP_CONST_STRING <span style="color: #586e75; font-style: italic;">/*</span><span style="color: #586e75; font-style: italic;">vAA, string@BBBB</span><span style="color: #586e75; font-style: italic;">*/</span>)
{
    <span style="color: #b58900;">StringObject</span>* <span style="color: #268bd2;">strObj</span>;

    vdst = INST_AA(inst);
    ref = FETCH(1);
    ILOGV(<span style="color: #2aa198;">"|const-string v%d string@0x%04x"</span>, vdst, ref);
    strObj = dvmDexGetResolvedString(methodClassDex, ref);
    <span style="color: #859900;">if</span> (strObj == <span style="color: #2aa198;">NULL</span>) {
        EXPORT_PC();
        strObj = dvmResolveString(curMethod-&gt;clazz, ref);
        <span style="color: #859900;">if</span> (strObj == <span style="color: #2aa198;">NULL</span>)
            GOTO_exceptionThrown();
    }
    SET_REGISTER(vdst, (<span style="color: #b58900;">u4</span>) strObj);
}
FINISH(2);
OP_END
</pre>
</div>

<p>
dvmResolveString:
</p>

<div class="org-src-container">

<pre class="src src-text">StringObject* dvmResolveString(const ClassObject* referrer, u4 stringIdx)
  utf8 = dexStringAndSizeById(pDvmDex-&gt;pDexFile, stringIdx, &amp;utf16Size);
  strObj = dvmCreateStringFromCstrAndLength(utf8, utf16Size);
  internStrObj = dvmLookupImmortalInternedString(strObj);
  return internStrObj;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Class Loading</h3>
<div class="outline-text-3" id="text-1-4">
<p>
java 类加载的过程包含一般包括加载, 解析, 初始化等过程.  特别的, dvm 加
载类的过程基本上就是:
</p>

<ol class="org-ol">
<li>加载 &#x2013; dvmfindclassnoinit

<p>
从 odex 中加载类 (loadClassFromDex), 此后 ClassObject 的多数成员已经
被初始化
</p>
</li>

<li>解析 (link) &#x2013; dvmLinkClass

<p>
通过 dvmLinkClass, 将 ClassObject 中的存在的 symbolic references
resolve 为 direct pointer (对于 vtable, superclass, iftable 等) 或
offset (对于 sfields, ifields)
</p>

<p>
需要注意的是, 在最初的 ClassLoader 初始化阶段, dexopt 会负责将 dex
转换为 odex, 这时会做一些类似于 resolve 的工作, 但这些工作影响的主
要是 dex 中的代码部分: 即 xxx 指令会被转换为 xxx<sub>quick</sub> 指令, 使代码
由使用 symbolic references 的方式变为使用 direct pointer 或 offset
的方式. 所以, 即使有 odex, dvmLinkClass 时还是需要做 resolve 的动作.
</p>
</li>

<li>初始化 &#x2013; dvminitclass 与 验证 &#x2013; dvmVerifyClass
</li>
</ol>

<p>
Class Loading 的入口是 dvmResolveClass-&gt;findClassNoInit
</p>

<p>
findClassNoInit:
</p>
<div class="org-src-container">

<pre class="src src-text">ClassObject* findClassNoInit(descriptor, loader, pDvmDex)
  clazz = loadClassFromDex(pDvmDex, pClassDef, loader);
    newClass = (ClassObject*) dvmMalloc(size, ALLOC_NON_MOVING);
    newClass-&gt;descriptor = descriptor;
    newClass-&gt;interfaceCount = pInterfacesList-&gt;size;
    // &#35835;&#21462; ifaces
    newClass-&gt;interfaces = (ClassObject**) dvmLinearAlloc(classLoader,
    newClass-&gt;interfaceCount * sizeof(ClassObject*));

    for (i = 0; i &lt; newClass-&gt;interfaceCount; i++):
      const DexTypeItem* pType = dexGetTypeItem(pInterfacesList, i);
      newClass-&gt;interfaces[i] = (ClassObject*)(u4) pType-&gt;typeIdx;

    // &#35835;&#21462; sfield  
    newClass-&gt;sfieldCount = count;
    for (i = 0; i &lt; count; i++):
      dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);
      loadSFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;sfields[i]);
    // &#35835;&#21462; ifield, direct methods, virtual methods ...

  dvmLinkClass(clazz)
    // resolve superclass &#20026; direct pointer
    ClassObject* super = dvmResolveClass(clazz, superclassIdx, false);
    dvmSetFieldObject(clazz,  OFFSETOF_MEMBER(ClassObject,super),super);
    // resolve ifaces
    for (i = 0; i &lt; clazz-&gt;interfaceCount; i++) {
      clazz-&gt;interfaces[i] = dvmResolveClass(clazz,interfaceIdxArray[i], false);
    // &#26681;&#25454; virtualMethods &#21450; superclass, ifaces &#29983;&#25104; vtable
    createVtable(clazz)
      clazz-&gt;vtable = (Method**) dvmLinearAlloc(clazz-&gt;classLoader, maxCount);
      // &#23558; super &#30340; vtable &#19982; clazz &#33258;&#24049;&#30340; virtualMethods &#36827;&#34892;&#27604;&#36739;,
      // &#29983;&#25104;&#26368;&#32456;&#30340; clazz-&gt;vtable

      // maxCount &#26159;&#25351;&#26412;&#31867;&#30340; vtable &#21487;&#33021;&#36798;&#21040;&#30340;&#26368;&#22823;&#22823;&#23567;, &#26368;&#32456; vtable &#30340;
      // &#22823;&#23567;&#24517;&#28982;&#20250; &lt;= maxCount
      maxCount = clazz-&gt;virtualMethodCount;
      if (clazz-&gt;super != NULL):
        maxCount += clazz-&gt;super-&gt;vtableCount;
      clazz-&gt;vtable = (Method**) dvmLinearAlloc(sizeof(Method*) * maxCount);
      // &#20808;&#29992; super-&gt;vtable &#35206;&#30422; class-&gt;vtabl &#30340;&#21069;&#20960;&#39033;
      memcpy(clazz-&gt;vtable, clazz-&gt;super-&gt;vtable,
            sizeof(*(clazz-&gt;vtable)) * clazz-&gt;super-&gt;vtableCount);
      actualCount = clazz-&gt;super-&gt;vtableCount;        
      // &#28982;&#21518;&#25195;&#25551; class-&gt;virtualMethods, &#36890;&#36807;&#21517;&#23383;&#30340;&#27604;&#36739;&#30475;&#26159;&#21542;&#26377;&#26041;&#27861;&#38656;&#35201;&#35206;&#30422;&#22522;&#31867;               for (i = 0; i &lt; clazz-&gt;virtualMethodCount; i++):
        Method* localMeth = &amp;clazz-&gt;virtualMethods[i];
        for (si = 0; si &lt; clazz-&gt;super-&gt;vtableCount; si++):
          Method* superMeth = clazz-&gt;vtable[si];
          // &#20004;&#20010;&#26041;&#27861;&#30340;&#21517;&#23383;&#21644; signature &#26159;&#30456;&#21516;&#30340; ...
          if (dvmCompareMethodNamesAndProtos(localMeth, superMeth) == 0):
            // &#30830;&#20445;&#22522;&#31867;&#26041;&#27861;&#19981;&#26159; final
            if (dvmIsFinalMethod(superMeth)): bail;
            // &#26412;&#31867;&#26041;&#27861;&#35206;&#30422;&#22522;&#31867;&#26041;&#27861;
            clazz-&gt;vtable[si] = localMeth;
            localMeth-&gt;methodIndex = (u2) si;
         // inner for ends here
         // super-&gt;vtable &#20013;&#21508;&#39033;&#25195;&#25551;&#23436;&#27605;, &#21457;&#29616;&#19981;&#33021;&#35206;&#30422;, &#25918;&#21040;&#32467;&#23614;
         if (si == clazz-&gt;super-&gt;vtableCount):
           clazz-&gt;vtable[actualCount] = localMeth;
           localMeth-&gt;methodIndex = (u2) actualCount;
       // outer for ends here
       assert(actualCount &lt;= maxCount);

    // &#29983;&#25104; iftable
    // &#19978;&#19968;&#27493;&#30340; vtable &#20013;&#21253;&#21547;&#20102;&#25152;&#26377;&#30340;&#34394;&#20989;&#25968;, &#21253;&#25324;&#32487;&#25215;&#33258; super &#30340;&#21644;&#33258;&#24049;
    // &#23454;&#29616;&#30340;, &#20294;&#33258;&#24049;&#23454;&#29616;&#30340;&#25509;&#21475;&#20013;&#30340;&#34394;&#20989;&#25968;&#38656;&#35201;&#36890;&#36807; iftable &#36827;&#34892;&#32034;&#24341;, &#22240;
    // &#20026; invoke-interface &#21644; invoke-virtual &#26159;&#19981;&#21516;&#30340;, &#21069;&#32773;&#38656;&#35201;
    // iftable &#25165;&#33021;&#24037;&#20316;, &#20855;&#20307;&#35265;
    // http://stackoverflow.com/questions/1504633/what-is-the-point-of-invokeinterface
    createIftable(clazz)
    // &#35745;&#31639;&#25152;&#26377; ifiled &#30340; offset, &#21518;&#38754;&#30340; GetFieldID &#31561;&#38656;&#35201;&#20351;&#29992;
    // ifiled &#19982; vtable &#30340;&#32452;&#32455;&#26377;&#20123;&#31867;&#20284;: &#37117;&#26159;&#22522;&#31867;&#25104;&#21592;&#22312;&#21069;, &#33258;&#36523;&#25104;&#21592;&#22312;&#21518;
    computeFieldOffsets(clazz)
      if (clazz-&gt;super != NULL):
        fieldOffset = clazz-&gt;super-&gt;objectSize;
        for (i = 0; i &lt; clazz-&gt;ifieldCount; i++):
          pField-&gt;byteOffset = fieldOffset;
          fieldOffset += sizeof(u4);
    // precacheReferenceOffsets &#20250;&#36127;&#36131;&#23558; referent filed &#20174; ifields
    // &#31227;&#38500;, &#20197;&#20415; GC &#26102; scanDataObject &#26102;&#19981;&#20250;&#25195;&#25551;&#21040; referent &#23545;&#35937;.
    if (strcmp(clazz-&gt;descriptor, "Ljava/lang/ref/Reference;") == 0):
      precacheReferenceOffsets(clazz)
</pre>
</div>

<p>
loadClassFromDex
</p>
<div class="org-src-container">

<pre class="src src-text">DexClassDef* pClassDef;
pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);
  // DexClassDef &#23454;&#38469;&#19978;&#23601;&#26159; dex &#25991;&#20214;&#20013; Class Definition Table &#20013;&#30340;&#19968;&#39033;
  // pLookup &#26159; odex &#21253;&#21547;&#30340;&#19968;&#20010;&#23545;&#20110;&#21152;&#36895;&#26597;&#25214;&#30340;&#25968;&#25454;&#32467;&#26500;
  // ...
  return (const DexClassDef*)
    (pDexFile-&gt;baseAddr + pLookup-&gt;table[idx].classDefOffset);

clazz = loadClassFromDex(pDvmDex, pClassDef, loader);
  // class data &#26159; class definition &#30340;&#19968;&#39033;, &#21253;&#21547;&#20102;&#21508;&#31181; fields, methods
  // &#30340;&#32034;&#24341;&#21644;&#26435;&#38480;&#20449;&#24687;
  pEncodedData = dexGetClassData(pDexFile, pClassDef);
  dexReadClassDataHeader(&amp;pEncodedData, &amp;header);
    pHeader-&gt;staticFieldsSize = readUnsignedLeb128(pData);
    pHeader-&gt;instanceFieldsSize = readUnsignedLeb128(pData);
    pHeader-&gt;directMethodsSize = readUnsignedLeb128(pData);
    pHeader-&gt;virtualMethodsSize = readUnsignedLeb128(pData);
  // pDvmDex &#26159; dex file
  // pClassDef &#26159; dex file &#20013;&#30340; Class Definition Table &#20013;&#30340;&#19968;&#39033;
  // header &#26159; class &#30340;&#21508;&#31181; field, methods &#22312; dex file &#20013;&#30340;&#32034;&#24341;
  // pEncodedData &#26159; pClassDef &#30340; data &#37096;&#20998;
  loadClassFromDex0(pDvmDex, pClassDef, &amp;header, pEncodedData, classLoader);
    pDexFile = pDvmDex-&gt;pDexFile;
    descriptor = dexGetClassDescriptor(pDexFile, pClassDef);
      // &#20351;&#29992; pClassDef-&gt;classIdx &#25195;&#25551; String Table &#33719;&#24471; descriptor
      dexStringByTypeIdx(pDexFile, pClassDef-&gt;classIdx);
    newClass-&gt;descriptor = descriptor;
    //... &#35835;&#21462;&#20854;&#23427;&#30340; field, methods, interface ...
    // &#21253;&#25324;&#22312; LinearAlloc &#19978;&#20998;&#37197;&#30456;&#24212;&#30340; Field, Method &#23545;&#35937;, &#20174; dex file
    // &#20013;&#35835;&#21462;&#30456;&#24212;&#30340;&#25968;&#25454;, &#36825;&#37324;&#35835;&#21040;&#30340;&#25968;&#25454;&#38656;&#35201;&#34987;&#21518;&#32493;&#30340; dvmLinkClass &#22788;&#29702;
    // &#21518;&#25165;&#33021;&#20351;&#29992;, &#21253;&#25324;:
    // 1. ifield &#38656;&#35201;&#36890;&#36807; link &#24471;&#21040;&#22312; Object &#20013;&#30340;&#32034;&#24341;.
    // 2. super &#38656;&#35201;&#36890;&#36807; link &#23558; idx &#21464;&#20026;&#23454;&#38469;&#30340; ClassObject*
    // 3. iftable &#38656;&#35201;&#36890;&#36807; link &#23558; idx &#21464;&#20026; ClassObject*
    // 4. vtable &#38656;&#35201;&#36890;&#36807; link &#29983;&#25104;
    // 5. ...
</pre>
</div>

<p>
至此 ClassObject 已经准备完毕:
</p>

<ol class="org-ol">
<li>clazz-&gt;super 指向了父类的 ClassObject
</li>
<li>clazz-&gt;virtualMethods 包含了所有该类实现的虚函数 Method, 而
Method-&gt;insns 又指向了 mmap 的 odex 中真正的代码部分
</li>
<li>clazz-&gt;vtable 包含该类, 父类中定义的所有虚函数 Method 的引用.
</li>
<li>clazz-&gt;iftable 包含该类实现的接口函数在 vtable 中的引用.
</li>
<li>clazz-&gt;ifield 中所有的 InstField 在 Object 中的 offset 被计算出来
</li>
<li>&#x2026;
</li>
</ol>

<p>
注意: ClassObject 本身分配在 GC Heap, 但它的 ifield, sfield,
virtualMethods 等成员却分配在 LinearAlloc. 分配在 GC Heap 可能主要是考
虑到 ClassObject 也要参与到 GC 扫描, 而 GC 扫描通过 liveBits, markBits
进行的, 必须要求 ClassObject 本身分配在 GC Heap 上 (因为 liveBits,
markBits 是针对 GC Heap 的 bitmap)
</p>
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> class 何时被加载</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
基本上涉及到 clazz 的 OP<sub>CODE</sub> 都会直接或间接通过 dvmResolveClass 来导致
class 被加载.
</p>

<p>
以下情况下 class 会首次被加载:
</p>

<ol class="org-ol">
<li>主动调用 Class.forName 等函数
</li>
<li>通过 reflect 的一些方法对 class 进行操作时
</li>
<li>OP<sub>NEW</sub><sub>INSTANCE</sub>
</li>
<li>OP<sub>SGET</sub>/OP<sub>SSET</sub>
</li>
<li>OP<sub>INVOKE</sub><sub>STATIC</sub>
</li>
<li>OP<sub>INSTANCE</sub><sub>OF</sub>
</li>
</ol>

<p>
invoke-virtual, invoke-interface 等以及 iget/iset 不包含在以上列表中,
因为这些调用之前, OP<sub>NEW</sub><sub>INSTANCE</sub> 肯定已经把 class 加载完成了. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 各种函数的实现</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> iget / iset</h4>
<div class="outline-text-4" id="text-1-5-1">
</div><div id="outline-container-sec-1-5-1-1" class="outline-5">
<h5 id="sec-1-5-1-1"><span class="section-number-5">1.5.1.1</span> Jni version</h5>
<div class="outline-text-5" id="text-1-5-1-1">
<p>
第一步, 获得 jfieldID, 这个 jfieldID 实际上是 InstField *, 其
byteOffset 保存着 Object 中保存该 ifield 的偏移量. 
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">static</span> <span style="color: #b58900;">jfieldID</span> <span style="color: #268bd2;">GetFieldID</span>(JNIEnv* env, <span style="color: #b58900;">jclass</span> <span style="color: #268bd2;">jclazz</span>, <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* name, <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* sig) {
    <span style="color: #b58900;">ScopedJniThreadState</span> <span style="color: #268bd2;">ts</span>(<span style="color: #b58900;">env</span>);
    ClassObject* clazz = (ClassObject*) dvmDecodeIndirectRef(ts.self(), jclazz);

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">jfieldID &#19982; jmethodID &#31561;&#19968;&#26679;, &#23454;&#38469;&#31867;&#22411;&#37117;&#26159;&#19968;&#20010; opaque pointer</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#36825;&#37324; jfieldID &#30340;&#23454;&#38469;&#31867;&#22411;&#20026; InstField*</span>
    <span style="color: #b58900;">jfieldID</span> <span style="color: #268bd2;">id</span> = (<span style="color: #b58900;">jfieldID</span>) dvmFindInstanceFieldHier(clazz, name, sig);
    <span style="color: #859900;">return</span> id;
}
</pre>
</div>

<p>
第二步, 调用 GetField##<sub>jname</sub>, 以 byte 为例
</p>
<div class="org-src-container">

<pre class="src src-text">INLINE s1 dvmGetFieldByte(const Object* obj, int offset) {
    return ((JValue*)BYTE_OFFSET(obj, offset))-&gt;b;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-1-2" class="outline-5">
<h5 id="sec-1-5-1-2"><span class="section-number-5">1.5.1.2</span> interpreter version</h5>
<div class="outline-text-5" id="text-1-5-1-2">
<p>
与下面 sget / sset 类似, 根据 dex 中的 id 获得 name, 然后根据 name 找
到 InstField*, 然后根据偏移量得到 ifield 的值. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> sget / sset</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
sget/sset 比 iget/iset 要复杂, 因为 static 变量可以存在于 interface 中
</p>
</div>
<div id="outline-container-sec-1-5-2-1" class="outline-5">
<h5 id="sec-1-5-2-1"><span class="section-number-5">1.5.2.1</span> jni version</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<p>
首先, GetStaticFieldID 得到 jfieldID, 这个 jfieldID 实现上是
StaticField *, 其 value 值即为所求. 
</p>
<div class="org-src-container">

<pre class="src src-text">jfieldID GetStaticFieldID(env, jclazz, char* name, char* sig)
  jfieldID id = dvmFindStaticFieldHier(clazz, name, sig);
    // search in current clazz
    pField = dvmFindStaticField(clazz, fieldName, signature);
      // &#36890;&#36807;&#36941;&#21382; clazz-&gt;sfields &#26597;&#25214;
      pField = &amp;clazz-&gt;sfields[0];
      for (i = 0; i &lt; clazz-&gt;sfieldCount; i++, pField++):
        if (strcmp(fieldName, pField-&gt;name) == 0 &amp;&amp;
          strcmp(signature, pField-&gt;signature) == 0)
          return (StaticField*) pField;
      // &#33509; clazz &#20013;&#27809;&#25214;&#21040;, &#21017;&#26597;&#25214;&#25152;&#26377;&#25509;&#21475;
      for ( ; i &lt; clazz-&gt;iftableCount; i++) {
        ClassObject* iface = clazz-&gt;iftable[i].clazz;
        pField = dvmFindStaticField(iface, fieldName, signature);
        if (pField != NULL):
          return pField;
      // &#33509;&#25152;&#26377;&#25509;&#21475;&#20013;&#37117;&#27809;&#26377;&#25214;&#21040;, &#21017;&#26597;&#25214;&#29238;&#31867;
      if (clazz-&gt;super != NULL):
        return dvmFindStaticFieldHier(clazz-&gt;super, fieldName, signature);
      else
        return NULL;
</pre>
</div>

<p>
第二步, GetStaticField##<sub>jname</sub>, 这个函数直接从 jfieldID (即
StaticField* ) 中取出 value 字段即可. 
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2-2" class="outline-5">
<h5 id="sec-1-5-2-2"><span class="section-number-5">1.5.2.2</span> interpreter version</h5>
<div class="outline-text-5" id="text-1-5-2-2">
<div class="org-src-container">

<pre class="src src-text">// ref &#26159;&#19968;&#20010;&#25972;&#25968;, odex &#20195;&#30721;&#20013;&#19981;&#26159;&#20351;&#29992; name &#26597;&#25214; filed &#30340;, &#32780;&#26159;&#24050;
// &#32463;&#35745;&#31639;&#20986;&#20102; sfield &#22312; sfields &#20013;&#30340; offset, &#25152;&#20197;&#31532;&#19968;&#27493;&#38656;&#35201;&#26681;&#25454; ref &#25214;
// &#21040;&#21407;&#26469;&#30340; name

StaticField* sfield = dvmResolveStaticField(clazz, ref);
  DexFieldId pFieldId = dexGetFieldId(pDvmDex-&gt;pDexFile, ref);
  // &#36890;&#36807; dexStringById &#21518;&#21040; name &#21518;, &#21518;&#38754;&#30340;&#35843;&#29992;&#21644; jni &#30456;&#21516;
  return dvmFindStaticFieldHier(resClass,
           dexStringById(pDvmDex-&gt;pDexFile, pFieldId-&gt;nameIdx),
           dexStringByTypeIdx(pDvmDex-&gt;pDexFile, pFieldId-&gt;typeIdx));
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> iget-quick/iset-quick</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
由于 iget/iset 本质是操作 Object 的一个 offset, 所以 odex 提供 quick 版
本的iget/iset, 直接以 offset 做为操作数. 
</p>

<p>
但 sget/sset 并不存在 quick 版本, 因为接口也可以包含 static 变量, 无法
通过一个 offset 简单的搞定. 
</p>
</div>
</div>
<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4"><span class="section-number-4">1.5.4</span> invoke</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
所有 invoke 类调用都分为两步:
</p>
<ol class="org-ol">
<li>查找真正的 Method (dvmResolveMethod)
</li>
<li>调用 Method (处理参数, 返回值, 栈帧等)
</li>
</ol>

<p>
dalvik 的 invoke 类调用共分为五种, 主要原因是查找 Method 的方法不同,
例如, invoke-direct 是从 Object 的 directMethods 中找, 而
invoke-virtual 需要从 Object-&gt;vtable 和 Object-&gt;virtualMethods 中找.
更复杂的 invoke-interface 需要从 Object-&gt;iftable, Object-&gt;vtable 和
Object-&gt;virtualMethods 中找到.
</p>
</div>

<div id="outline-container-sec-1-5-4-1" class="outline-5">
<h5 id="sec-1-5-4-1"><span class="section-number-5">1.5.4.1</span> 五种 invoke</h5>
<div class="outline-text-5" id="text-1-5-4-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">interface</span> <span style="color: #b58900;">I</span> {
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">i</span>();
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">Base</span> {
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">b</span>() {};
}

<span style="color: #859900;">class</span> <span style="color: #b58900;">Foo</span> <span style="color: #859900;">extends</span> <span style="color: #b58900;">Base</span> <span style="color: #859900;">implements</span> <span style="color: #b58900;">I</span> {
    <span style="color: #859900;">public</span> <span style="color: #268bd2;">Foo</span>() {}
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">b</span>() {
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">invoke-super</span>
        <span style="color: #859900;">super</span>.b();
    }
    <span style="color: #859900;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">i</span>() {

    }

    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">v</span>() {}
    <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">s</span>() {}

    <span style="color: #859900;">private</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">p</span>() {}
    <span style="color: #859900;">final</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">f</span>() {}

    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">invoke-static</span>
        Foo.s();
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">invoke-direct  </span>
        <span style="color: #b58900;">Foo</span> <span style="color: #268bd2;">f</span> =  <span style="color: #859900;">new</span> <span style="color: #b58900;">Foo</span>();
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">invoke-virtual</span>
        f.v();
        f.i();
        f.f();
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">invoke-interface</span>
        ((<span style="color: #b58900;">I</span>)f).i();
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">invoke-direct</span>
        f.p();
    }
}
</pre>
</div>

<p>
对应的 dalvik 字节码为:
</p>
<div class="org-src-container">

<pre class="src src-text">.class LFoo;
.super LBase;
.source "Foo.java"

# interfaces
.implements LI;


# direct methods
.method constructor &lt;init&gt;()V
    .locals 0

    .prologue
    .line 10
    invoke-direct {p0}, LBase;-&gt;&lt;init&gt;()V

    return-void
.end method

.method public static main([Ljava/lang/String;)V
    .locals 1
    .parameter

    .prologue
    .line 27
    invoke-static {}, LFoo;-&gt;s()V

    .line 29
    new-instance v0, LFoo;

    invoke-direct {v0}, LFoo;-&gt;&lt;init&gt;()V

    .line 31
    invoke-virtual {v0}, LFoo;-&gt;v()V

    .line 33
    invoke-virtual {v0}, LFoo;-&gt;i()V

    .line 34
    invoke-virtual {v0}, LFoo;-&gt;f()V

    .line 36
    invoke-interface {v0}, LI;-&gt;i()V

    .line 38
    invoke-direct {v0}, LFoo;-&gt;p()V

    .line 39
    return-void
.end method

.method private p()V
    .locals 0

    .prologue
    .line 22
    return-void
.end method

.method static s()V
    .locals 0

    .prologue
    .line 20
    return-void
.end method


# virtual methods
.method public b()V
    .locals 0

    .prologue
    .line 13
    invoke-super {p0}, LBase;-&gt;b()V

    .line 14
    return-void
.end method

.method final f()V
    .locals 0

    .prologue
    .line 23
    return-void
.end method

.method public i()V
    .locals 0

    .prologue
    .line 17
    return-void
.end method

.method v()V
    .locals 0

    .prologue
    .line 19
    return-void
.end method
</pre>
</div>

<p>
虽然 invoke 分为五种, 但实际上根据查找的表的不同又分为两大类:
</p>

<ol class="org-ol">
<li>查找 Object-&gt;directMethods
<ul class="org-ul">
<li>invoke-static
</li>
<li>invoke-direct
</li>
</ul>
</li>
<li>查找 Object-&gt;virtualMethods
<ul class="org-ul">
<li>invoke-super
</li>
<li>invoke-virtual
</li>
<li>invoke-interface
</li>
</ul>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-5-4-2" class="outline-5">
<h5 id="sec-1-5-4-2"><span class="section-number-5">1.5.4.2</span> dvmResolveMethod</h5>
<div class="outline-text-5" id="text-1-5-4-2">
<p>
任何一种 invoke 的第一步都是调用 dvmResolveMethod 来查找真正的 Method,
不过不同的 invoke 会使用不同的参数
</p>

<div class="org-src-container">

<pre class="src src-text">Method* dvmResolveMethod(const ClassObject* referrer, u4 methodIdx,MethodType methodType)
  // &#26681;&#25454; nameIdx &#20174; dex &#20013;&#33719;&#24471; method name
  char* name = dexStringById(pDvmDex-&gt;pDexFile, pMethodId-&gt;nameIdx);
  if (methodType == METHOD_DIRECT):
    resMethod = dvmFindDirectMethod(resClass, name, &amp;proto);
  else if (methodType == METHOD_STATIC):
    resMethod = dvmFindDirectMethodHier(resClass, name, &amp;proto);
  else:
    resMethod = dvmFindVirtualMethodHier(resClass, name, &amp;proto);

// ------------------- for direct
Method* dvmFindDirectMethod(clazz, methodName, proto)
  // &#20174; Object-&gt;directMethods &#20013;&#26597;&#25214;, &#20294;&#20351;&#29992;&#19968;&#20010; false &#21442;&#25968;&#34920;&#31034;&#19981;&#38656;&#35201;
  // &#20174;&#29238;&#31867;&#20013;&#26597;&#25214;
  findMethodInListByProto(clazz, METHOD_DIRECT, false, methodName,proto);
    while (clazz != NULL) {
      int i;
      if (wantedType == METHOD_VIRTUAL || wantedType == METHOD_UNKNOWN):
        for (i = 0; i &lt; clazz-&gt;virtualMethodCount; i++):
          Method* method = &amp;clazz-&gt;virtualMethods[i];
            // &#22522;&#20110;&#23383;&#31526;&#20018;&#30340;&#21305;&#37197;
            if (dvmCompareNameProtoAndMethod(name, proto, method) == 0) {
              return method;
      if (wantedType == METHOD_DIRECT || wantedType == METHOD_UNKNOWN):
        for (i = 0; i &lt; clazz-&gt;directMethodCount; i++):
          Method* method = &amp;clazz-&gt;directMethods[i];
            if (dvmCompareNameProtoAndMethod(name, proto, method) == 0):
              return method;
      if (! isHier):
        break;

      clazz = clazz-&gt;super;
    // end while

// -------------------- for STATIC
Method* dvmFindDirectMethod(clazz, methodName, proto)
  findMethodInListByProto(clazz, METHOD_DIRECT, true, methodName, proto)

// -------------------- for VIRTUAL (mainly SUPER)
Method* dvmFindVirtualMethodHier(clazz,methodName,proto)
  findMethodInListByProto(clazz, METHOD_VIRTUAL, true, methodName,proto);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-4-3" class="outline-5">
<h5 id="sec-1-5-4-3"><span class="section-number-5">1.5.4.3</span> invoke-static</h5>
<div class="outline-text-5" id="text-1-5-4-3">
<div class="org-src-container">

<pre class="src src-text">methodToCall = dvmResolveMethod(curMethod-&gt;clazz, ref, METHOD_STATIC);
// &#25214;&#21040; methodToCall &#21518;&#30452;&#25509;&#35843;&#29992;&#21363;&#21487;
GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-4-4" class="outline-5">
<h5 id="sec-1-5-4-4"><span class="section-number-5">1.5.4.4</span> invoke-direct</h5>
<div class="outline-text-5" id="text-1-5-4-4">
<div class="org-src-container">

<pre class="src src-text">methodToCall = dvmResolveMethod(curMethod-&gt;clazz, ref,METHOD_DIRECT);
// &#19982; invokeStatic &#19968;&#26679;, &#30452;&#25509;&#35843;&#29992;, &#21482;&#19981;&#36807;&#22240;&#20026;&#23427;&#29992;&#30340;&#21442;&#25968;&#26159;METHOD_DIRECT
// &#23548;&#33268;&#22312; clazz-&gt;directMethods &#26597;&#25214;&#26102;&#19981;&#20250;&#26597;&#25214;&#21040;&#29238;&#31867;
GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-4-5" class="outline-5">
<h5 id="sec-1-5-4-5"><span class="section-number-5">1.5.4.5</span> invoke-super</h5>
<div class="outline-text-5" id="text-1-5-4-5">
<div class="org-src-container">

<pre class="src src-text">// &#26597;&#25214; base method &#26102;, &#21487;&#20197;&#22312;&#24403;&#21069; class &#25214;&#21040;, &#20063;&#21487;&#33021;&#22312;&#29238;&#31867;&#20013;&#25214;&#21040;
// &#20294;&#19981;&#24433;&#21709;&#26368;&#32456;&#30340;&#32467;&#26524;, &#21363; baseMethod-&gt;methodIndex
baseMethod = dvmResolveMethod(curMethod-&gt;clazz, ref,METHOD_VIRTUAL);
if (baseMethod-&gt;methodIndex &gt;= curMethod-&gt;clazz-&gt;super-&gt;vtableCount):
   // error
// &#36825;&#37324;&#38656;&#35201;&#22312; super-&gt;vtable &#20013;&#26597;&#25214;, &#26159;&#22240;&#20026;&#26377;&#21487;&#33021; baseMethod &#26159;&#22312;&#24403;&#21069;&#31867;
// &#20013;&#25214;&#21040;&#30340;, &#25105;&#20204;&#38656;&#35201;&#35843;&#29992;&#30340;&#26159;&#29238;&#31867;&#30340;&#29256;&#26412;.
methodToCall = curMethod-&gt;clazz-&gt;super-&gt;vtable[baseMethod-&gt;methodIndex];
GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-4-6" class="outline-5">
<h5 id="sec-1-5-4-6"><span class="section-number-5">1.5.4.6</span> invoke-virtual</h5>
<div class="outline-text-5" id="text-1-5-4-6">
<div class="org-src-container">

<pre class="src src-text">baseMethod = dvmResolveMethod(curMethod-&gt;clazz, ref,METHOD_VIRTUAL);
// &#36825;&#37324;&#27809;&#26377;&#30452;&#25509;&#20351;&#29992; baseMethod, &#26159;&#22240;&#20026;&#26377;&#21487;&#33021; baseMethod &#26159;&#20174;&#29238;&#31867;&#20013;&#24320;&#22987;
// &#26597;&#25214;&#30340;, &#25105;&#20204;&#35201;&#29992;&#30340;&#26159;&#23376;&#31867;&#20013;&#30340;&#29256;&#26412;
methodToCall = thisPtr-&gt;clazz-&gt;vtable[baseMethod-&gt;methodIndex];
GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-4-7" class="outline-5">
<h5 id="sec-1-5-4-7"><span class="section-number-5">1.5.4.7</span> invoke-interface</h5>
<div class="outline-text-5" id="text-1-5-4-7">
<p>
invoke-interface 与 invoke-virtual 不同:
</p>

<p>
invoke-interface 时使用的 ref 参数是和 interface 相关的, 无法通过调用
dvmResolveMethod 直接找到 clazz-&gt;virtualMethods 中对应的虚函数. 必须通过它
先找到接口类, 然后根据接口类在 clazz-&gt;iftable 中找到对应于该接口的
methodIndexArray, 然后才能从 clazz-&gt;vtable 中找到真正的 virtual
methods. 
</p>

<div class="org-src-container">

<pre class="src src-text">methodToCall = dvmFindInterfaceMethodInCache(thisClass, ref,curMethod,methodClassDex);
  dvmInterpFindInterfaceMethod(thisClass, methodIdx,method,methodClassDex)
    // &#20174;&#25509;&#21475;&#31867;&#20013;&#25214;&#21040; absMethod, &#36825;&#20010; absMethod &#24182;&#19981;&#33021;&#25191;&#34892;, &#30452;&#25509;&#30340;&#21487;&#25191;&#34892;&#30340; method
    // &#22312; thisClass &#30340; virtualMethods &#20013;
    // &#36825;&#37324;&#30340; method-&gt;clazz &#25351;&#30340;&#26159;&#25509;&#21475;&#31867;&#26412;&#36523;
    absMethod = dvmResolveInterfaceMethod(method-&gt;clazz, methodIdx);
      Method* dvmFindInterfaceMethodHier(iface,methodName,proto)
    for (i = 0; i &lt; thisClass-&gt;iftableCount; i++):
      if (thisClass-&gt;iftable[i].clazz == absMethod-&gt;clazz):
        break;
    // iftable[i] &#27492;&#26102;&#20195;&#34920;&#30456;&#24212;&#30340;&#25509;&#21475;&#31867;
    vtableIndex =
      thisClass-&gt;iftable[i].methodIndexArray[absMethod-&gt;methodIndex];
    methodToCall = thisClass-&gt;vtable[vtableIndex];    
GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-4-8" class="outline-5">
<h5 id="sec-1-5-4-8"><span class="section-number-5">1.5.4.8</span> invoke-virtual-quick 与 invoke-super-quick</h5>
<div class="outline-text-5" id="text-1-5-4-8">
<p>
odex 对 dex 优化时, 会将原来的 invoke-virtual 或 invoke-super 替换为相
应的 quick 版本, 相应的指令参数也会变: 由原来的 ref 直接变为 vtable
index, 这样可以节省一个 dvmResolveMethod 的过程. 
</p>

<p>
但是, invoke-direct, invoke-static 和 invoke-interface 并没有相应的
quick 版本. 因为这是不可能的&#x2026;
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 对齐</h3>
<div class="outline-text-3" id="text-1-6">
<p>
所有 java 对象都是 8 字节对齐的, 包括 Object, ClassObject 等. 
</p>

<p>
之所以是 8 字节对齐, 是因为默认情况下 dlmalloc 分配的地址是 8 字节对齐
的. 
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #cb4b16;">#define</span> <span style="color: #268bd2;">MALLOC_ALIGNMENT</span> ((<span style="color: #b58900;">size_t</span>)(2 * <span style="color: #859900;">sizeof</span>(<span style="color: #b58900;">void</span> *)))
</pre>
</div>

<p>
另外, dlmalloc 分配的地址按 8 字节对齐, 是指其分配出来的 malloc<sub>chunk</sub>
是 8 字节对齐的, 因为 malloc<sub>chunk</sub> 与 malloc 返回的地址刚好相差 8 字节
(prev+head), 所以 malloc 分配出来的地址也是 8 字节对齐的. 
</p>

<p>
值得注意的是, dlmalloc 分配的地址是 8 字节对齐的, 但它分配的 chunk 最
小为 16 字节(因为要包含 head+fd+prev = 12, 按 8 字节对齐就是 16).
</p>

<p>
以下场景利用了这种对齐 (或者依赖于这种对齐):
</p>

<ol class="org-ol">
<li>各种 bitmap 的每个位对应着 heap 上的 8 个字节.
</li>
<li>Object 的 lock word 被 inflate 成 fat lock 时, 其高 29 位对应着
monitor 对象的地址, 剩余 3 位标记锁类型 (fat or thin) 以及 hash
state. 因为 monitor 对象的地址是 8 字节对齐, 所以可以只用 29 位表示.
</li>
<li>基于 copy 的 GC 中, setForward 利用了对象地址的低三位来记录移动状态.
</li>
<li>&#x2026;
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-09-26 Fri 10:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.50.4 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
