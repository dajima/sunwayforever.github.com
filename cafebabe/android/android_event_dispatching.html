<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Android Event Dispatching</title>
<!-- 2014-07-01 Tue 10:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="wei.sun" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Android Event Dispatching</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Android Event Dispatching</a>
<ul>
<li><a href="#sec-1-1">1.1. Upper Level (above ViewRoot)</a></li>
<li><a href="#sec-1-2">1.2. Lower Level (below ViewRoot)</a></li>
<li><a href="#sec-1-3">1.3. Event Dispatching ANR</a></li>
<li><a href="#sec-1-4">1.4. 再看 Looper</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Android Event Dispatching</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Upper Level (above ViewRoot)</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> KeyEvent dispatch</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
ViewRootImpl:
</p>
<pre class="example">
WindowInputEventReceiver.onInputEvent();
  ViewRoot.deliverKeyEvent()
    ViewRoot.deliverKeyEventToViewHierarchy()
      Decorview.dispatchKeyEvent() ;; mView is the decorView
        if (is volume key)
          adjust volume
        if (has Window.Callback) ;; Activity, Dialog implents Window.Callback
          callback.dispatchKeyEvent()
            DecorView.superDispatchKeyEvent()
              ViewGroup.dispatchKeyEvent() ;; dispatch key event to view hierachy
                Travers the focus path, call every ViewGroup's dispatchKeyEvent, then finally,calls:
                focusView.dispatchKeyEvent()
                  mOnKeyListener.onKey()
                  if (not handled)
                    event.dispatch(view) ;; view also implents Event.Callback
            if (not handled)
                event.dispatch(activity) ;; Activity implents Event.Callback, which implents onKeyUp, onKeyDown ...
        else
          super.dispatchKeyEvent() ;; view.dispatchKeyEvent, PopupWindow falls into this condition, since PopupWindow
                                   ;; does not implents Window.Callback
        if (still not handled):
          Window.onKeyDown() or onKeyUp()
            // cope with MENU,CAMERA,VOLUME,MEDIA,CALL,SEARCH...
      if (not handled)
        changeFocus()
        if not (focus changed)
          playSoundEffect
      sWindowSession.finishKey(mWindow) to tell AMS that key
</pre>

<p>
note that:
Activity and Dialog implements Window.Callback and KeyEvent.Callback, so you can override Activity or Dialog's dispatchKeyEvent (implemented in
Window.Callback), and you can override onKeyUp, onKeyDown &#x2026;( implemented in KeyEvent.Callback)
But PopupWindow implements neither Window.Callback nor KeyEvent.Callback.
</p>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> TouchEvent dispatch</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="org-src-container">

<pre class="src src-text">ViewRoot.dispatchPointer()
  decorView.dispatchTouchEvent() ;; mView is typically a DecorView
    if DecorView has callbacks like Activity or Dialog
      activity.dispatchTouchEvent()
        mDecor.superDispatchTouchEvent()
        .... ;; same as the `else` branch
        activity.onTouchEvent() if not handled before
    else
      mDecor.superDispatchTouchEvent()
        ViewGroup.dispatchTouchEvent() ; DecorView is a FrameLayout
          if (action == MotionEvent.ACTION_DOWN):
            if (disallowIntercept || !onInterceptTouchEvent(Ev)):
              foreach mView of ViewGroup: ;; for each child of the ViewGroup whose rect contains pointer(x,y), note that view's rect is set during view.layout()
                if (mView.dispatchTouchEvent()):
                  mMotionTarget=mView;
                  return true;
          if mMotionTarget==null: // DOWN is not handled by any child; or event is up/move, but there is no mMotionTarget,
                                  // which means last DOWN is handled by ourselves.
            return super.dispatchTouchEvent()
              mView.onTouchListener().on Touch()
              mView.onTouchEvent() ;; if not handled before
                mView.onClickListener()
          // ACTION is up/move, and mMotionTarget is not null, which means we should delegate the up/move to the mMotionTarget,
          // There is no need to go through child hierarchy to handle it.
          if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)): // touchEvent is intercepted
            ev.setAction(MotionEvent.ACTION_CANCEL);
            mMotionTarget.dispatchTouchEvent(ev)
            return true;
          // touchEvent is not intercepted
          return mMotionTarget.dispatchTouchEvent(ev);
</pre>
</div>
<p>
To summarize:
</p>
<ol class="org-ol">
<li>TouchEvent dispatching 的过程和 KeyEvent <b>相反</b>:
<ul class="org-ul">
<li>KeyEvent: 先调用 ViewGroup.superDispatchKeyEvent(), 若没处理,再调用 mFocused.dispatchKeyEvent()
<ul class="org-ul">
<li>TouchEvent: 先调用 child.dispatchTouchEvent(),若没处理, 再调用 super.dispatchTouchEvent()
</li>
</ul>
</li>
</ul>
</li>
<li>dispatchTouchEvent -&gt; onTouchListener -&gt; onTouchEvent -&gt; onClickListener
</li>
<li>onInterceptTouchEvent and mMotionTarget and requestDisallowInterceptTouchEvent
</li>
</ol>
</div>

<div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1"><span class="section-number-5">1.1.2.1</span> ListView TouchEvent dispatch</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<ul class="org-ul">
<li>State "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2011-02-16 Wed 15:04]</span></span>
</li>
</ul>
<p>
ListView 首先是一个 ViewGroup, 它使用了
</p>
<pre class="example">
ViewGroup.dispatchTouchEvent()
  ask_child_to_handle_it()
  if not handled:
    super(view).dispatchTouchEvent()
      AbsListView.onTouchEvent()
        if child(list item).hasFocusable(): ;; if the liste_item have any view that is focusable
          do_nothing;
        else:
          onItemClickedListener();
</pre>

<p>
To summarize:
ListView is just like a common ViewGroup, but:
</p>
<ol class="org-ol">
<li>ListView's onTouchEvent will not invoke `onClickListener`, but `onItemClickedListener`
</li>
<li>before invoke onItemClickedListener, onTouchEvent will make sure that child.hasFocusable() is false
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-1-2-2" class="outline-5">
<h5 id="sec-1-1-2-2"><span class="section-number-5">1.1.2.2</span> ViewGroup.onInterceptTouchEvent &amp; mMotionTarget &amp; requestDisallowInterceptTouchEvent</h5>
</div>
<div id="outline-container-sec-1-1-2-3" class="outline-5">
<h5 id="sec-1-1-2-3"><span class="section-number-5">1.1.2.3</span> Outside Touch</h5>
<div class="outline-text-5" id="text-1-1-2-3">
</div><ol class="org-ol"><li>WindowManager.LayoutParams.FLAG<sub>WATCH</sub><sub>OUTSIDE</sub><sub>TOUCH</sub><br  /></li>
<li>MotionEvent.ACTION<sub>OUTSIDE</sub><br  /></li>
<li>example<br  /><ol class="org-ol"><li>Dialog.setCanceledOnTouchOutside<br  /></li>
<li>PopupWindow.isOutsideTouchable<br  /></li></ol>
</li></ol>
</div>

<div id="outline-container-sec-1-1-2-4" class="outline-5">
<h5 id="sec-1-1-2-4"><span class="section-number-5">1.1.2.4</span> Multiple Touch (多点触摸)</h5>
<div class="outline-text-5" id="text-1-1-2-4">
<ul class="org-ul">
<li>ACTION<sub>POINTER</sub><sub>DOWN</sub>
</li>
<li>ACTION<sub>POINTER</sub><sub>UP</sub>
</li>
<li>getPointerId(index)
</li>
<li>findPointerIndex(pointerId)
</li>
<li>getPointerCount()
</li>
<li>getActionMasked
</li>
<li>ACTION<sub>MASK</sub>
</li>
<li>getActionIndex();
</li>
<li>ACTION<sub>POINTER</sub><sub>INDEX</sub><sub>MASK</sub>
</li>
<li>ACTION<sub>POINTER</sub><sub>INDEX</sub><sub>SHIFT</sub>
</li>
</ul>


<ol class="org-ol">
<li>在任何时候, 一个 MotionEvent 都会包含当前所有 pointer 的信息 (例如
x,y, pointer<sub>id</sub>)
</li>

<li>当多点触摸时, 第一个点之外的其他点会触发 ACTION<sub>POINTER</sub><sub>DOWN</sub>/UP, 而
不是 ACTION<sub>DOWN</sub>/UP, ACTION<sub>POINTER</sub><sub>DOWN</sub>/UP 需要用 getActionMasked
才能获得, 因为这种 ACTION 实际上是 index|action, 需要把 index mask
掉. 另外, 所有点 move 时都触发 ACTION<sub>MOVE</sub>, 没有 ACTION<sub>POINTER</sub><sub>MOVE</sub>.
</li>
</ol>
</div>

<ol class="org-ol"><li>情景<br  /><div class="outline-text-6" id="text-1-1-2-4-1">
<ul class="org-ul">
<li>第一个点 down
触发 ACTION<sub>DOWN</sub>, pointerCount 为 1.
</li>

<li>第一个点保持不动, 按下第二个点
触发 ACTION<sub>POINTER</sub><sub>DOWN</sub> (通过 getActionMasked 获知), 且其
getActionIndex 返回 1. pointerCount 为 2.
</li>

<li>第一个点不动, 移动第二个点
触发一次 ACTION<sub>MOVE</sub>, pointerCount 为 2, 通过 getX(index) 可以获得两
个点的位置.
</li>

<li>第二个点不动, 抬起第一个点
触发一次 ACTION<sub>POINTER</sub><sub>UP</sub>, getActionIndex 返回 0, pointerCount 为
2, getPointerId(0) 返回 0;
</li>

<li>抬起第二个点

<p>
触发一次 ACTION<sub>UP</sub>, getActionIndex 返回 0, pointerCount 为 1,
getPointerId (0) 返回 1;
</p>
</li>
</ul>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Lower Level (below ViewRoot)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
有最重要的几点需要明确:
</p>

<ol class="org-ol">
<li>InputReader 使用 epoll 监听 EventHub 维护的多个输入设备.
</li>

<li>InputDispatcher, InputChannel 都使用了 Looper 进行高效的事件通知.

<ol class="org-ol">
<li>C++ Looper 的实现十分高效 (通过 epoll, pipe, &#x2026;, 而不是通过线程同
步原语)
</li>
</ol>
</li>

<li>InputEvent 是通过 ViewRoot 提供的 InputChannel 直接由 InputDispatcher 传
递给当前有焦点的进程的 ViewRoot, 并没有通过 WMS 中转, 以便提高效率.
不过 WMS 会负责通知 InputDispatcher 当前哪个 InputChannel 获得焦点.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</li>

<li>在 dispatch 给 ViewRoot 之前, PhoneWindowManager 有机会通过.
InputDispatcher.interceptKeyBeforeQueueing/Dispatching 来处理系统硬
键, 如 HOME, POWERKEY, MENU, VOLUME, SEARCH, &#x2026;
</li>
</ol>

<pre class="example">
                  +--------------+    +--------------+   +--------------+
                  | /dev/input/1 |    | /dev/input/2 |   | /dev/input/3 |
                  +-----------+--+    +------+-------+   +-------+------+
                              |              |                   |
                              |       +------+---+               |
                              +-------+ EventHub +---------------+
                                      +-----+----+
                                            |   +---------------+
                                            |   v     epoll     |
     +--------------------+        +--------+---+--------+      |
     | ViewRoot.addWindow |        |  InputReaderThread  +------+
     +------+-------------+        +--------+------------+
            |                 notify_key... |   +----------------+
            v              notify_motion... v   v looper.poll    |
+-----------+--------------+       +--------+---+-----------+    |
| WMS.registerInputChannel +-------+  InputDispatcherThread +----+
+--------------------------+       +--------+---------------+
                                            |
                                            |
                                    +-------+---------------------------------------------------+
                                    | PhoneWindowManager.interceptKeyBeforeQueueing/Dispatching |
                                    +-------+---------------------------------------------------+
                                            | find the InputChannel that has focus or touched
                           write to pipe    |    (findTouchedWindowAtLocked | findFocusedWindowTargetsLocked)
                                            | 唤醒应用一侧的 looper (通过向 pipe 一端写入数据)
                                    +-------+------------+
                                    | Looper in ViewRoot |&lt;--+
                                    +-------+------------+   | looper.poll
                                            |                |
                                            +----------------+
                                            | NativeInputEventReceiver::handleEvent (NativeInputEventReceiver 是 loop 的 callback)
                                   +--------+------------------------+
                                   | InputEventReceiver.onInputEvent |
                                   +---------------------------------+
</pre>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> C++</h4>
<div class="outline-text-4" id="text-1-2-1">
</div><div id="outline-container-sec-1-2-1-1" class="outline-5">
<h5 id="sec-1-2-1-1"><span class="section-number-5">1.2.1.1</span> EventHub</h5>
</div>
<div id="outline-container-sec-1-2-1-2" class="outline-5">
<h5 id="sec-1-2-1-2"><span class="section-number-5">1.2.1.2</span> InputReader</h5>
</div>
<div id="outline-container-sec-1-2-1-3" class="outline-5">
<h5 id="sec-1-2-1-3"><span class="section-number-5">1.2.1.3</span> InputDispatcher</h5>
<div class="outline-text-5" id="text-1-2-1-3">
<ul class="org-ul">
<li>Looper
</li>
<li>interceptKeyBeforeQueueing
</li>
<li>interceptKeyBeforeDispatching
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-1-4" class="outline-5">
<h5 id="sec-1-2-1-4"><span class="section-number-5">1.2.1.4</span> InputManagerService</h5>
</div>
<div id="outline-container-sec-1-2-1-5" class="outline-5">
<h5 id="sec-1-2-1-5"><span class="section-number-5">1.2.1.5</span> InputEventReceiver</h5>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> Java</h4>
<div class="outline-text-4" id="text-1-2-2">
</div><div id="outline-container-sec-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1"><span class="section-number-5">1.2.2.1</span> InputManagerService</h5>
</div>
<div id="outline-container-sec-1-2-2-2" class="outline-5">
<h5 id="sec-1-2-2-2"><span class="section-number-5">1.2.2.2</span> InputEventReceiver &amp; InputChannel</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<p>
InputEventReceiver.onInputEvent() 是 ViewRoot 一侧 event dispatch 的起点.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2-3" class="outline-5">
<h5 id="sec-1-2-2-3"><span class="section-number-5">1.2.2.3</span> InputMonitor</h5>
</div>
<div id="outline-container-sec-1-2-2-4" class="outline-5">
<h5 id="sec-1-2-2-4"><span class="section-number-5">1.2.2.4</span> InputFilter</h5>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> InputChannel 的注册过程</h4>
<div class="outline-text-4" id="text-1-2-3">
<ol class="org-ol">
<li>ViewRootImpl.setView 时, 会先生成一个 InputChannel, 并使用这个
InputChannel 生成一个 InputEventReceiver

<ol class="org-ol">
<li>InputEventReceiver 初始化时会调用到 NativeInputEventReceiver 的相关
代码, 最终会通过 Looper.addFd 将 InputChannel 对应的 fd 添加到
looper, 并且其对应的 callback 就是 NativeInputEventReceiver.handleEvent
</li>
</ol>
</li>

<li>ViewRootImpl.setView 会再调用 WMS.addView (InputChannel)
</li>

<li>WMS.addView 会先生成一对 InputChannel (即一个管道), 然后将
ViewRootImpl 传来的 InputChannel transferTo 到
InputChannelPair<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>, 然后将 InputChannelPair<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> 注册到 InputManagerService.
</li>

<li>最终, 当 InputManagerService 一侧的 InputChannel 被 write 时,
ViewRootImpl 一侧的 InputChannel 就会有反应, 其 InputEventReceiver
中的相关函数 (如 onInputEvent 就会被调用), 这个过程是
InputManagerService 直接通过 Looper 通知 ViewRoot 的.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> To summarize</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>InputReader, InputDispatcher, InputEventReceiver, InputChannel 以及
Looper 是整个 event dispatching 中比较重要的部分.
</li>

<li>以一次 event dispatching 为例, 会涉及到三次 pollOnce, 两个 looper
<ol class="org-ol">
<li>InputReader 通过 pollOnce 在 EventHub 上监听事件
</li>
<li>InputReader 和 InputDispatcher 通过一个 looper 进行生产/消费的通知
</li>
<li>ViewRootImpl 一侧通过 InputEventReceiver 注册的本进程的 looper 来
响应 InputChannel 的通知, 处理事件.
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Event Dispatching ANR</h3>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 再看 Looper</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> Java Looper vs. C++ Looper</h4>
<div class="outline-text-4" id="text-1-4-1">
<pre class="example">
                                                          |
                                                Java      |    C++
+---------+                                               |
| Handler +--------+                                      |
+---------+        |                                      |
                   |                                      |
+---------+        |   +--------+    +--------------+     |     +--------------------+  +--------+
| Handler +--------+---+ Looper +----+ MessageQueue +-----+-----+ NativeMessageQueue +--+ Looper |
+---------+        |   +--------+    +--------------+     |     +--------------------+  +--------+
                   |                                      |
+---------+        |                                      |
| Handler +--------+                                      |
+---------+                                               |
                                                          |
                                                          |
</pre>


<ul class="org-ul">
<li>Java Looper (及其 Handler, Message) 与 C++ Looper (及其 Message,
MessageHandler) 并没有直接的关系, 而且,令人不解的是, Java looper 和
C++ looper 的许多代码, 例如, Java looper 的 enqueueMessage vs. C++
looper 的 sendMessage, 以及 Java looper 的 MessageQueue.next
vs. C++ looper 的 pollOnce 等, 都是很类似的&#x2026;.即 Java looper 与
C++ looper 对消息的收,发,处理都是独立的代码&#x2026;.Java looper 并不是对
C++ looper 的封装.
</li>

<li>Java looper 与 C++ looper 的唯一联系, 是 MessageQueue &lt;&#x2014;&gt;
NativeMessageQueue, 但 Java MessageQueue 与 NativeMessageQueue 的功
能也很有限, 只是借用了 C++ looper 高效的 pollOnce 和 wake 机制.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> C++ Looper</h4>
<div class="outline-text-4" id="text-1-4-2">
</div><div id="outline-container-sec-1-4-2-1" class="outline-5">
<h5 id="sec-1-4-2-1"><span class="section-number-5">1.4.2.1</span> Looper.sendMessage</h5>
</div>
<div id="outline-container-sec-1-4-2-2" class="outline-5">
<h5 id="sec-1-4-2-2"><span class="section-number-5">1.4.2.2</span> Looper.pollOnce &amp; wake</h5>
<div class="outline-text-5" id="text-1-4-2-2">
</div><ol class="org-ol"><li>pollOnce<br  /><div class="outline-text-6" id="text-1-4-2-2-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">Looper</span>::pollOnce(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">timeoutMillis</span>, <span style="color: #b58900;">int</span>* outFd, <span style="color: #b58900;">int</span>* outEvents, <span style="color: #b58900;">void</span>** outData) {
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = 0;
    <span style="color: #859900;">for</span> (;;) {
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#39318;&#20808;, &#20808;&#36820;&#22238;&#19978;&#19968;&#27425; for (;;) &#24490;&#29615; &#22788;&#29702;&#36807;&#30340;&#20854;&#20182;&#36890;&#36807; addFd() &#28155;&#21152;&#30340; fd</span>
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#19978;&#30340;&#20107;&#20214;, &#19968;&#27425;&#36820;&#22238;&#19968;&#20214;.</span>
        <span style="color: #859900;">while</span> (mResponseIndex &lt; mResponses.size()) {
            <span style="color: #859900;">const</span> <span style="color: #b58900;">Response</span>&amp; response = mResponses.itemAt(mResponseIndex++);
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ident</span> = response.request.ident;
            <span style="color: #859900;">if</span> (ident &gt;= 0) {
                <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fd</span> = response.request.fd;
                <span style="color: #b58900;">int</span> <span style="color: #268bd2;">events</span> = response.events;
                <span style="color: #b58900;">void</span>* data = response.request.data;
                #<span style="color: #859900;">if</span> DEBUG_POLL_AND_WAKE
                    ALOGD(<span style="color: #2aa198;">"%p ~ pollOnce - returning signalled identifier %d: "</span>
                          <span style="color: #2aa198;">"fd=%d, events=0x%x, data=%p"</span>,
                          <span style="color: #859900;">this</span>, ident, fd, events, data);
                #endif
                    <span style="color: #859900;">if</span> (outFd != NULL) *outFd = fd;
                <span style="color: #859900;">if</span> (outEvents != NULL) *outEvents = events;
                <span style="color: #859900;">if</span> (outData != NULL) *outData = data;
                <span style="color: #859900;">return</span> ident;
            }
        }

        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">result != 0 &#30340;&#21028;&#26029;&#21487;&#20197;&#20351;&#29992; pollInner &#25191;&#34892;&#19988;&#21482;&#25191;&#34892;&#19968;&#27425;</span>
        <span style="color: #859900;">if</span> (result != 0) {
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#36825;&#37324;&#34920;&#31034;&#25152;&#26377; addFd &#28155;&#21152;&#30340; fd &#19978;&#30340;&#20107;&#20214;&#37117;&#25253;&#21578;&#23436;&#27605;, &#29616;&#22312;&#25253;</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#21578;&#30340;&#26159; waitPipeFd &#19978;&#30340; message &#20107;&#20214;</span>
            #<span style="color: #859900;">if</span> DEBUG_POLL_AND_WAKE
                ALOGD(<span style="color: #2aa198;">"%p ~ pollOnce - returning result %d"</span>, <span style="color: #859900;">this</span>, result);
            #endif
                <span style="color: #859900;">if</span> (outFd != NULL) *outFd = 0;
            <span style="color: #859900;">if</span> (outEvents != NULL) *outEvents = 0;
            <span style="color: #859900;">if</span> (outData != NULL) *outData = NULL;
            <span style="color: #859900;">return</span> result;
        }

        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#19978;&#38754;&#30340;&#20195;&#30721;&#37117;&#21482;&#26159;&#21521;&#19978;&#23618;&#24050;&#22788;&#29702;&#30340;&#20107;&#20214;. pollInner &#25165;&#26159;&#30495;&#27491;&#22788;&#29702;</span>
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#20107;&#20214;</span>
        result = pollInner(timeoutMillis);
    }
}

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">Looper</span>::pollInner(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">timeoutMillis</span>) {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Adjust the timeout based on when the next message is due.</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">pollOnce &#34987;&#35843;&#29992;&#26102;&#36890;&#24120;&#20250;&#25351;&#23450;&#19968;&#20010;&#24456;&#22823;&#30340; timeout (&#20363;&#22914;</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">LONG_LONG_MAX), &#27492;&#26102;&#20250;&#26681;&#25454; mNextMessageUptime (&#26368;&#36817;&#30340;&#19968;&#20010;</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">message &#30340; uptime)&#35843;&#25972;&#19968;&#19979; timeout, &#20197;&#20415;&#36890;&#36807; epoll &#36229;&#26102;&#26469;&#21450;&#26102;&#30340;</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#22788;&#29702; pending message</span>

    <span style="color: #859900;">if</span> (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        <span style="color: #b58900;">nsecs_t</span> <span style="color: #268bd2;">now</span> = systemTime(SYSTEM_TIME_MONOTONIC);
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">messageTimeoutMillis</span> = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        <span style="color: #859900;">if</span> (messageTimeoutMillis &gt;= 0
            &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
    }

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Poll.</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = ALOOPER_POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;

    struct <span style="color: #b58900;">epoll_event</span> <span style="color: #268bd2;">eventItems</span>[EPOLL_MAX_EVENTS];
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">eventCount</span> = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Acquire lock.</span>
    mLock.lock();

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Check for poll timeout. &#36229;&#26102;</span>
    <span style="color: #859900;">if</span> (eventCount == 0) {
        result = ALOOPER_POLL_TIMEOUT;
        <span style="color: #859900;">goto</span> <span style="color: #2aa198;">Done</span>;
    }

    <span style="color: #859900;">for</span> (<span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; eventCount; i++) {
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fd</span> = eventItems[i].data.fd;
        <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">epollEvents</span> = eventItems[i].events;
            <span style="color: #859900;">if</span> (fd == mWakeReadPipeFd) {
                <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#26159;&#34987; pipe &#21796;&#37266;&#30340;, &#21017;&#35843;&#29992; awoken &#28040;&#32791;&#25481; fd &#20013;&#30340;&#25152;&#26377;&#20869;&#23481;. &#28982;&#21518;&#36716;&#21040; Done</span>
                <span style="color: #859900;">if</span> (epollEvents &amp; EPOLLIN) {
                    awoken();
                } <span style="color: #859900;">else</span> {
                    ALOGW(<span style="color: #2aa198;">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);
                }
            } <span style="color: #859900;">else</span> {
                <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#26159;&#34987; addFd &#20013; fd &#21796;&#37266;&#30340;, &#21017;&#26500;&#36896;&#19968;&#20010; response &#25918;&#21040;</span>
                <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">mResponse &#20013;, Done &#26102;&#20250;&#22788;&#29702;.</span>
                <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">requestIndex</span> = mRequests.indexOfKey(fd);
                <span style="color: #859900;">if</span> (requestIndex &gt;= 0) {
                    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">events</span> = 0;
                    <span style="color: #859900;">if</span> (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                    <span style="color: #859900;">if</span> (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                    <span style="color: #859900;">if</span> (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                    <span style="color: #859900;">if</span> (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                    pushResponse(events, mRequests.valueAt(requestIndex));
                } <span style="color: #859900;">else</span> {
                    ALOGW(<span style="color: #2aa198;">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span>
                          <span style="color: #2aa198;">"no longer registered."</span>, epollEvents, fd);
                }
            }
        }
<span style="color: #2aa198;">Done</span>: ;

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#20808;&#22788;&#29702;&#25152;&#26377; pending message</span>
    mNextMessageUptime = LLONG_MAX;
    <span style="color: #859900;">while</span> (mMessageEnvelopes.size() != 0) {
        <span style="color: #b58900;">nsecs_t</span> <span style="color: #268bd2;">now</span> = systemTime(SYSTEM_TIME_MONOTONIC);
        <span style="color: #859900;">const</span> <span style="color: #b58900;">MessageEnvelope</span>&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">mMessageEnvelopes &#26159;&#19968;&#20010; vector, &#20294;&#26159;&#26159;&#25353;&#29031; uptime &#26469;&#25490;&#24207;&#30340;.</span>
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#25152;&#26377;uptime &#23567;&#20110; now &#30340;&#20250;&#34987;&#22788;&#29702; (handleMessage),</span>
        <span style="color: #859900;">if</span> (messageEnvelope.uptime &lt;= now) {
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Remove the envelope from the list.</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">We keep a strong reference to the handler until the call to handleMessage</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">finishes.  Then we drop it so that the handler can be deleted *before*</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">we reacquire our lock.</span>
            { <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">obtain handler</span>
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                <span style="color: #b58900;">Message</span> <span style="color: #268bd2;">message</span> = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = <span style="color: #2aa198;">true</span>;
                mLock.unlock();

                #<span style="color: #859900;">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                                               ALOGD(<span style="color: #2aa198;">"%p ~ pollOnce - sending message: handler=%p, what=%d"</span>,
                                                     <span style="color: #859900;">this</span>, handler.get(), message.what);
                #endif
                    handler-&gt;handleMessage(message);
            } <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">release handler</span>

            mLock.lock();
            mSendingMessage = <span style="color: #2aa198;">false</span>;
            result = ALOOPER_POLL_CALLBACK;
        } <span style="color: #859900;">else</span> {
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">The last message left at the head of the queue</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">determines the next wakeup time.</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#35774;&#32622; mNextMessageUptime</span>
            mNextMessageUptime = messageEnvelope.uptime;
            <span style="color: #859900;">break</span>;
        }
    }

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Release lock.</span>
    mLock.unlock();

    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#22788;&#29702;&#25152;&#26377; reponse (handleEvent)</span>
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Invoke all response callbacks.</span>
    <span style="color: #859900;">for</span> (<span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = 0; i &lt; mResponses.size(); i++) {
        Response&amp; response = mResponses.editItemAt(i);
        <span style="color: #859900;">if</span> (response.request.ident == ALOOPER_POLL_CALLBACK) {
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fd</span> = response.request.fd;
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">events</span> = response.events;
            <span style="color: #b58900;">void</span>* data = response.request.data;
            #<span style="color: #859900;">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                                           ALOGD(<span style="color: #2aa198;">"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p"</span>,
                                                 <span style="color: #859900;">this</span>, response.request.callback.get(), fd, events, data);
            #endif
                <span style="color: #b58900;">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);
            <span style="color: #859900;">if</span> (callbackResult == 0) {
                removeFd(fd);
            }
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Clear the callback reference in the response structure promptly because we</span>
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">will not clear the response vector itself until the next poll.</span>
            response.request.callback.clear();
            result = ALOOPER_POLL_CALLBACK;
        }
    }
    <span style="color: #859900;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li>wake<br  /><div class="outline-text-6" id="text-1-4-2-2-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">Looper</span>::wake() {
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">nWrite</span>;
    <span style="color: #859900;">do</span> {
        nWrite = write(mWakeWritePipeFd, <span style="color: #2aa198;">"W"</span>, 1);
    } <span style="color: #859900;">while</span> (nWrite == -1 &amp;&amp; errno == EINTR);

    <span style="color: #859900;">if</span> (nWrite != 1) {
        <span style="color: #859900;">if</span> (errno != EAGAIN) {
            ALOGW(<span style="color: #2aa198;">"Could not write wake signal, errno=%d"</span>, errno);
        }
    }
}
</pre>
</div>
</div>
</li>

<li>To summarize<br  /><div class="outline-text-6" id="text-1-4-2-2-3">
<ul class="org-ul">
<li>pollOnce 运行一次会处理一批的 response (epoll<sub>wait</sub> 返回的所有
reponse) 和 message (根据各 message的 uptime 选择的 message)
</li>

<li>response 和 message 的处理过程不太一样:
<ol class="org-ol">
<li>response 通过 epoll<sub>wait</sub> 返回, 并且返回后一次性处理完.
</li>
<li>message 通过 SendMessageAtTime 可以暂存在 MessageEnvelope 中, 等
epoll<sub>wait</sub> 返回或超时时根据 uptime 选择性的处理
</li>
<li>sendMessageAtTime 通常不需要 wake poll, 除非是插到队头, 这里为了
及时响应这个 message, 会强制 wake poll.
</li>
</ol>
</li>
</ul>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> Java Looper</h4>
<div class="outline-text-4" id="text-1-4-3">
</div><div id="outline-container-sec-1-4-3-1" class="outline-5">
<h5 id="sec-1-4-3-1"><span class="section-number-5">1.4.3.1</span> Looper.postSyncBarrier</h5>
<div class="outline-text-5" id="text-1-4-3-1">
</div><ol class="org-ol"><li>MessageQueue.enqueueSyncBarrier<br  /><div class="outline-text-6" id="text-1-4-3-1-1">
<p>
syncBarrier 实际上就是一种特殊的 Message: 它的 tagetHandler 为 null,
当 MessageQueue 处理到这种 Message 时, 会停顿下来, 直到该 Message 被
removeSyncBarrier 移除. 但 asynchronous 的 Message 不受 syncBarrier 的
限制.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-4-3-2" class="outline-5">
<h5 id="sec-1-4-3-2"><span class="section-number-5">1.4.3.2</span> Message.setAsynchronous</h5>
<div class="outline-text-5" id="text-1-4-3-2">
<p>
Asynchronous Message 和 通信系统的 OOB 消息类似, 可以通知一些紧急情况,
因为它不受 syncBarrier 的限制, 可以保证在指定的时间一定会被处理. 但与
OOB 不同的是, 它并没有单独的通道, 即它要和其他 Message 一起排队.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
每次 WMS 的 WindowState 有变化时, 它就会调用:
</p>

<div class="org-src-container">

<pre class="src src-text">InputMonitor.updateInputWindowsLw ();
  ...
  InputDispatcher.setInputWindows();
</pre>
</div>

<p class="footpara">
来设置 InputDispatcher 的 input windows 的状态;
</p>

<p class="footpara">
Input windows 被设置后, InputDispatcher 的
findFocusedWindowTargetsLocked 或 findTouchedWindowAtLocked 会根据
input windows 的状态, 选择合适的 InputWindowHandle, 最终找到对应的
InputChannel.
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: wei.sun</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-07-01 Tue 10:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
