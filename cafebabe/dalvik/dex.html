<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Dex</title>
<!-- 2014-09-26 Fri 10:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Dex</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Dex</a>
<ul>
<li><a href="#sec-1-1">1.1. dex 文件结构</a></li>
<li><a href="#sec-1-2">1.2. odex 文件结构</a></li>
<li><a href="#sec-1-3">1.3. class 文件结构</a></li>
<li><a href="#sec-1-4">1.4. DexFile 与 DvmDex</a></li>
<li><a href="#sec-1-5">1.5. dexopt</a></li>
<li><a href="#sec-1-6">1.6. load</a></li>
<li><a href="#sec-1-7">1.7. verify</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Dex</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> dex 文件结构</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<a href="http://www.retrodev.com/android/dexformat.html">http://www.retrodev.com/android/dexformat.html</a>
<a href="http://stackoverflow.com/questions/7750448/dex-file-in-android">http://stackoverflow.com/questions/7750448/dex-file-in-android</a>
<a href="http://source.android.com/devices/tech/dalvik/dex-format.html">http://source.android.com/devices/tech/dalvik/dex-format.html</a>
<a href="http://blog.csdn.net/hlchou/article/details/6303566">http://blog.csdn.net/hlchou/article/details/6303566</a>
<a href="http://www.2cto.com/Article/201308/236054.html">http://www.2cto.com/Article/201308/236054.html</a>
</p>

<p>
dex 文件主要由一个 dex header, 多个表(ids, defs)和数据 (data) 部分组成.
构成一个复杂的索引关系, 这些表和数据的位置大约是:
</p>

<ol class="org-ol">
<li>dex header
</li>
<li>dex string ids
</li>
<li>dex type ids
</li>
<li>dex field ids
</li>
<li>dex method ids                 o
</li>
<li>dex class defs
</li>
<li>data
</li>
<li>dex map list
</li>
</ol>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> dex header</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
dex header 中主要下面提到的各个 ids, defs 的 size 和 offset, 以便能找
到这些 table, 例如:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">header_item</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">dex_magic</span> {
        <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">dex.. </span><span style="color: #586e75; font-style: italic;">*/</span>
    };
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">checksum</span>;
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">signature</span>[20];
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">file_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">header_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">endian_tag</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">link_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">link_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">map_off</span>;               <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">map list offset </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">string_ids_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">string_ids_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">type_ids_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">type_ids_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">proto_ids_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">proto_ids_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">field_ids_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">field_ids_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">method_ids_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">mehtod_ids_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">class_defs_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">class_defs_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">data_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">data_off</span>;              <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">data_off &#21487;&#33021;&#20027;&#35201;&#29992;&#26469;&#26816;&#26597; </span><span style="color: #586e75; font-style: italic;">*/</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> dex string ids</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">string_id_list</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">string_id_item</span> {
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">string_data_off</span>;
    } [string_ids_size];
};
</pre>
</div>

<p>
通过这个 string<sub>data</sub><sub>off</sub>, 可以在 data 部分找到这个 string 对应的
string<sub>item</sub> 结构.
</p>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> dex type ids</h4>
<div class="outline-text-4" id="text-1-1-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">type_id_list</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">type_id_item</span> {
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">descriptor_idx</span>;    <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; string_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
    } [type_ids_size];
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> dex proto ids</h4>
<div class="outline-text-4" id="text-1-1-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">proto_id_list</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">proto_id_item</span> {
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">shorty_idx</span>;            <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; string_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">reture_type_idx</span>;       <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">unit</span> <span style="color: #268bd2;">parameters_off</span>;
    } [proto_ids_size];
};
</pre>
</div>
</div>


<div id="outline-container-sec-1-1-4-1" class="outline-5">
<h5 id="sec-1-1-4-1"><span class="section-number-5">1.1.4.1</span> prarameters<sub>off</sub></h5>
<div class="outline-text-5" id="text-1-1-4-1">
<p>
parameters<sub>off</sub> 表示该函数的参数情况, 指向 data 部分的一个
type<sub>item</sub><sub>list</sub> 结构
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">type_item_list</span> {
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">size</span>;                  <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">&#21442;&#25968;&#30340;&#20010;&#25968; </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">type_item</span> [size];
};
<span style="color: #859900;">struct</span> <span style="color: #b58900;">type_item</span> {
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">type_idx</span>;            <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">&#25351;&#21521; string ids </span><span style="color: #586e75; font-style: italic;">*/</span>
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> dex field ids</h4>
<div class="outline-text-4" id="text-1-1-5">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">field_id_list</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">field_id_item</span> {
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">class_idx</span>;             <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">type_idx</span>;              <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">name_idx</span>;              <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; string_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
    } [field_ids_size];
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-6" class="outline-4">
<h4 id="sec-1-1-6"><span class="section-number-4">1.1.6</span> dex method ids</h4>
<div class="outline-text-4" id="text-1-1-6">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">method_id_list</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">method_id_item</span> {
        <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">class_idx</span>;           <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">proto_idx</span>;           <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; proto_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">name_idx</span>;              <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; string_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
    } [method_ids_size];
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-7" class="outline-4">
<h4 id="sec-1-1-7"><span class="section-number-4">1.1.7</span> dex class defs</h4>
<div class="outline-text-4" id="text-1-1-7">
<p>
class defs 是这些表中是复杂的一个表.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">class_def_item_list</span> {
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">class_def_item</span> {
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">class_idx</span>;             <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #859900;">enum</span> <span style="color: #b58900;">ACCESS_FLAGS</span>;
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">superclass_idx</span>;        <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">interface_off</span>;
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">source_file_idx</span>;       <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; string_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">annotation_off</span>;
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">class_data_off</span>;
        <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">static_value_off</span>;
    } [class_defs_size];
};
</pre>
</div>

<p>
与 string<sub>id</sub><sub>item</sub> 中的 string<sub>data</sub><sub>off</sub> 及 proto<sub>id</sub><sub>item</sub> 中的
parameters<sub>off</sub> 类似, class<sub>def</sub><sub>item</sub> 中包含四项 off 也存在到 data 部分,
</p>
</div>


<div id="outline-container-sec-1-1-7-1" class="outline-5">
<h5 id="sec-1-1-7-1"><span class="section-number-5">1.1.7.1</span> interface<sub>off</sub></h5>
<div class="outline-text-5" id="text-1-1-7-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">type_item_list</span> {
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">size</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">type_item</span>[size];
};

<span style="color: #859900;">struct</span> <span style="color: #b58900;">type_item</span> {
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">type_index</span>;          <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; type_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-7-2" class="outline-5">
<h5 id="sec-1-1-7-2"><span class="section-number-5">1.1.7.2</span> static<sub>value</sub><sub>off</sub></h5>
</div>

<div id="outline-container-sec-1-1-7-3" class="outline-5">
<h5 id="sec-1-1-7-3"><span class="section-number-5">1.1.7.3</span> class<sub>data</sub><sub>off</sub></h5>
<div class="outline-text-5" id="text-1-1-7-3">
<p>
class<sub>data</sub><sub>off</sub> 是 class<sub>def</sub><sub>item</sub> 中最复杂的.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">class_data_item</span> {
    <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">static_fields_size</span>;
    <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">instance_fields_size</span>;
    <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">direct_methods_size</span>;
    <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">virtual_methods_size</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_field_list</span> {
        <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_field</span> {
            <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">field_idx_diff &#19982;&#21069;&#38754;&#25552;&#21040;&#30340; xxx_idx &#19981;&#21516;:</span>
<span style="color: #586e75; font-style: italic;">               actual_idx[i]= sum_{0}^{i}(field_idx_diff[x]d(x))</span>
<span style="color: #586e75; font-style: italic;">             ,</span><span style="color: #586e75; font-style: italic;">*/</span>
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">field_idx_diff</span>; <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; field_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
        } [static_fields_size];
    } <span style="color: #268bd2;">static_fields</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_field_list</span> {
        <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_field</span> {
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">field_idx_diff</span>; <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; field_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">access_flags</span>;
        } [instance_fields_size];
    } <span style="color: #268bd2;">instance_fields</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_methods_list</span> {
        <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_method</span> {
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">method_idx_diff</span>; <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; method_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">access_flags</span>;
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">code_off</span>;
        } [direct_methods_size];
    } <span style="color: #268bd2;">direct_methods</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_methods_list</span> {
        <span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_method</span> {
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">method_idx_diff</span>; <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">=&gt; method_id_item </span><span style="color: #586e75; font-style: italic;">*/</span>
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">access_flags</span>;
            <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">code_off</span>;
        } [virtual_methods_size];
    } <span style="color: #268bd2;">virtual_methods</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li>code off<br  /><div class="outline-text-6" id="text-1-1-7-3-1">
<p>
encoded<sub>method</sub> 中包含一个 code<sub>off</sub> 的指针, 指向真正的 code<sub>item</sub>
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">code_item</span> {
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">register_size</span>;       <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">&#20351;&#29992;&#22810;&#23569;&#20010; register, &#21253;&#25324;&#21442;&#25968;, &#23616;&#22495;</span>
<span style="color: #586e75; font-style: italic;">                                 * &#21464;&#37327;&#31561; </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">ins_size</span>;            <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">&#21442;&#25968;&#29992;&#21040;&#30340; register &#20010;&#25968; </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">outs_size</span>;           <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">&#35843;&#29992;&#20854;&#20182;&#20989;&#25968;&#38656;&#35201;&#29992;&#21040;&#30340; register &#20010;</span>
<span style="color: #586e75; font-style: italic;">                                 * &#25968; </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">tries_size</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">debug_info_off</span>;
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">insns_size</span>;            <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">instruction size, &#20197; 16 bits &#20026;&#21333;&#20301; </span><span style="color: #586e75; font-style: italic;">*/</span>
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">insns</span>[insns_size];   <span style="color: #586e75; font-style: italic;">/*  </span><span style="color: #586e75; font-style: italic;">&#30495;&#27491;&#30340; byte code</span><span style="color: #586e75; font-style: italic;">*/</span>
};
</pre>
</div>
<p>
如果 tries<sub>size</sub> 不为 0, 则 insns 后还会有另两部分和 exception 相关的内
容:
</p>
<ol class="org-ol">
<li>try<sub>item</sub><sub>list</sub>
</li>
<li>encoded<sub>catch</sub><sub>handler</sub><sub>list</sub>
</li>
</ol>

<p>
这两个 list 对应着 exception table.
</p>

<p>
其中 tries<sub>item</sub> 为:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">try_item</span> {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">catcher &#23545;&#24212;&#30340; start_addr</span>
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">start_addr</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">catcher &#23545;&#24212;&#30340; end_addr &#20026; start_addr + insn_count</span>
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">insn_count</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">catcher &#30340;&#20301;&#32622;. &#20197;&#19978;&#19977;&#20010;&#20540;&#37117;&#26159;&#24403;&#21069; method &#20013;&#30340;&#30456;&#23545;&#22320;&#22336;</span>
    <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">handler_off</span>;
}
</pre>
</div>

<p>
根据 handler<sub>off</sub> 可以找到 encoded<sub>catch</sub><sub>handler</sub>, encoded<sub>catch</sub><sub>handler</sub>
结构比较啰嗦, 但基本信息为:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">encoded_type_addr_pair</span> {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">catcher &#35201; catch &#30340;&#24322;&#24120;&#30340;&#31867;&#22411;</span>
    <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">type_idx</span>;
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">catcher &#30340;&#20195;&#30721;, &#20063;&#26159;&#30456;&#23545;&#22320;&#22336;</span>
    <span style="color: #b58900;">uleb128</span> <span style="color: #268bd2;">addr</span>;
};
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-1-8" class="outline-4">
<h4 id="sec-1-1-8"><span class="section-number-4">1.1.8</span> dex map list</h4>
<div class="outline-text-4" id="text-1-1-8">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">map_list_type</span> {
    <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">size</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">map_item_list</span> {
        <span style="color: #859900;">struct</span> <span style="color: #b58900;">map_item</span> {
            <span style="color: #859900;">enum</span> <span style="color: #b58900;">type</span>;
            <span style="color: #b58900;">ushort</span> <span style="color: #268bd2;">unused</span>;
            <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">size</span>;
            <span style="color: #b58900;">uint</span> <span style="color: #268bd2;">offset</span>;
        } [size];
    };
};
</pre>
</div>

<p>
`This is a list of the entire contents of a file, in order. It contains
some redundancy with respect to the header<sub>item</sub> but is intended to be
an easy form to use to iterate over an entire file.`
</p>

<p>
map<sub>list</sub> 中保存着许多不同类型的 entry 对应的 offset, 与 header<sub>item有些重复</sub>,
例如以下类型的 entry 在 header<sub>item</sub> 中也是存在的
</p>

<ul class="org-ul">
<li>TYPE<sub>TYPE</sub><sub>ID</sub><sub>ITEM</sub>
</li>
<li>TYPE<sub>PROTO</sub><sub>ID</sub><sub>ITEM</sub>
</li>
<li>TYPE<sub>FIELD</sub><sub>ID</sub><sub>ITEM</sub>
</li>
<li>&#x2026;
</li>
</ul>

<p>
但它也可以包含以下类型:
</p>

<ul class="org-ul">
<li>TYPE<sub>CLASS</sub><sub>DATA</sub><sub>ITEM</sub>
</li>
<li>TYPE<sub>CODE</sub><sub>ITEM</sub>
</li>
<li>TYPE<sub>STRING</sub><sub>DATA</sub><sub>ITEM</sub>
</li>
<li>&#x2026;
</li>
</ul>

<p>
这些数据在 header<sub>item</sub> 是不存在的, 以 CLASS<sub>DATA</sub><sub>ITEM</sub> 为例, 如果不使用
中 map<sub>list</sub>, 必须通过 header<sub>item</sub> -&gt; class<sub>def</sub><sub>item</sub> -&gt; class<sub>data</sub><sub>item</sub>
这条路径才能找到. 有了 map<sub>list</sub>, 代码可以用一种更简单一致的方法来遍历
整个 dex 文件.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> odex 文件结构</h3>
<div class="outline-text-3" id="text-1-2">
<p>
odex 文件对 dex 做了如下的修改:
</p>
<ol class="org-ol">
<li>文件开头加入一个 odex header
</li>
<li>dex 文件本身会被修改, 例如 xxx =&gt; xxx<sub>quick</sub>
</li>
<li>在文件末尾加入两个数据结构: classLookup 与 registerMapPool
</li>
</ol>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> classLookup</h4>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> registerMap</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
register map 主要用来帮助 dvm 知道在每个函数的每个 GC Point 处当前各个
寄存器中哪些保存着 java 对象.以便进行 exact GC. register map 导致 odex
比 dex 大了 9% 左右. 
</p>

<p>
在 Hotspot 中, 也有一个类似的结构称为 OopMap
</p>

<p>
若没有这个 map, 则 GC 只能进行 conservative GC, 即 GC 时 dvm 只能假设当
前所有寄存器中都保存着对象引用, 从而导致一些本来已经是 garbage 的对象没
有被回收. (例如 r1 本来保存着一个整数 0xxxxx, 但这个整数刚好对应着某个
已经不可达的对象的地址, 那么这个对象就会被重新标记为可达).
</p>

<p>
conservative GC 可能通过堆内存上下界检查, 对齐检查 (java 对象都是 8 字
节对齐) 等方法过滤掉一些明显不可能是引用的值. 但它相对于 exact GC 还是
有两方面明显的问题:
</p>
<ol class="org-ol">
<li>某些对象不会被回收, 导致内存压力
</li>
<li>无法支持 copying GC.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> class 文件结构</h3>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> DexFile 与 DvmDex</h3>
<div class="outline-text-3" id="text-1-4">
<p>
dalvik 在扫描 class path 时, 会负责将所有的 odex 文件 parse 一遍. parse
的过程基本是:
</p>

<ol class="org-ol">
<li>通过 mmap 将 odex 映射到内存 A
</li>
<li>生成 DexFile 结构, 将其成员设置为到 A 各个区域的指针
</li>
</ol>

<div class="org-src-container">

<pre class="src src-text">pDexFile-&gt;pStringIds = (const DexStringId*) (A + pHeader-&gt;stringIdsOff);
pDexFile-&gt;pTypeIds = (const DexTypeId*) (A + pHeader-&gt;typeIdsOff);
pDexFile-&gt;pFieldIds = (const DexFieldId*) (A + pHeader-&gt;fieldIdsOff);
pDexFile-&gt;pMethodIds = (const DexMethodId*) (A + pHeader-&gt;methodIdsOff);
pDexFile-&gt;pProtoIds = (const DexProtoId*) (A + pHeader-&gt;protoIdsOff);
pDexFile-&gt;pClassDefs = (const DexClassDef*) (A + pHeader-&gt;classDefsOff);
pDexFile-&gt;pLinkData = (const DexLink*) (A + pHeader-&gt;linkOff);
</pre>
</div>

<ol class="org-ol">
<li>生成 DvmDex 结构

<p>
这个结构实际就是 procmem 时显示的 "dalvik-aux-structure".
这是一个辅助的数据结构: 因为 DexFile 基本是直接映射了 odex 文件, 里
面的内容都是一些 "ID", 但实际执行时程序需要的通常不是 "ID", 而是真
正的内容, 这时 DvmDex 相当于一个将 "ID" 映射为真正内容的一个 cache.
</p>

<p>
以 dvmResolveClass 为例:
</p>

<div class="org-src-container">

<pre class="src src-text">dvmResolveClass
  resClass = dvmDexGetResolvedClass(pDvmDex, classIdx);
    return pDvmDex-&gt;pResClasses[classIdx];
  if (resClass != NULL):
    return resClass;
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> dexopt</h3>
<div class="outline-text-3" id="text-1-5">
<p>
dexopt is located in dalvik/dexopt/OptMain.cpp
</p>
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> dexopt 的作用</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>verification
</li>

<li>optimization
/dalvik/vm/analysis/Optimize.cpp::optimizeMethod

<ol class="org-ol">
<li>quick替换 与 符号解析

<p>
将本来 java 在类加载时完成的符号解析的工作拿出来,提前将符号解析出
来, 并且使用相应的 `quick' 指令代替原来的基于常量池符号引用的指令,
例如: 将之前的
</p>

<pre class="example">
invoke-virtual {v0,v1},Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V
</pre>

<p>
替换为
</p>

<pre class="example">
invoke-virtual-quick {v0,v1},vtable #0x3b
</pre>
</li>

<li>inline method
</li>

<li>&#x2026;
</li>
</ol>
</li>

<li>register map
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> There are three ways to launch dexopt</h4>
<div class="outline-text-4" id="text-1-5-2">
<ol class="org-ol">
<li>From the VM.  This takes a dozen args, one of which is a file
descriptor that acts as both input and output.  This allows us to
remain ignorant of where the DEX data originally came from.
</li>

<li>From installd or another native application.  Pass in a file
descriptor for a zip file, a file descriptor for the output, and a
filename for debug messages.  Many assumptions are made about
what's going on (verification + optimization are enabled, boot
class path is in BOOTCLASSPATH, etc).
</li>

<li>On the host during a build for preoptimization. This behaves almost
the same as (2), except it takes file names instead of file
descriptors.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> dex 何时被 dexopt</h4>
<div class="outline-text-4" id="text-1-5-3">
<ol class="org-ol">
<li>zygote 启动时
zygote 启动时会负责 boot class 的 dexopt (通过 dvmClassStartup -&gt;
prepareCpe -&gt; dvmRawDexFileOpen)
</li>
<li>PMS.performBootDexOpt
PMS 启动时
</li>
<li>AMS.ensurePackageDexOpt
AMS启动应用之前
</li>
<li>dvmRawDexFileOpen
ClassLoader 初始化时
</li>
<li>app 被安装时
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> load</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> ClassLoader</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
ClassLoader 并不是一定要在 native 实现的, 有些 ClassLoader 是完全用
Java 写的. 但 dalvik 的 ClassLoader 因为底层都依赖于 dex, 所以都是通过
native 层的 DexFile (代表 dex), RawDexFile (代表 odex), DvmDex (代表
auxiliary cache) 实现的.
</p>

<p>
Java 层和 ClassLoader 相关的类主要有:
</p>

<ol class="org-ol">
<li>VMClassLoader
</li>
<li>ClassLoader
</li>
<li>BootClassLoader
</li>
<li>BaseDexClassLoader
</li>
<li>PathClassLoader
</li>
</ol>


<pre class="example">
                 -+-------------+
                  | ClassLoader |
                 -+-----+-------+
                        |
                        |
          -+------------+-----------------+
           |                              |
           |                              |
    -+-----+-----------+          -+------+-------------+
     | BootClassLoader |           | BaseDexClassLoader |
    -+-----+-----------+          -+------+-------------+
           |                              |
 comp      |                       comp   |
-+---------+-----+                -+------+---+
 | VMClassLoader |                 | DexFile  |
-+---------+-----+                -+------+---+
           |                              |
           |                              |
       native                         native
</pre>
</div>

<div id="outline-container-sec-1-6-1-1" class="outline-5">
<h5 id="sec-1-6-1-1"><span class="section-number-5">1.6.1.1</span> PathClassLoader</h5>
<div class="outline-text-5" id="text-1-6-1-1">
<p>
当 PathClassLoader 初始化时, 会初始化 DexFile, 相当的会设置对应的 odex 的路
径.
</p>

<ol class="org-ol">
<li>ContextImpl.getClassLoader 最终返回的是一个 PathClassLoader
</li>

<li>PathClassLoader的构造函数
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #268bd2;">PathClassLoader</span>(<span style="color: #b58900;">String</span> <span style="color: #268bd2;">dexPath</span>, <span style="color: #b58900;">ClassLoader</span> <span style="color: #268bd2;">parent</span>) {
    <span style="color: #859900;">super</span>(dexPath, <span style="color: #2aa198;">null</span>, <span style="color: #2aa198;">null</span>, parent);
}
</pre>
</div>

<p>
其中, 基类的第一个参数表示 apk/jar, 第二个参数表示
optimizedDirectory, 表示 odex 放置在哪里, 以后查找和生成 odex 时会使用
该目录, 若该参数为 null, 则表示使用默认的 `/data/dalvik-cache/`
</p>
</li>

<li>PathClassLoader 的基类: BaseDexClassLoader 的构造函数
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #268bd2;">BaseDexClassLoader</span>(<span style="color: #b58900;">String</span> <span style="color: #268bd2;">dexPath</span>, <span style="color: #b58900;">File</span> <span style="color: #268bd2;">optimizedDirectory</span>,
                          <span style="color: #b58900;">String</span> <span style="color: #268bd2;">libraryPath</span>, <span style="color: #b58900;">ClassLoader</span> <span style="color: #268bd2;">parent</span>) {
    <span style="color: #859900;">super</span>(parent);
    <span style="color: #859900;">this</span>.originalPath = dexPath;
    <span style="color: #859900;">this</span>.pathList =
        <span style="color: #859900;">new</span> <span style="color: #b58900;">DexPathList</span>(<span style="color: #859900;">this</span>, dexPath, libraryPath, optimizedDirectory);
}
</pre>
</div>

<p>
其中 optimizedDirectory 为 null, 表示使用默认的 `/data/dalvik-cache/`
</p>
</li>

<li>DexPathList 构造函数

<div class="org-src-container">

<pre class="src src-text">this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);
  dex = loadDexFile(file, optimizedDirectory);
    if (optimizedDirectory == null):
      return new DexFile(file);
        mCookie = openDexFile(sourceName, outputName, flags);
          Dalvik_dalvik_system_DexFile_openDexFile(const u4* args,)
            dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile,)
              if (odexOutputName == NULL):
                // &#29983;&#25104; odex &#23545;&#24212;&#30340;&#25991;&#20214;&#21517;.
                cachedName = dexOptGenerateCacheFileName(fileName,  NULL);
              optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,);
              ...
    else:
      String optimizedPath = optimizedPathFor(file, optimizedDirectory);
      return DexFile.loadDex(file.getPath(), optimizedPath, 0);
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-1-2" class="outline-5">
<h5 id="sec-1-6-1-2"><span class="section-number-5">1.6.1.2</span> BootClassLoader</h5>
<div class="outline-text-5" id="text-1-6-1-2">
<div class="org-src-container">

<pre class="src src-text">app_process.main()
  AndroidRuntime::start
    AndroidRuntime::startVM
      JNI_CreateJavaVM
        dvmStartup
          dvmClassStartup()
            // bootClassPathStr &#21253;&#25324; core.jar, bouncycastle.jar ...
            processClassPath(gDvm.bootClassPathStr, true);
              foreach entry in bootClassPathStr:
                prepareCpe(&amp;entry, isBootstrap);
                  dvmRawDexFileOpen(cpe-&gt;fileName, NULL, &amp;pRawDexFile, isBootstrap);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> 双亲委派</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
ClassLoader 这个基类主要作用是实现双亲委派
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">protected</span> <span style="color: #b58900;">Class</span>&lt;?&gt; <span style="color: #268bd2;">loadClass</span>(<span style="color: #b58900;">String</span> <span style="color: #268bd2;">className</span>) {
    <span style="color: #b58900;">Class</span>&lt;?&gt; <span style="color: #268bd2;">clazz</span> = findLoadedClass(className);

    <span style="color: #859900;">if</span> (clazz == <span style="color: #2aa198;">null</span>) {
        <span style="color: #859900;">try</span> {
            clazz = parent.loadClass(className, <span style="color: #2aa198;">false</span>);
        } <span style="color: #859900;">catch</span> (<span style="color: #b58900;">ClassNotFoundException</span> <span style="color: #268bd2;">e</span>) {
            <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">Don't want to see this.</span>
        }

        <span style="color: #859900;">if</span> (clazz == <span style="color: #2aa198;">null</span>) {
            clazz = findClass(className);
        }
    }
    <span style="color: #859900;">return</span> clazz;
}
</pre>
</div>

<p>
ClassLoader 通过 parent 指针可以形成一棵树, BootClassLoader 是树根.
</p>

<p>
在 dalvik 底层代码中并没有 BootClassLoader 这个东西: dalvik 通过把
clazz-&gt;classLoader 置为 NULL 表示该 class 是由 BootClassLoader 加载的.
</p>

<div class="org-src-container">

<pre class="src src-text">/* defining class loader, or NULL for the "bootstrap" system loader */
Object*         classLoader;
</pre>
</div>

<p>
简单起见, 我们假设 BaseDexClassLoader 的 parent 都是
BootClassLoader, 所以 PathClassLoader 的 loadClass 会先调用
BootClassLoader 的 loadClass:
</p>

<div class="org-src-container">

<pre class="src src-text">BootClassLoader.loadClass
  BootClassLoader.findClass
    VMClassLoader.loadClass(name, false);
      // native, &#20854;&#20013; null &#34920;&#31034; ClassLoader &#20026; null, &#20197;
      // &#20415;&#20174; bootstrap class &#20013;&#26597;&#25214;
      clazz = dvmFindClassByName(nameObj, NULL, resolve);
        dvmFindClassNoInit
          dvmFindSystemClassNoInit
            findClassNoInit(descriptor, null);
</pre>
</div>

<p>
若 BootClassLoader 没有找到 class, 则使用 BaseDexClassLoader 有加载
</p>

<div class="org-src-container">

<pre class="src src-text">BaseDexClassLoader.findClass(String name)
  Class c = pathList.findClass(name, suppressedExceptions);
    Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
      DexFile.defineClassNative(name, loader, cookie);
        // native
        clazz = dvmDefineClass(pDvmDex, descriptor, loader);
          findClassNoInit(descriptor, loader);
</pre>
</div>

<p>
无论是 VMClassLoader 或是 DexFile, 最终都通过 native 的
findClassNoInit 进行 dex 的加载
</p>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> 类的加载</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
和类加载相关的入口主要有:
</p>
<ol class="org-ol">
<li>dvmFindClassNoInit
<ol class="org-ol">
<li>findClassNoInit
</li>
</ol>
</li>
<li>dvmResolveClass
</li>
<li>java 层的 classForName
</li>
<li>java 层的 ClassLoader.loadClass
</li>
</ol>
</div>

<div id="outline-container-sec-1-6-3-1" class="outline-5">
<h5 id="sec-1-6-3-1"><span class="section-number-5">1.6.3.1</span> dvmFindClassNoInit</h5>
<div class="outline-text-5" id="text-1-6-3-1">
<p>
dvmFindClassNoInit 较底层的加载类的方法, 它需要指定一个字符串来表示要加载
的类, 以及一个 ClassLoader, 它作的基本上就是这么一件事:
</p>
<ol class="org-ol">
<li>若 ClassLoader 为空, 则调用更底层的 findClassNoInit 从 boot class
path 中加载类
</li>
<li>若 ClassLoader 不为空, 则通过反射去调用 java 层的
ClassLoader.loadClass. 而后者会先通过双亲委派以 NULL 做为
ClassLoader 再次调用 dvmFindClassNoInit (对应
BootClassLoader.loadClass), 然后会通过 DexFile 调用 findClassNoInit
</li>
</ol>

<p>
后面提到的 dvmResolveClass 实际上就是把 ref 转换为字符串, 并且根据
referrer 找到调用者的 ClassLoader 后直接调用 dvmFindClassNoInit. 而
classForName 因为本身就使用字符串表示要加载的类, 所以它只需要找到调用
者的 ClassLoader 后就可以直接调用 dvmFindClassNoInit
</p>

<div class="org-src-container">

<pre class="src src-text">dvmFindClassNoInit(className, referrer-&gt;classLoader);
  // &#27492;&#26102; loader &#19981;&#20026;&#31354;, &#23427;&#23545;&#24212;&#30340;&#26159; app &#30340; BaseDexClassLoader,
  // &#25152;&#20197;&#20250;&#35843;&#29992; findClassFromLoaderNoInit
  if (loader != NULL):
    return findClassFromLoaderNoInit(descriptor, loader);
      // &#22312;&#35843;&#29992; class loader &#20043;&#21069;, &#36890;&#36807; dvmLookupClass &#20174; gDvm.loadedClasses &#20013;
      // &#26597;&#25214;&#35201;&#21152;&#36733;&#30340; class &#26159;&#21542;&#24050;&#32463;&#21152;&#36733;, found &#30340;&#26465;&#20214;&#26377;&#20004;&#20010;:
      // 1. loadedClasses &#20013;&#23384;&#22312;&#19968;&#20010; class, class-&gt;descriptor &#21644; class-&gt;loader &#19982;
      // &#21442;&#25968;&#20013;&#30340;&#20540;&#37117;&#26159;&#19968;&#33268;&#30340;.
      // 2. loadedClasses &#20013;&#23384;&#22312;&#19968;&#20010; class, class-&gt;descriptor &#26159;&#19968;&#33268;&#30340;, class-&gt;initiatingLoaderList
      // &#20013;&#21253;&#21547;&#21442;&#25968;&#20013;&#30340; loader
      ClassObject* clazz = dvmLookupClass(descriptor, loader, false);
      // ClassLoader &#24320;&#22987;&#24037;&#20316;
      // &#35843;&#29992; ClassLoader.java &#30340; loadClass &#20989;&#25968;
      const Method* loadClass =
        loader-&gt;clazz-&gt;vtable[gDvm.voffJavaLangClassLoader_loadClass];
      dvmCallMethod(self, loadClass, loader, &amp;result, nameObj);
        // &#21452;&#20146;&#22996;&#27966;&#23548;&#33268; ClassLoader.loadClass &#34987;&#35843;&#29992;
        // BootClassLoader &#23548;&#33268; dvmFindClassNoInit &#20877;&#27425;&#34987;&#35843;&#29992;, &#20294;&#26159;
        // loader &#21442;&#25968;&#20026; null
        ClassLoader.loadClass
          BootClassLoader.loadClass
            dvmFindClassNoInit(className, null);
              return dvmFindSystemClassNoInit(descriptor);
                // &#36825;&#20010;&#21644;&#21452;&#20146;&#22996;&#27966;&#26080;&#20851;, &#30452;&#25509;&#20351;&#29992; dexFile &#26469;&#30495;&#27491;&#21152;&#36733;&#31867;
                findClassNoInit(descriptor, NULL, NULL);
                  clazz = dvmLookupClass(descriptor, loader, true);
                  if (clazz == NULL):
                    // !!! THE HARD WORK !!!
                    clazz = loadClassFromDex(pDvmDex, pClassDef, loader);
                    dvmAddClassToHash(clazz);
                    // &#21518;&#38754;&#30340;&#37096;&#20998;&#21442;&#32771; &lt;oo.org: findClassNoInit&gt;
          // &#33509; BootClassLoader.loadClass &#22833;&#36133;, &#35828;&#26126;&#36825;&#20010;&#31867;&#26159; BaseDexClassLoader
          // &#23450;&#20041;&#30340;, &#21452;&#20146;&#22996;&#27966;&#20250;&#35843;&#29992; BaseDexClassLoader.findClass
          BaseDexClassLoader.findClass
            pathList.findClass(name);
              findClassNoInit(className, loader);
      // findClassFromLoaderNoInit &#26368;&#21518;&#20250;&#23558; loader &#21152;&#20837;&#21040; clazz &#30340; initiatingLoaderList &#20013;
      // &#25152;&#35859;&#30340; initiatingLoaderList, &#26159;&#25351;&#24403;&#21069; class &#30340;&#21152;&#36733;&#26159;&#30001;&#36825;&#20010; loader &#21457;&#36215;&#30340;, &#22240;&#20026;&#26368;&#32456;
      // &#36127;&#36131;&#21152;&#36733;&#30340; loader (clazz-&gt;loader) &#21487;&#33021;&#24182;&#19981;&#26159;&#36825;&#20010; loader. &#36825;&#20010; initiatingLoaderList &#22312; dvmLookupClass
      // &#20250;&#29992;&#21040;. 
      dvmAddInitiatingLoader(clazz, loader);          
      // end of findClassFromLoaderNoInit
  else:
    dvmFindSystemClassNoInit(descriptor);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-3-2" class="outline-5">
<h5 id="sec-1-6-3-2"><span class="section-number-5">1.6.3.2</span> dvmResolveClass 是 byte code 中加载 class 的入口 (因为它使用 ref 指示 class</h5>
<div class="outline-text-5" id="text-1-6-3-2">
<p>
而且不是 class 名)
</p>

<div class="org-src-container">

<pre class="src src-text">HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
  clazz = dvmResolveClass(curMethod-&gt;clazz, ref, false);
    dvmResolveClass(referrer, ref, init)
      // referrer-&gt;classLoader &#35843;&#29992;&#35813;&#20195;&#30721;&#30340;&#23545;&#35937;&#20351;&#29992;&#30340; BaseDexClassLoader
      // jvm spec &#35268;&#23450;&#20102;&#33509; A &#30001; cl &#21152;&#36733;, &#21017; A-&gt;B &#26102;&#20063;&#35201;&#30001; cl &#36127;&#36131;&#21152;&#36733; B
      dvmFindClassNoInit(className, referrer-&gt;classLoader);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-3-3" class="outline-5">
<h5 id="sec-1-6-3-3"><span class="section-number-5">1.6.3.3</span> classForName</h5>
<div class="outline-text-5" id="text-1-6-3-3">
<p>
classForName 即 Class.forName(str, classLoader), 若不指定 classLoader,
根据 jvm 规范, 当前方法所属的 class 的 classLoader 负责加载这个类. 即
像 dvmResolveClass 中展示的那样: curMethod-&gt;clazz-&gt;classLoader.
</p>

<p>
这里有个问题: 若 Class.forName 在 java 层不指定 classLoader, 而要求
jni 层像 dvmResolveClass 那样自己获得 curMethod-&gt;clazz-&gt;classLoader 是否可
行? 不可行, 因为:
</p>

<p>
若 classForName 对应的 native 函数 Dalvik<sub>java</sub><sub>lang</sub><sub>Class</sub><sub>classForName</sub>
方法调用 curMethod, curMethod代表是当前 jni 方法, 而它的 clazz 是
Class 类, 最终会使用BootClassLoader 来加载, 这不是我们想要的.
</p>

<p>
因此, java 层调用 classForName 时, 需要提交获得
curMethod-&gt;clazz-&gt;classLoader, 并做为参数传给 findClassNoInit. 
</p>

<p>
而 java 层获得当前的 classLoader 是使用 native
VMStack.getCallingClassLoader
</p>

<div class="org-src-container">

<pre class="src src-text">VMStack.getCallingClassLoader
  static void Dalvik_dalvik_system_VMStack_getCallingClassLoader
    ClassObject* clazz = dvmGetCaller2Class(dvmThreadSelf()-&gt;interpSave.curFrame);
      // dvmGetCaller2Class:  Get the caller's caller's class.  Pass in the current fp.
      // &#25152;&#35859;&#30340; caller's caller's class, &#26159;&#36825;&#20040;&#22238;&#20107;:
      // &#31532;&#19968;&#20010; caller &#26159;&#25351; &#35843;&#29992; VMStack &#30340; getCallingClassLoader &#36825;&#20010;&#26041;&#27861;&#30340;&#26041;&#27861;, &#21363;
      // Class.forName &#26041;&#27861;, &#26174;&#28982;&#19981;&#26159;&#25105;&#20204;&#24819;&#35201;&#30340;. 
      // caller's caller &#26159;&#35843;&#29992; Class.forName &#30340;&#37027;&#20010;&#26041;&#27861;, &#26159;&#25105;&#20204;&#24819;&#35201;&#30340;.

      // &#24403;&#21069;&#30340; frame &#23545;&#24212;&#30340;&#26159; getCallingClassLoader &#36825;&#20010; jni &#26041;&#27861;,
      // prevFrame &#23545;&#24212; Class.forName &#26041;&#27861;
      void* caller = SAVEAREA_FROM_FP(curFrame)-&gt;prevFrame;
      callerCaller = dvmGetCallerFP(caller);
        void* caller = SAVEAREA_FROM_FP(curFrame)-&gt;prevFrame;
        if (dvmIsBreakFrame((u4*)caller)):
          caller = SAVEAREA_FROM_FP(caller)-&gt;prevFrame;
        return caller;                  
      return SAVEAREA_FROM_FP(callerCaller)-&gt;method-&gt;clazz;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-3-4" class="outline-5">
<h5 id="sec-1-6-3-4"><span class="section-number-5">1.6.3.4</span> ClassLoader.loadClass</h5>
<div class="outline-text-5" id="text-1-6-3-4">
<p>
ClassLoader.loadClass 可能比 classForName 快一些. 
因为 classForName 的调用路径是:
</p>

<ol class="org-ol">
<li>先通过 jni 调用到 Dalvik<sub>java</sub><sub>lang</sub><sub>Class</sub><sub>classForName</sub>
</li>
<li>然后调用到 dvmFindClassNoInit
</li>
<li>然后 dvmFindClassNoInit 通过 dvmCallMethod 反过来再调用
ClassLoader.loadClass 进行双亲委派
</li>
</ol>

<p>
显然, 若直接调用 ClassLoader.loadClass 的话可以跳过前两步.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4"><span class="section-number-4">1.6.4</span> 总结</h4>
<div class="outline-text-4" id="text-1-6-4">
<ol class="org-ol">
<li>对于 dvmResolveClass 和 classForName 都需要提交根据
curMethod-&gt;clazz-&gt;classLoader 获得`定义当前 method 的 class 使用的
classLoader`, 并使用这个 classLoader 调用 dvmFindClassNoInit, 这是
jvm 规范要求的. 
</li>

<li>dvmFindClassNoInit 加载类时, 要 classLoader 不为空, 则使用
classLoader 来加载, 否则使用 dvmFindSystemClassNoInit 从 bootstrap
classpath 中加载 (即从 `BootClassLoader` 中加载)

<p>
通过 ClassLoader 加载时, java 层的双亲委派会优先使用 BootClassLoader 来
加载, BootClassLoader 最终会通过 dvmFindSystemClassNoInit 来加载.
</p>

<p>
若 BootClassLoader 没有加载成功, 则 BaseDexClassLoader 的 findClass 会
负责通过 dvmDefineClass(pDvmDex, descriptor, loader) 在 app 自己的 dex
中加载类. 
</p>

<p>
即 dvmFindClassNoInit 与 java 层的各种 ClassLoader 类实现了 dalvik 的
双亲委派模型.
</p>
</li>

<li>最终 dex 都是通过 findClassNoInit 加载进来的. findClassNoInit 是负责
从 ClassLoader 对应的 dexFile (若 ClassLoader 为空则从 boot class
path) 中加载类, 它无须再考虑双亲委派.
</li>

<li>dvmFindClassNoInit 或 findClassNoInit 过程中, 都会用到
dvmLookupClass 来避免重复的加载. 

<p>
dvmLookupClass 进行查找时考虑到 clazz-&gt;loader 因为双亲委派的原因可
能不是真正发起类加载的那个 ClassLoader, 所以它使用了
clazz-&gt;initiatingLoaderList 来记录这些信息. 
</p>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> verify</h3>
<div class="outline-text-3" id="text-1-7">
<p>
<a href="http://www.netmite.com/android/mydroid/dalvik/docs/verifier.html">http://www.netmite.com/android/mydroid/dalvik/docs/verifier.html</a>
<a href="http://www.netmite.com/android/mydroid/dalvik/docs/dexopt.html">http://www.netmite.com/android/mydroid/dalvik/docs/dexopt.html</a>
<a href="http://www.netmite.com/android/mydroid/dalvik/docs/embedded-vm-control.html">http://www.netmite.com/android/mydroid/dalvik/docs/embedded-vm-control.html</a>
</p>

<p>
verify 的发生有两种场合:
</p>
<ol class="org-ol">
<li>pre-verify
</li>
<li>dvmVerifyClass
</li>
</ol>
</div>

<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> pre-verify</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
pre-verify 实际上指的就是 dexopt 时进行的 verify. 在默认配制下, dexopt
会先对 dex 进行 verify, 然后再进行 optimization. 实际上, 默认配制下
dexopt 要求必须先 verify 以后才能进行 optimization. 所以 pre-verify 发
生的时机就是dexopt 发生的时机: 例如通过 zygote 的 dvmClassStartup.
</p>

<p>
通过 dexopt 的 pre-verify, odex 中的 class 对象的 CLASS<sub>ISPREVERIFIED</sub>
标志会被置位, 这个标记会阻止后续 dvminitclass 时的 dvmVerifyClass 调用. 
</p>

<p>
实际上, pre-verify, dexopt 合起来做为 dex 的 prepare
</p>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> dvmVerifyClass</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
通过 setprop dalvik.vm.verify-bytecode false, 可以禁用整个 dex prepare
过程 (包括 pre-verify 和 dexopt). 若开机启动时因为这个 prop 没有进行
verify, 但运行时通过 setprop dalvik.vm.verify-bytecode true 或直接通过
dalvik 的启动参数 (-Xverify:all 或 -Xverify:remote) 重新启用了 verify,
则在 class 初始化时, 会调用 dvmVerifyClass 进行 verify. 这种运行时的
verify 会导致应用加载明显变慢 (可能 40% 以上)
</p>

<p>
Xverify 参数接受三种值:
</p>
<ol class="org-ol">
<li>all
所有 class 被需要被 verify
</li>
<li>remote
boot class 以外的 class 需要被 verify
</li>
<li>none   
任何 class 都不会被 verify
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3"><span class="section-number-4">1.7.3</span> 关于 verify 和 dexopt 的实验</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
这里有一个 java 文件:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">class</span> <span style="color: #b58900;">Test2</span> {
    <span style="color: #859900;">private</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">a</span> = 10;
}

<span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #b58900;">Test</span> {
    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        System.out.println(<span style="color: #2aa198;">"hello: "</span>+Test2.a);
    }
}
</pre>
</div>

<p>
但这个 java 文件是编译不过, 为了让 javac 能生成这个语义的 class 文件(让
class 中的 main 函数直接访问 Test2 的私有成员), 我们可以这样操作:
</p>

<ol class="org-ol">
<li>把 private 暂时改为 public, javac Test.java
</li>
<li>把生成的 Test.class 保存起来
</li>
<li>把 public 变回 private, 但把 System.out.println 一行去掉, 然后
javac Test.java, 把 Test2.class 保存起来
</li>
<li>把两次保存的 Test.class 和 Test2.class 打包为 Test.dex. 这样
Test.dex 中就会包含 Test 访问 Test2 的私有变量这样的非法代码. 
</li>
</ol>

<p>
在手机上用 dalvikvm 命令执行, 分别指定不同的 Xverify 和 Sexpot 参数:
</p>

<ol class="org-ol">
<li>dalvikvm -Xverify:none -Xdexopt:all -cp Test.dex Test
<ul class="org-ul">
<li>dalvik-cache 下有 odex 生成, 且 Test 确实被优化了 (invoke-virtual
被替换为 invoke-virtual-quick)
</li>
<li>程序正常输出 10
</li>
</ul>
</li>

<li>dalvikvm -Xverify:all -Xdexopt:all -cp Test.dex Test
<ul class="org-ul">
<li>dalvik-cache 下有 odex 生成, 且 Test 被优化
</li>
<li>程序报错:
<div class="org-src-container">

<pre class="src src-text">root@scx15_sp7715ga:/data # dalvikvm -Xverify:all -Xdexopt:all -cp Test.dex Te&gt;
Unable to find static main(String[]) in 'Test'
java.lang.VerifyError: Test
        at dalvik.system.NativeStart.main(Native Method)
java.lang.VerifyError: Test
        at dalvik.system.NativeStart.main(Native Method)
</pre>
</div>

<p>
这里报错是因为: Xverify:all 会导致 dexopt 时进行 pre-verify, 但
这里 verify 会失败, 所以 class 不会被标记为 PREVERIFIED, 但因为
Xdexopt:all, 所以虽然 pre-verify 失败了, dexopt 还是会进行优化,
最终 odex 中包括的 Test 类是优化后的结果. 
</p>

<p>
dvminitclass @ Class.cpp 中的这段代码:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900;">if</span> (clazz-&gt;status &lt; CLASS_VERIFIED) {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">...</span>
    <span style="color: #859900;">if</span> (IS_CLASS_FLAG_SET(clazz, CLASS_ISOPTIMIZED)) {
        ALOGW(<span style="color: #2aa198;">"Class '%s' was optimized without verification; "</span>
              <span style="color: #2aa198;">"not verifying now"</span>,
              clazz-&gt;descriptor);
        ALOGW(<span style="color: #2aa198;">"  ('rm /data/dalvik-cache/*' and restart to fix this)"</span>);
        <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">verify_failed &#22788;&#20250;&#25243;&#20986;&#24322;&#24120;</span>
        <span style="color: #859900;">goto</span> <span style="color: #2aa198;">verify_failed</span>;
    }
}
</pre>
</div>

<p>
会抛出上面的异常. 
</p>

<p>
即: 若 class 没有通过 verify 就被 dexopt, 则在 dvmInitClass 的阶段,
dalvik 就会主动抛出异常. 这样做的原因可能是: 因为 code 已经被
dexopt, 这里可能无法再 replaceFailingInstruction
</p>
</li>
</ul>
</li>

<li>dalvikvm -Xverify:all -Xdexopt:none -cp Test.dex Test
<ul class="org-ul">
<li>dalvik-cache 下有 odex 生成, 但 Test 没有被优化
</li>
<li>程序报错:
<div class="org-src-container">

<pre class="src src-text">root@scx15_sp7715ga:/data # dalvikvm -Xverify:all -Xdexopt:none -cp Test.dex T&gt;
java.lang.IllegalAccessError: tried to access field Test2.a from class Test
        at Test.main(Test.java:6)
        at dalvik.system.NativeStart.main(Native Method)
</pre>
</div>

<p>
这里报错是因为:
Xverify:all 会导致 pre-verify, 但 pre-verify 会失败, 导致后续
dvmInitClass 还会再次调用 dvmVerifyClass 进行 late verify. (因为
Xdexopt 为 none, 所以不会发生 case 2 的问题). late verify 时还是
会失败, 这里会通过 replaceFailingInstruction 将原来的指令 (sget)
替换为一个抛出异常的指令, 但这里做的仅仅是指令替换, 并不会直接抛
出异常. 当被替换的指令直接执行时, 才会报错. 
</p>
</li>
</ul>
</li>
</ol>

<p>
综上:
</p>
<ol class="org-ol">
<li>无法 Xdexopt 如何指定, odex 总是会生成, 但 Xdexopt 会影响 odex 中的
代码是优化过的还是 dex 中的原始代码.
</li>
<li>Xverify 会影响 dexopt 时的 pre-verify 和 class 加载时的 late verify
</li>
<li>在 late verify 阶段, 若当前代码并没有被 dexopt 优化, 则会
通过 replaceFailingInstruction 进行指令替换, 否则直接报错
</li>
<li>默认情况下 Xverify = all, Xdexopt = verified, 所以, 若一个类有问题,
则会在运行时报错 (通过 replaceFailingInstruction), 而不是在 verify
阶段 (pre-verify 或 late verify) 报错. 抛开 pre-verify, dexopt 这些
不谈, java 的 verify 的功能本质上就是 replaceFailingInstruction
</li>
</ol>
</div>

<div id="outline-container-sec-1-7-3-1" class="outline-5">
<h5 id="sec-1-7-3-1"><span class="section-number-5">1.7.3.1</span> 关于 replaceFailingInstruction</h5>
<div class="outline-text-5" id="text-1-7-3-1">
<p>
在 pre-verify 阶段, 即使 verify 失败, 也不会进行
replaceFailingInstruction 的, 因为:
</p>

<div class="org-src-container">

<pre class="src src-c++">verifyInstruction @ CodeVerify.cpp
<span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">...</span>
<span style="color: #859900;">if</span> (<span style="color: #dc322f;">!</span>VERIFY_OK(failure)) {
    <span style="color: #586e75; font-style: italic;">// </span><span style="color: #586e75; font-style: italic;">&#22312; pre-verify &#38454;&#27573;, gDvm.optimizing &#20026; true</span>
    <span style="color: #859900;">if</span> (failure == VERIFY_ERROR_GENERIC || gDvm.optimizing) {
        <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">immediate failure, reject class */</span>
        LOG_VFY_METH(meth, <span style="color: #2aa198;">"VFY:  rejecting opcode 0x%02x at 0x%04x"</span>,
                     decInsn.opcode, insnIdx);
        <span style="color: #859900;">goto</span> <span style="color: #2aa198;">bail</span>;
    } <span style="color: #859900;">else</span> {
        <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">replace opcode and continue on */</span>
        ALOGD(<span style="color: #2aa198;">"VFY: replacing opcode 0x%02x at 0x%04x"</span>,
              decInsn.opcode, insnIdx);
        <span style="color: #859900;">if</span> (<span style="color: #dc322f;">!</span>replaceFailingInstruction(meth, insnFlags, insnIdx, failure)) {
            LOG_VFY_METH(meth, <span style="color: #2aa198;">"VFY:  rejecting opcode 0x%02x at 0x%04x"</span>,
                         decInsn.opcode, insnIdx);
            <span style="color: #859900;">goto</span> <span style="color: #2aa198;">bail</span>;
        }
        <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">IMPORTANT: meth-&gt;insns may have been changed */</span>
        insns = meth-&gt;insns + insnIdx;

        <span style="color: #586e75; font-style: italic;">/* </span><span style="color: #586e75; font-style: italic;">continue on as if we just handled a throw-verification-error */</span>
        failure = VERIFY_ERROR_NONE;
        nextFlags = kInstrCanThrow;
    }
}
</pre>
</div>

<p>
replaceFailingInstruction 需要修改 odex 映射的内存, 而不是 odex 本身.
因为 odex 都是以只读方式进行 mmap 的, 所以 replaceFailingInstruction
需要先修改 mmap 区域的权限, 再进行写操作, 这会导致额外的内存开销.  
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Wei Sun (孙伟)</p>
<p class="email">Email: <a href="mailto:wei.sun@spreadtrum.com">wei.sun@spreadtrum.com</a></p>
<p class="date">Created: 2014-09-26 Fri 10:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.50.4 (<a href="http://orgmode.org">Org</a> mode 8.2.5g)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
