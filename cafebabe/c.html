<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>c</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="c"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-05-17T17:03+0800"/>
<meta name="author" content="sunway"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>    <link rel="stylesheet" type="text/css" href="/stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">c</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 C/C++</a>
<ul>
<li><a href="#sec-1-1">1.1 static变量不要写在头文件中</a></li>
<li><a href="#sec-1-2">1.2 void参数与空参数</a></li>
<li><a href="#sec-1-3">1.3 switch与跳转表</a></li>
<li><a href="#sec-1-4">1.4 volatile keyword in C</a></li>
<li><a href="#sec-1-5">1.5 栈对齐 stack align</a></li>
<li><a href="#sec-1-6">1.6 gcc -E</a></li>
<li><a href="#sec-1-7">1.7 结构体的 struct A a={.a=1,.b=2};形式的初始化</a></li>
<li><a href="#sec-1-8">1.8 do {} while (0)</a></li>
<li><a href="#sec-1-9">1.9 char * str[MAXSIZE]</a></li>
<li><a href="#sec-1-10">1.10 scanf</a></li>
<li><a href="#sec-1-11">1.11 scanf中的%s与%[]</a></li>
<li><a href="#sec-1-12">1.12 c中的声明与定义</a></li>
<li><a href="#sec-1-13">1.13 compile time assert</a></li>
<li><a href="#sec-1-14">1.14 C Preprocessor &ndash; the whole story</a></li>
<li><a href="#sec-1-15">1.15 c++容器当pop元素时元素如果被自动析构</a></li>
<li><a href="#sec-1-16">1.16 c++引入引用的最根本原因</a></li>
<li><a href="#sec-1-17">1.17 operator-&gt;()</a></li>
<li><a href="#sec-1-18">1.18 [23.11] How can I set up my class so it won't be inherited from?</a></li>
<li><a href="#sec-1-19">1.19 never throw exceptions in dtor</a></li>
<li><a href="#sec-1-20">1.20 what is type-safe and strong type</a></li>
<li><a href="#sec-1-21">1.21 why pop<sub>back</sub> returns void instead of the removed object?</a></li>
<li><a href="#sec-1-22">1.22 数组蜕化为指针及数组引用做为函数参数</a></li>
<li><a href="#sec-1-23">1.23 c++ template 链接问题</a></li>
<li><a href="#sec-1-24">1.24 The Standard Librarian: Containers of Incomplete Types</a></li>
<li><a href="#sec-1-25">1.25 临时对象的const引用</a></li>
<li><a href="#sec-1-26">1.26 bitwise copy</a></li>
<li><a href="#sec-1-27">1.27 可怜的bool</a></li>
<li><a href="#sec-1-28">1.28 operator new</a></li>
<li><a href="#sec-1-29">1.29 prefrer ++i to i++</a></li>
<li><a href="#sec-1-30">1.30 Decorator pattern</a></li>
<li><a href="#sec-1-31">1.31 一个Printable类</a></li>
<li><a href="#sec-1-32">1.32 类型转换</a></li>
<li><a href="#sec-1-33">1.33 cast</a></li>
<li><a href="#sec-1-34">1.34 RTTI与CTTI</a></li>
<li><a href="#sec-1-35">1.35 重载 </a></li>
<li><a href="#sec-1-36">1.36 mask</a></li>
<li><a href="#sec-1-37">1.37 copy构造函数与vtl</a></li>
<li><a href="#sec-1-38">1.38 类对象的几种声明方法：</a></li>
<li><a href="#sec-1-39">1.39 virtual函数,vptr例子</a></li>
<li><a href="#sec-1-40">1.40 成员函数的调用</a></li>
<li><a href="#sec-1-41">1.41 virtual析构函数</a></li>
<li><a href="#sec-1-42">1.42 c++ string literal的类型是什么?</a></li>
<li><a href="#sec-1-43">1.43 internal linkage , external linkage &amp; no linkage</a></li>
<li><a href="#sec-1-44">1.44 临时对象(右值)可被修改?</a></li>
<li><a href="#sec-1-45">1.45 左值与右值</a></li>
<li><a href="#sec-1-46">1.46 when does cast alter the pointer's address</a></li>
<li><a href="#sec-1-47">1.47 c++弱化了data段还是bss段?</a></li>
<li><a href="#sec-1-48">1.48 除了ctor,在一个类的所有成员函数中调用虚函数都是通过vptr机制</a></li>
<li><a href="#sec-1-49">1.49 virtual inhereit in c++</a></li>
<li><a href="#sec-1-50">1.50 c++ pointer-to-member variable and functions</a></li>
<li><a href="#sec-1-51">1.51 c++ inline function</a></li>
<li><a href="#sec-1-52">1.52 static<sub>cast&lt</sub>;Derived *&gt;(virtual base *) is not supported in C++</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> C/C++</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> static变量不要写在头文件中</h3>
<div class="outline-text-3" id="text-1-1">

<p>   通常static变量在头文件中是错误的, 除非多个编译单元真的想各自使用独立的该变量
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> void参数与空参数</h3>
<div class="outline-text-3" id="text-1-2">

<p>   引用网址：<a href="http://david.tribble.com/text/cdiffs.htm#C99-func-vararg">http://david.tribble.com/text/cdiffs.htm#C99-func-vararg</a>
</p>
<p>
   “
   Empty parameter lists
</p>
<p>
   C distinguishes between a function declared with an empty parameter list and
   a function declared with a parameter list consisting of only void. The former
   is an unprototoped function taking an unspecified number of arguments, while
   the latter is a prototyped function taking no arguments.
</p>
<p>
    // C code
</p>



<pre class="example">extern int  foo();          // Unspecified parameters
extern int  bar(void);      // No parameters

void baz()
{
    foo(0);         // Valid C, invalid C++
    foo(1, 2);      // Valid C, invalid C++

    bar();          // Okay in both C and C++
    bar(1);         // Error in both C and C++
}
</pre>

<p>
    C++, on the other hand, makes no distinction between the two declarations
    and considers them both to mean a function taking no arguments.
</p>
<p>
    // C++ code
</p>



<pre class="example">extern int  xyz();
extern int  xyz(void);  // Same as 'xyz()' in C++,
                        // Different and invalid in C
For code that is intended to be compiled as either C or C++, the best solution to this problem is to always declare functions taking no parameters with an explicit void prototype. For example:

// Compiles as both C and C++
int bosho(void)
{
    ...
}
</pre>

<p>
    Empty function prototypes are a deprecated feature in C99 (as they were in C89).
</p>
<p>
    即 在c中,void f()表示参数个数未指定,而不是表示无参数,表示无参数要使用void f(void)
    在c++中,void f()和void f(void)是一样的.
</p>
<p>
    即 尽量使用void f(void) 而不要使用void f()
</p>
<p>
    --
    发信人: sunway (sunway), 信区: CPP
    标  题: Re: 关于函数参数个数的问题
    发信站: 北邮人论坛 (Wed Oct 14 13:01:02 2009), 站内
</p>
<p>
    gcc确实能编译过去&hellip;神奇
    一般情况下不会错误,gcc默认使用cdecl调用约定,调用者会负责清理栈上的参数,但如果使
    用了stdcall,被调用的f不知道有参数要清理,而调用者又认为f会清理参数&hellip;然后就有问题
    了,比如:
</p>



<pre class="example">void  __attribute__((stdcall)) f (int a,int b) {
    f (1,2);
}

int main()
{
    f(1,2);
    return 0;
}
</pre>


<p>
    【 在 SuperBrother (xiaohui) 的大作中提到: 】
</p><pre class="example">
标  题: 关于函数参数个数的问题
发信站: 北邮人论坛 (Wed Oct 14 11:29:31 2009), 站内

void f() {}
void g(int a) {}

int main()
{
    f(1);
    //g(1, 1);  编译不过，提示参数个数过多
    return 0;
}

用的是GCC 4.2.4
想问问为啥f(1)能过，而g(1, 1)不能？
另外，假设f()不用参数就能完成相应功能，调用f(1)会引起运行时错误吗？
--

</pre>

<p>    ※ 修改:・sunway 于 Oct 14 13:02:34 修改本文・[FROM: 2001:da8:215:1800:211:11ff:
</p><pre class="example">
※ 来源:・北邮人论坛 http://forum.byr.edu.cn・[FROM: 2001:da8:215:5200:0:5efe:
</pre>

</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> switch与跳转表</h3>
<div class="outline-text-3" id="text-1-3">




<pre class="example">int
main (int argc, char * argv[]) {
    int a=0;
    switch (a) {
    case 1:
        printf ("%d\n",a);
        break;
    case 2:
        printf ("%d\n",a);
        break;
    case 3:
        printf ("%d\n",a);
        break;
    case 11:
        printf ("%d\n",a);
        break;
    case 100:
        printf ("%d\n",a);
        break;
    case 13:
        printf ("%d\n",a);
        break;
    case 4:
        printf ("%d\n",a);
        break;
    case 5:
        printf ("%d\n",a);
        break;
    case 6:
        printf ("%d\n",a);
        break;
    case 7:
        printf ("%d\n",a);
        break;
    case 8:
        printf ("%d\n",a);
        break;

    default:
        printf ("%d\n",a);
        break;
    }
    return 0;
}
</pre>

<p>
当case分支较少时,和if..else一样,通过一系列cmp,je..跳转.
当case分支较多时,会根据情况生成一个跳转表,如:
</p>


<pre class="example">        movl    -24(%ebp), %edx
        movl    .L14(,%edx,4), %eax
        jmp     *%eax
        .section        .rodata
        .align 4
        .align 4
.L14:
        .long   .L2
        .long   .L3
        .long   .L4
        .long   .L5
        .long   .L6
        .long   .L7
        .long   .L8
        .long   .L9
        .long   .L10
        .long   .L2
</pre>

<p>
.L14就是跳转表的入口, %eax是分支在表中的偏移,如case为100,则其偏移量为100*4(因为每个表项为4字节)
这时存在一个问题是:如果case值范围过大,比如一共100个case,但有一个case的值为1000,则表中有900个项需要用default分支的地址去填充,浪费空间.
所以gcc在这种情况下又会转而使用原始的cmp,je..跳转.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> volatile keyword in C</h3>
<div class="outline-text-3" id="text-1-4">




<pre class="example">int main(int args, char **argv)  {
    char x, y, z;
    int i;
    int a[16];

    for(i=0; i&lt;=16; i++) {
        a[i] = 0;
        printf("%d\n", i);
    }
    return 0;
}
</pre>


<ol>
<li>程序正常终止,打印出0-16
</li>
<li>在 int i; 前加上 volatile, 死循环
</li>
</ol>


<p>
   Volatile is an ANSI C type modifier that is frequently needed in C code that
   is part of signal/interrupt handlers, threaded code, and other kernel code,
   including device drivers. In general, any data that may be undated
   asynchronously should be declared to be volatile. Incidentally, this issue is
   not related to CPU caches except that re-loading of variables into registers
   may involve cache hits or misses.
</p>
<p>
   Why Use Volatile?  The reason to use volatile is to insure that the compiler
   generates code to re-load a data item each time it is referenced in your
   program. Without volatile, the compiler may generate code that merely re-uses
   the value it already loaded into a register.
</p>
<p>
   Volatile advises the compiler that the data may be modified in a manner that
   may not be determinable by the compiler. This could be, for example, when a
   pointer is mapped to a device's hardware registers. The device may
   independently change the values unbeknownst to the compiler.
</p>

<p>
   With gcc the -O2 option is normally required to see the effect of not using
   volatile. Without -O2 or greater optimization, the compiler is likely to
   re-load registers each time a variable is referenced, anyway. Don't blame the
   optimizer if a program gets incorrect results because the program does not
   use volatile where required.
</p>
<p>
   For example, if two threads share a variable, sum, and one or both threads
   modify it, then the other thread may use a stale value in a register instead
   of going back to memory to get the new value. Instead, each time the thread
   references sum, it must be re-loaded. The way to insure this occurs in ANSI C
   is to declare sum to be volatile.
</p>
<p>
   Example: The use of volatile can be required to get correct answers. For
   example the program wrong will give incorrect results when it is compiled -O2
   and without volatile. This slightly obtuse program is designed to stop after
   100 ticks of an interval timer that ticks at 100Hz and print the value of the
   variable total. The tick count is incremented in the signal handler. When the
   count gets to 100, the program should terminate. If the tick count does not
   get to 100 within 10 seconds then an alarm goes off and the program
   terminates.
</p>
<p>
   By compiling the program as: gcc -O2 -DVOLATILE=volatile wrong.c -o wrong<sub>v</sub>
   you will see, (unless your program is preempted for quite a while), that the
   count gets to 100 and the program terminates as designed. With the program
   compiled as gcc -O2 wrong.c -o wrong<sub>nv</sub> you will see, that the count becomes
   greater than 100 as shown when the handler prints it, but, the while loop
   does not terminate.
</p>
<p>
   Incidentally, attempts to determine what is happening may thwart your
   efforts. For example, a function call, such as to printf(), or the use of a
   breakpoint, in the loop, will likely spill and re-load the registers.
</p>

<p>
   <a href="http://en.allexperts.com/q/C-1587/volatile.htm">http://en.allexperts.com/q/C-1587/volatile.htm</a>
   <a href="http://www.netrino.com/node/80">http://www.netrino.com/node/80</a>
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 栈对齐 stack align</h3>
<div class="outline-text-3" id="text-1-5">




<pre class="example">int
main (int argc, char * argv[]) {
   int a=9;
   double b=0;
   char * c=&amp;b;
   printf ("%d\n",*(int *)(c+8));
   return 0;
}
</pre>

<p>
  c+8后才是a的地址,而不是c+4
</p>
<p>
  gcc保证,对于8 bytes的类型如double,在栈上是8字节对齐的
</p>
<p>
  On the Pentium and subsequent x86 processors, there is a substantial
  performance penalty if double-precision variables are not stored 8-byte
  aligned; a factor of two or more is not unusual. Unfortunately, the stack (the
  place that local variables and subroutine arguments live) is not guaranteed by
  the Intel ABI to be 8-byte aligned.
</p>
<p>
  Recent versions of gcc (as well as most other compilers, we are told, such as
  Intel's, Metrowerks', and Microsoft's) are able to keep the stack 8-byte
  aligned; gcc does this by default (see -mpreferred-stack-boundary in the gcc
  documentation). If you are not certain whether your compiler maintains stack
  alignment by default, it is a good idea to make sure.
</p>
<p>
  Unfortunately, gcc only preserves the stack alignment―as a result, if the
  stack starts off misaligned, it will always be misaligned, with a disastrous
  effect on performance (in double precision).
</p>
<p>
  <a href="http://www.fftw.org/doc/Stack-alignment-on-x86.html">http://www.fftw.org/doc/Stack-alignment-on-x86.html</a>
</p>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> gcc -E</h3>
<div class="outline-text-3" id="text-1-6">

</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 结构体的 struct A a={.a=1,.b=2};形式的初始化</h3>
<div class="outline-text-3" id="text-1-7">

<p>   gcc扩展:
</p>



<pre class="example">struct A {
  int a;
  int b;
};

int
main(int argc, char *argv[]) {
  struct A a={.b=1,.a=2}; //或者 struct A a={2,1};
  printf ("%d %d\n",a.a,a.b);
  return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> do {} while (0)</h3>
<div class="outline-text-3" id="text-1-8">

<p>   <a href="http://c2.com/cgi/wiki?TrivialDoWhileLoop">http://c2.com/cgi/wiki?TrivialDoWhileLoop</a>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> char * str[MAXSIZE]</h3>
<div class="outline-text-3" id="text-1-9">

<p>   当打算将strlen是n的字符串存入str时，要分配n+1个char的空间，因为结尾的'\0'不包括在strlen里
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> scanf</h3>
<div class="outline-text-3" id="text-1-10">


</div>

<div id="outline-container-1-10-1" class="outline-4">
<h4 id="sec-1-10-1"><span class="section-number-4">1.10.1</span> %n</h4>
<div class="outline-text-4" id="text-1-10-1">




<pre class="example">int a,b;
scanf("%d%n",&amp;a,&amp;b)
#&gt;./a.out
1234
a=1234 b=4
</pre>

</div>

</div>

<div id="outline-container-1-10-2" class="outline-4">
<h4 id="sec-1-10-2"><span class="section-number-4">1.10.2</span> %[]</h4>
<div class="outline-text-4" id="text-1-10-2">


</div>

</div>

<div id="outline-container-1-10-3" class="outline-4">
<h4 id="sec-1-10-3"><span class="section-number-4">1.10.3</span> %*</h4>
<div class="outline-text-4" id="text-1-10-3">




<pre class="example">int a,b;
scanf("%*d%n",&amp;a);
#&gt;./a.out
1234
a=4
</pre>

</div>

</div>

<div id="outline-container-1-10-4" class="outline-4">
<h4 id="sec-1-10-4"><span class="section-number-4">1.10.4</span> 空白字符的处理</h4>
<div class="outline-text-4" id="text-1-10-4">

<p>    空白字符包括 空格,tab,\n
</p>


<pre class="example">int a,b;
scanf("%d",&amp;a);
scanf("%d",&amp;b);
#&gt;./a.out
1234 123
a=1234,b=123
</pre>

<p>
    实际上,第一个scanf执行后,输入流里还有一个\n,但是,下一句scanf用%d做参数时,会忽略输入流开头的空白字符.
    大多数%..会忽略开头的空白字符,但以下几个除外:
    %c,%[]
    所以:
</p>


<pre class="example">int a,b;
scanf("%d",&amp;a);
scanf("%c",&amp;b);
#&gt;./a.out
1234
a=1234,b=134513674
</pre>

<p>
    b没有要求输入值,而是直接用的流中剩余的\n,对于%c,%[]这种情况,需要手工用%s忽略开头的空白字符,如:
</p>


<pre class="example">int a,b;
scanf("%d",&amp;a);
scanf("%*[ \t\n]%c",&amp;b);
</pre>


</div>

</div>

<div id="outline-container-1-10-5" class="outline-4">
<h4 id="sec-1-10-5"><span class="section-number-4">1.10.5</span> 回车的作用</h4>
<div class="outline-text-4" id="text-1-10-5">

<p>    回车用来表示将输入提交到输入流中,但回车本身也会被正常放在输入流中,所以
    scanf("%d\n",&amp;a) 也是可以被匹配的
</p></div>

</div>

<div id="outline-container-1-10-6" class="outline-4">
<h4 id="sec-1-10-6"><span class="section-number-4">1.10.6</span> scanf类型不匹配时死循环?</h4>
<div class="outline-text-4" id="text-1-10-6">




<pre class="example">int a;
label:
scanf("%d",&amp;a);
goto label;
</pre>

<p>
    若输入不为整数,如'a',则后面的scanf会被跳过,死循环
    原因:
    scanf类型不匹配时,scanf失败,不匹配的数据仍然留在输入流中,必须用%*..丢弃这些错误的数据.
</p>


<pre class="example">int a;
label:
scanf("%d",&amp;a);
scanf("%*s");
goto label;
</pre>


</div>
</div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> scanf中的%s与%[]</h3>
<div class="outline-text-3" id="text-1-11">

<p>scanf ("%s,%d",a,&amp;b);
然后输入 abc,2,打印a的值是 abc,2 ,不是abc,就是说%s会贪婪的吞掉它后面所有的输入,
除非你输入空格让它停止
</p>
<p>
s
</p>
<p>
Matches  a sequence of non-white-space characters; the next pointer must be
a pointer to character array that is long enough to hold the input sequence
and  the  terminating  null character ('\0'), which is added automatically.
The input string stops at white  space  or  at  the  maximum  field  width,
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ \t\n]+
whichever occurs first.
</p>

<p>
如果你确实喜欢用abc,2这种形式输入,可以试试这个:
scanf("%[^,]%d",a,&amp;b);
比较爽
</p>
<p>
我觉得%s可能就是%[^ \t\n]吧
</p>
</div>

</div>

<div id="outline-container-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> c中的声明与定义</h3>
<div class="outline-text-3" id="text-1-12">

<p>   在1.c和2.c两个文件中,
</p>
<p>
以下情形时编译正确:
</p>


<pre class="example">|----------------+----------------|
| 1.c            | 2.c            |
|----------------+----------------|
| int a          | int a          |
| int a          | char a         |
| int a          | extern int a   |
| int a          | extern char a  |
| int a=2        | char a         |
| int a=2        | int a          |
| static int a=2 | static int a=1 |
|----------------+----------------|
</pre>


<p>
以下情形时出错:
</p>


<pre class="example">|---------+----------|
| 1.c     | 2.c      |
|---------+----------|
| int a=2 | int a=3  |
| int a=2 | char a=3 |
| int a=2 | int a=2  |
|---------+----------|
</pre>

<p>
结论:
   没有赋值的定义如 int a 和 声明 extern int a 一样,可以声明多次,类型也可以不同(虽然这是个错误)
   赋值的定义只能定义一次
   static的定义和声明不干扰
即:没赋值的可以随便写,赋值的只能写一次.extern关键字没有用.
</p></div>

</div>

<div id="outline-container-1-13" class="outline-3">
<h3 id="sec-1-13"><a name="7xl4i9z0ife0-sunway-lab.bupt.edu.cn" id="7xl4i9z0ife0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.13</span> <span class="done DONE">DONE</span> compile time assert &nbsp;&nbsp;&nbsp;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-13">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-11-03 一 16:13</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-11-03 一 16:13</span></span>
</li>
</ul>

<p>   #define ASSERT<sub>STATIC</sub>(e) char UXXX[(e)-1]
</p>
</div>

</div>

<div id="outline-container-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> <span class="done DONE">DONE</span> C Preprocessor &ndash; the whole story</h3>
<div class="outline-text-3" id="text-1-14">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-11-03 一 16:15</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-11-03 一 16:15</span></span>
</li>
</ul>

<p>   <a href="http://developer.apple.com/documentation/DeveloperTools/gcc-4.0.1/cpp/">http://developer.apple.com/documentation/DeveloperTools/gcc-4.0.1/cpp/</a>
   <a href="http://en.wikipedia.org/wiki/C_preprocessor">http://en.wikipedia.org/wiki/C_preprocessor</a>
   <a href="http://blog.chinaunix.net/u1/41845/showart_446562.html">http://blog.chinaunix.net/u1/41845/showart_446562.html</a>
</p>
</div>

</div>

<div id="outline-container-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> c++容器当pop元素时元素如果被自动析构</h3>
<div class="outline-text-3" id="text-1-15">

<p>   Test t;
   vector&lt;Test&gt; v;
   v.push<sub>back</sub>(t);
   v.pop<sub>back</sub>();
   v pop<sub>back时</sub>,容器中相应的元素(t的拷贝)被自动析构.
   但
   Test * t=new Test;
   v.push<sub>back</sub>(t);
   v.pop<sub>back</sub>()时,t指向的元素却并不会被析构.
   同样,若vector中元素为其它内置类型也,也不可能被自动析构
</p>
<p>
   vector的源码中,
   pop<sub>back</sub>() {
   _<sub>M</sub><sub>content</sub>;
   destroy(..);
   }
   而destroy(p)只是简单的调用 p-&gt;~T()
</p>
<p>
   为了容器的一致,C++规定,内置类型的析构也能编译通过,但这些析构实际上什么也不做,
   即当T为int时,p-&gt;~int()也能编译通过,指针也属于内置类型,所以容器中为指针时,也能
   编译通过,但析构时实际上什么也不做.
</p>
<p>
   从上面vector的代码中也可以看到,vector pop<sub>back时并不释放内存</sub>,而list与此不同:
   list的pop<sub>back大致为</sub>:
   destroy();
   deallocate();
   ..
   其中deallocate负责释放内存
</p>
<p>
   上面提到的destroy,deallocate,还有allocate,construct都是容器的allocator的功能,
   可以自己重写一个allocator,实现不同的allocate,deallocate,construct,destroy行为,然后把
   新的allocator做为容器的模板参数
</p>
</div>

</div>

<div id="outline-container-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> c++引入引用的最根本原因</h3>
<div class="outline-text-3" id="text-1-16">

<p>   c++引入引用,是因为容器的存在.
</p>
<p>
   对比C语言中经典的容器:数组. 数组可以保存各种类型,包括内置类型,自定义struct等,
   如array<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>=structA,则后面array<sup><a class="footref" name="fnr-.1.2" href="#fn-.1">1</a></sup>.value1=1时,即是修改structA,数组的[]是C内置运
   算符,不存在array<sup><a class="footref" name="fnr-.1.3" href="#fn-.1">1</a></sup>取得的是structA的拷贝的问题
</p>
<p>
   但在c++中,容器类的[],at,get&hellip;都是函数,如vector&lt;struct&gt; v; v<sup><a class="footref" name="fnr-.1.4" href="#fn-.1">1</a></sup>=structA;
   v<sup><a class="footref" name="fnr-.1.5" href="#fn-.1">1</a></sup>.value=1;若operator[]直接返回struct类型,而不是引用或指针,则v<sup><a class="footref" name="fnr-.1.6" href="#fn-.1">1</a></sup>.value=1修
   改的实际上是structA的拷贝.所以C++的容器类的getter,为了与c语义上的一致,都是返回
   引用.如果没有引用,C++容器只能设计成必须存储指针类型
</p>
<p>
   另外,用c写的glib中容器,如garray,getter都是使用宏来完成的,宏可以认为是
   return-by-name, 和引用的效果类似.如 #define g<sub>array</sub><sub>index</sub>(a,t,i) (((t*) (void
   *) (a)-&gt;data) [(i)]), a是array,t是容器中成员类型,i是偏移量
</p>
<p>
   综上:容器类的getter方法都是函数调用,为了避免return-by-value,使用了 return-by-name
</p>
</div>

</div>

<div id="outline-container-1-17" class="outline-3">
<h3 id="sec-1-17"><a name="shn19b504ie0-sunway-lab.bupt.edu.cn" id="shn19b504ie0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.17</span> operator-&gt;() &nbsp;&nbsp;&nbsp;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-17">

<p>   operator-&gt;()用来使某个类像指针,如iteraotr
</p>
</div>

</div>

<div id="outline-container-1-18" class="outline-3">
<h3 id="sec-1-18"><a name="4to2d6y03ge0-sunway-lab.bupt.edu.cn" id="4to2d6y03ge0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.18</span> [23.11] How can I set up my class so it won't be inherited from? &nbsp;&nbsp;&nbsp;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-18">

<p>   This is known as making the class "final" or "a leaf." There are three ways
   to do it: an easy technical approach, an even easier non-technical approach,
   and a slightly trickier technical approach.
</p>
<p>
   The (easy) technical approach is to make the class's constructors private and
   to use the Named Constructor Idiom to create the objects. No one can create
   objects of a derived class since the base class's constructor will be
   inaccessible. The "named constructors" themselves could return by pointer if
   you want your objects allocated by new or they could return by value if you
   want the objects created on the stack.
</p>
<p>
   The (even easier) non-technical approach is to put a big fat ugly comment
   next to the class definition. The comment could say, for example, // We'll
   fire you if you inherit from this class or even just <i>*final*</i> class Whatever
   {&hellip;};. Some programmers balk at this because it is enforced by people rather
   than by technology, but don't knock it on face value: it is quite effective
   in practice.
</p>
<p>
   A slightly trickier technical approach is to exploit virtual
   inheritance. Since the most derived class's ctor needs to directly call the
   virtual base class's ctor, the following guarantees that no concrete class
   can inherit from class Fred:
</p>



<pre class="example">class Fred;

class FredBase {
protected:
  FredBase() { }
};

class Fred : private virtual FredBase {
public:
...
};
</pre>


<p>
   Class Fred can access FredBase's ctor, since Fred is deprived from FredBase,
   but no class derived from Fred can access FredBase's ctor (note 1),and therefore no
   one can create a concrete class derived from Fred.
</p>
<p>
   note 1:
   'no class derived from Fred can access FredBase's ctor' need 3 constrains be considered:
</p><ol>
<li>FredBase() must be
      case1: protected and Fred derives from Fred or
      case2: FredBase() is private , Fred derived from FredBase and is a friend of Fred
</li>
<li>Fred must private inherits from FredBase on case 1 or protected inherits from FredBase on case 2
</li>
<li>virtual inherits is a must for Fred, because:

<p>
      When a base class is inherited virtualy, it is up to the <b>most derived</b>
      class to initialize it.
</p>
<p>
      in our case, if class F deprived from Fred, it's F's duty to initialize Fred, which is impossible since
      Fred's ctor is not accessable.
</p>
<p>
      about virtual inheritance, check attached virtual.cpp
</p></li>
</ol>





<pre class="example">~@sunway-lab&gt; ./a.out
ctor for FredBase called
ctor for Fred called
ctor for Fred2 called
</pre>


</div>

</div>

<div id="outline-container-1-19" class="outline-3">
<h3 id="sec-1-19"><span class="section-number-3">1.19</span> never throw exceptions in dtor</h3>
<div class="outline-text-3" id="text-1-19">

<p>[17.3] How can I handle a destructor that fails?
</p>
<p>
Write a message to a log-file. Or call Aunt Tilda. But do not throw an exception!
Here's why (buckle your seat-belts):
</p>
<p>
The C++ rule is that you must never throw an exception from a destructor that is
being called during the "stack unwinding" process of another exception. For
example, if someone says throw Foo(), the stack will be unwound so all the stack
frames between the throw Foo() and the } catch (Foo e) { will get popped. This
is called stack unwinding.
</p>
<p>
During stack unwinding, all the local objects in all those stack frames are
destructed. If one of those destructors throws an exception (say it throws a Bar
object), the C++ runtime system is in a no-win situation: should it ignore the
Bar and end up in the } catch (Foo e) { where it was originally headed? Should
it ignore the Foo and look for a } catch (Bar e) { handler? There is no good
answer ― either choice loses information.
</p>
<p>
So the C++ language guarantees that it will call terminate() at this point, and
terminate() kills the process. Bang you're dead.
</p>
<p>
The easy way to prevent this is never throw an exception from a destructor. But
if you really want to be clever, you can say never throw an exception from a
destructor while processing another exception. But in this second case, you're
in a difficult situation: the destructor itself needs code to handle both
throwing an exception and doing "something else", and the caller has no
guarantees as to what might happen when the destructor detects an error (it
might throw an exception, it might do "something else"). So the whole solution
is harder to write. So the easy thing to do is always do "something else". That
is, never throw an exception from a destructor.
</p>
<p>
Of course the word never should be "in quotes" since there is always some
situation somewhere where the rule won't hold. But certainly at least 99% of the
time this is a good rule of thumb.
</p>
</div>

</div>

<div id="outline-container-1-20" class="outline-3">
<h3 id="sec-1-20"><span class="section-number-3">1.20</span> what is type-safe and strong type</h3>
<div class="outline-text-3" id="text-1-20">

<p>   <a href="http://hi.baidu.com/chenfalei/blog/item/f33ac0133500ac21dd540186.html">http://hi.baidu.com/chenfalei/blog/item/f33ac0133500ac21dd540186.html</a>
   没有绝对的类型安全与强类型语言。类型安全都是相对的。
   比如C/C++基本的类型检查保证了一部分的类型安全，但它的 union/指针/强制转换/数组 却破坏了类型安全。
   绝对的类型安全是指：一旦程序通过编译，即不再存在除逻辑错误外的其他错误。
</p></div>

</div>

<div id="outline-container-1-21" class="outline-3">
<h3 id="sec-1-21"><span class="section-number-3">1.21</span> why pop<sub>back</sub> returns void instead of the removed object?</h3>
<div class="outline-text-3" id="text-1-21">

<ul>
<li>The SGI's docs contain the reasoning - it's from queue's documentation
     but it also applies for deque:
     "One might wonder why pop() returns void, instead of value<sub>type</sub>. That
     is, why must one use front() and pop() to examine and remove the
     element at the front of the queue, instead of combining the two in a
     single member function? In fact, there is a good reason for this
     design. If pop() returned the front element, it would have to return
     by value rather than by reference: return by reference would create a
     dangling pointer. Return by value, however, is inefficient: it
     involves at least one redundant copy constructor call. Since it is
     impossible for pop() to return a value in such a way as to be both
     efficient and correct, it is more sensible for it to return no value
     at all and to require clients to use front() to inspect the value at
     the front of the queue."
</li>
<li>exception safety
     假设 pop<sub>back</sub>()定义为：
</li>
</ul>




<pre class="example">T topValue=vector1.pop();

T pop_back() {
    T temp=vec[top];
    --top;
    return temp; // what about if the copy assignment or copy constructor of temp-&gt;topValue fails?
}
</pre>


</div>

</div>

<div id="outline-container-1-22" class="outline-3">
<h3 id="sec-1-22"><span class="section-number-3">1.22</span> 数组蜕化为指针及数组引用做为函数参数</h3>
<div class="outline-text-3" id="text-1-22">





<pre class="example">#include &lt;iostream&gt;
using namespace std;

void f (int (&amp; a) [10]) {
    cout&lt;&lt;a[0]&lt;&lt;endl;
    cout&lt;&lt;sizeof(a)&lt;&lt;endl;
}
void g (int a []) {
    f (a);
}
int
main(int argc, char *argv[]) {
    int a[10]={9};
    g (a);
    return 0;
}
</pre>

<p>
编译错误
</p>



<pre class="example">#include &lt;iostream&gt;
using namespace std;

void f (int (&amp; a) [10]) {
    cout&lt;&lt;a[0]&lt;&lt;endl;
    cout&lt;&lt;sizeof(a)&lt;&lt;endl;
}
int
main(int argc, char *argv[]) {
    int a[10]={9};
    f (a);
    return 0;
}
</pre>

<p>
编译正确
</p>
<p>
可见,数组作为参数会蜕化为指针,但数组引用做为参数不会
</p></div>

</div>

<div id="outline-container-1-23" class="outline-3">
<h3 id="sec-1-23"><span class="section-number-3">1.23</span> c++ template 链接问题 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="template">template</span>&nbsp;<span class="__">模板</span></span></h3>
<div class="outline-text-3" id="text-1-23">

<p>   or 为什么c++ template的声明和定义通常在同一个文件,而不把定义单独编译成目标文件
   因为c++ template is instantiated at compile time.
   <a href="http://en.wikibooks.org/wiki/C++_Programming/Template">http://en.wikibooks.org/wiki/C%2B%2B_Programming/Template</a>
</p></div>

</div>

<div id="outline-container-1-24" class="outline-3">
<h3 id="sec-1-24"><span class="section-number-3">1.24</span> The Standard Librarian: Containers of Incomplete Types</h3>
<div class="outline-text-3" id="text-1-24">

<p>   <a href="http://www.ddj.com/database/184403814">http://www.ddj.com/database/184403814</a>
</p></div>

</div>

<div id="outline-container-1-25" class="outline-3">
<h3 id="sec-1-25"><span class="section-number-3">1.25</span> 临时对象的const引用 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="__">引用</span>&nbsp;<span class="const">const</span>&nbsp;<span class="__">常量</span></span></h3>
<div class="outline-text-3" id="text-1-25">

<p>   string foo() {return string("abc");}
   const string &amp; a=foo();
   是合法的,这是C++对大量存在的 foo (const &amp; T) 类型的函数的折衷
   string &amp; a=foo()是非法的
   类似的,对于foo("abc")的调用,void foo(const string &amp; s)是合法的,void foo(string &amp; s)是非法的,除非
   string a("abc");string &amp; b=a; foo(b);
</p>
<p>
   虽然c++要求返回的临时对象的引用必须是const,但在gcc里,复杂对象通常都是用
   named-return-value,所以返回的临时对象实际上必然在调用者的栈中,所以
</p>



<pre class="example">main (int argc, char * argv[]) {
 const T &amp; t=fun ();
 T &amp; tt=const_cast&lt;T &amp;&gt;(t);
 tt.a=19;
 printf ("%d\n",t.a);
 return 0;
 }
</pre>

<p>
    并没有问题
    main的栈:
    临时对象a
    引用t的指针,指向临时对象a
</p>
</div>

</div>

<div id="outline-container-1-26" class="outline-3">
<h3 id="sec-1-26"><span class="section-number-3">1.26</span> bitwise copy</h3>
<div class="outline-text-3" id="text-1-26">

<p>   <a href="http://blogs.msdn.com/slippman/archive/2004/01/20/60655.aspx">http://blogs.msdn.com/slippman/archive/2004/01/20/60655.aspx</a>
   <a href="http://www.cppblog.com/jerysun0818/archive/2006/05/05/6632.html">http://www.cppblog.com/jerysun0818/archive/2006/05/05/6632.html</a>
</p>
<p>
   In practice, a good compiler can generate bitwise copies for most class objects since they
   have bitwise copy semantics….
   That is, a copy constructor is not automatically generated by the compiler for each class that
   does not explicitly define one.
</p>
<p>
   Default constructors and copy constructors…are generated (by the compiler) where needed.
   Needed in this instance means when the class does not exhibit bitwise copy semantics
   When are bitwise copy semantics not exhibited by a class? There are four instances:
</p>
<ol>
<li>When the class contains a member object of a class for which a copy constructor exists
      (either explicitly declared by the class designer, as in the case of the previous String
      class, or synthesized by the compiler, as in the case of class Word)
</li>
<li>When the class is derived from a base class for which a copy constructor exists (again,
      either explicitly declared or synthesized)
</li>
<li>When the class declares one or more virtual functions
</li>
<li>When the class is derived from an inheritance chain in which one or more base classes are virtual
</li>
</ol>



<p>
   如果一个类的成员中有指针成员，如果它又有bitwise copy semantics(如无虚函数，成
   员类没有定义copy constructor..),默认会使用bitwise copy,但是对指针做shadow
   copy在对象析构时指针成员可能会被多次delete,所以对于这个类要自定义copy
   constructor使其丧失bitwise copy semantics
</p>
</div>

</div>

<div id="outline-container-1-27" class="outline-3">
<h3 id="sec-1-27"><span class="section-number-3">1.27</span> 可怜的bool</h3>
<div class="outline-text-3" id="text-1-27">

<p>发信人: Oversense (空), 信区: CPlusPlus
标  题: 可怜的bool
发信站: BBS 水木清华站 (Mon Oct 21 17:53:11 2002), 转信
</p>
<p>
可怜的bool
</p>
<p>
作者: Jim Hyslop 和 Herb Sutter
翻译：oversense &lt;17:33 2002-10-21&gt;
出处: <a href="http://www.cuj.com/experts/2011/hyslop.htm?topic=experts">http://www.cuj.com/experts/2011/hyslop.htm?topic=experts</a>
</p>
<p>
嘿嘿&hellip;今天的活比较爽！前几天写了点破程序，今天改改就搞定了。
哎，真困！喝点咖啡，靠在我的小椅子上，看看我的代码&hellip;
</p>
<p>
神奇，这是啥？
void f()
{
 TextHandler t;
 t.sendText("Hello, world", true);
// &hellip;
}
</p>
<p>
后面那个true是什么东东？翻翻定义:
class TextHandler
{
public:
 void sendText( const std::string &amp; msg,
                bool sendNewLine );
//&hellip;
};
</p>
<p>
喝点coffee，我想起来了，true表示sendText函数自动加上一个回车换行，我怎
么忘了？难道是我笨？我陷入迷茫的沉思&hellip;
</p>
<p>
砰！！！的一声巨响，我一慌张，嘴里的咖啡差点喷出来，还好我嘴紧。一定是Guru合上
了她的什么大头书。我转向她，挤出一点微笑。她手里拿着一本不到一百页的小册子。
神奇，这么小的书弄得这么响，她是怎么弄得？
</p>
<p>
显然，她什么都知道了。
</p>
<p>
"我的宝贝！如果你这么快就忘了参数的含义，那么当其他程序员第一次看你的代
码的时候，他怎么明白你要表达的意思呢？"
</p>
<p>
"嗯，是啊" 我咕噜道 "但是在IDE里面，他只要把鼠标移到函数上，他就可以看
到参数说明了啊！"
</p>
<p>
"有些IDE如此，并非全部，甚至不是大多数！我说过很多次，源代码最主要的用途
是用来交流，对意图的交流。我手中这本古老的，令人尊敬的卷册阐述了交流的艺术。
在这儿，它写道，'使用明确，详细，具体的语言'<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup>，你代码中的bool与此无缘，
他不能传递任何有用的信息给读者。 "
</p>
<p>
"不哈，一旦他知道这个bool是什么意思，就很容易记住了哈！"我中气不足的说。
</p>
<p>
Guru用她美丽而坚定的蓝眼睛盯着我，我心里扑通扑通跳起来。
</p>
<p>
"你多久以前写的这段代码？"Guru很温柔的说道&ndash;那种我喜欢的温柔。
"嗯，好，嗯，那如何改正呢？"我巧妙的回避她的问题。
"你不能另外想一种方式去表达你的意图吗？"她也不直接回答我，我们就好像在
煎鸡蛋。
</p>
<p>
"我可以不要第二个参数，让用户自己加 '\n' 好了。"我边说边写:
{
 t.sendText("Hello, world\n");
}
"如果传递给sendText是一个变量呢？" Guru问。
"那就这样好了"
{
 t.sendText( variable );
 t.sendText( "\n" );
}
我抬头看到Guru脸色不善，赶紧说道:
"那就这样，我提供两个函数"
void sendText( const std::string &amp; );
void sendTextWithNewLine( const std::string &amp; );
</p>
<p>
"没有其他的办法了吗？"Guru思考的时候，微微皱眉。
哎，看来我今天不要想轻松溜走了，我一阵猛想&hellip;&hellip;什么也没想出来，我投降
了，"就这样吧！"
</p>
<p>
"关于你的问题，你还要认识一点" Guru写道:
void displayText( const std::string &amp;,
                  bool applyItalics,
                  bool applyBold );
void f(){
    displayText( "This is bold but not italic",true, false );
}
"如果一个程序员要用斜体显示文字，但是弄错了参数顺序，那么这些文字就要用
粗体显示了，而且显然编译器无法发现这个错误。"
</p>
<p>
"如果Bob拿到了这段代码，改变了参数的顺序，一种叫做'Permute And Baffle'
的技术<sup><a class="footref" name="fnr-.3" href="#fn-.3">3</a></sup>。会怎样？"
</p>
<p>
"显然，问题多多的displayText不能得到 '明确，详细，具体' 的参数。"
</p>
<p>
"现在来看你的问题，你的第一个方案，因为displayText需要其他参数而没法用
。你的第二个方案，
可以工作，但是如果displayText需要很多信息，比如颜色，字体等，你是不是要
提供如此多的函数呢？"
</p>
<p>
"所以，我们可以用enumerated."
"Enumerations?"我奇怪的说。
</p>
<p>
"是的，Enumerations在这儿能得到很好的应用，看，"
class TextHandler
{
public:
 enum NewLineDisposition { sendNewLine, noNewLine };
 void sendText( const std::string &amp;, NewLineDisposition );
};
void f()
{
 TextHandler t;
 t.sendText( "Hello, ", TextHandler::noNewLine );
 t.sendText( "world", TextHandler::sendNewLine );
}
"这种写法很好，这段代码现在self-documenting了，不需要注释，意图和结果都
很清楚。看得人不需要去查找函数的定义了。"
"而且，这种写法有很好的扩展性，如果你需要只加一个回车，你只需要在enume
ration中加上prependNewLine就可以了，现有的代码无需任何改变。"
</p>
<p>
"不要抛弃你第一个方案，宝贝。在有的情况下，他是最优的。"Guru转过身，重
新打开那本书，优雅而轻快的走开，消失在拐角处。
</p>
<p>
注解:
</p>
</div>

</div>

<div id="outline-container-1-28" class="outline-3">
<h3 id="sec-1-28"><span class="section-number-3">1.28</span> operator new &nbsp;&nbsp;&nbsp;<span class="tag"><span class="new">new</span>&nbsp;<span class="delete">delete</span></span></h3>
<div class="outline-text-3" id="text-1-28">

<p>   <a href="http://www.scs.cs.nyu.edu/~dm/c++-new.html">http://www.scs.cs.nyu.edu/~dm/c++-new.html</a>
</p>


<pre class="example">#include &lt;iostream&gt;
using namespace std;

class Test {
    int val;
public:
    Test (int v):val (v) {cout&lt;&lt;val&lt;&lt;endl;}
    void * operator new (size_t size,int count) {cout&lt;&lt;__LINE__&lt;&lt;endl;return malloc (size);}
    void operator delete( void * p,size_t size ) {cout&lt;&lt;size&lt;&lt;endl;free (p);}
    //new和delete只负责分配释放内存，不负责ctor和dtor调用
};

int
main(int argc, char ** argv) {
    Test * t=new (10) Test (20);
    Test tt; //局部变量不使用operator new和operator delete
    return 0;
}
</pre>

</div>

</div>

<div id="outline-container-1-29" class="outline-3">
<h3 id="sec-1-29"><span class="section-number-3">1.29</span> prefrer ++i to i++</h3>
<div class="outline-text-3" id="text-1-29">

<p>   For builtin types, it really doesn't matter. But in C++, you can write
   and operator++ for your own class. And then it might matter, becaure
   postfix ++ has to create a copy of the object so that the old value can
   be returned. If you don't need the return value, that copy is
   unnecessary. If the compiler doesn't do named return value
   optimization, that copy might even need to be copied again, and all
   that just to throw the result away. The postfix operator++ for an own
   class might look something like this:
</p>



<pre class="example">MyClass MyClass::operator++(int)
{
MyClass retval(*this); // copy the object
// do whatever is needed to "increment" the object
reutrn retval; // return the copy by value
}
</pre>


<p>
   while prefix ++ might look like:
</p>



<pre class="example">MyClass&amp; MyClass::operator++()
{
// do whatever is needed to "increment" the object
return *this; // return a refernce to the object
}
</pre>


<p>
   Therefore, it's considered a good habit to always use prefix ++ if the
   return value is not needed.
</p>
</div>

</div>

<div id="outline-container-1-30" class="outline-3">
<h3 id="sec-1-30"><span class="section-number-3">1.30</span> Decorator pattern</h3>
<div class="outline-text-3" id="text-1-30">

<p><a href="http://en.wikipedia.org/wiki/Decorator_pattern">http://en.wikipedia.org/wiki/Decorator_pattern</a>
</p>



<pre class="example">#include &lt;iostream&gt;
using namespace std;

class B {
public:
    virtual void fun () {cout&lt;&lt;"C"&lt;&lt;endl;}
};

class Dec:public B {
    B * pbase;
public:
    Dec (B * b):pbase(b) {}
    virtual void fun () {cout&lt;&lt;"Dec"&lt;&lt;endl;pbase-&gt;fun ();}
};

int
main(int argc, char ** argv) {
    B * b=new Dec(new Dec (new B));
    b-&gt;fun ();

    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-31" class="outline-3">
<h3 id="sec-1-31"><span class="section-number-3">1.31</span> 一个Printable类</h3>
<div class="outline-text-3" id="text-1-31">




<pre class="example">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
using namespace std;
class Printable {
    virtual string to_str () const=0;
public:
    friend ostream &amp; operator&lt;&lt;(ostream &amp;,const Printable &amp;);
};

ostream &amp; operator&lt;&lt;(ostream &amp; o,const Printable &amp; p) {
    return o&lt;&lt;p.to_str ()&lt;&lt;endl;
}

class Test:public Printable {
    int a;
    int b;
private:
    string to_str () const {
        stringstream ss;
        ss&lt;&lt;a&lt;&lt;" ";
        ss&lt;&lt;b&lt;&lt;endl;
        return ss.str ();
    }
public:
    Test (int a,int b):a (a),b (b) {}
};
int
main(int argc, char ** argv) {
    Test t (1,2);
    cout&lt;&lt;t;
    return 0;
}
</pre>

</div>

</div>

<div id="outline-container-1-32" class="outline-3">
<h3 id="sec-1-32"><span class="section-number-3">1.32</span> 类型转换</h3>
<div class="outline-text-3" id="text-1-32">

<p>   假设需要一个X到Y的转换：
</p>
<ul>
<li>Y内定义 Y(const X &amp;) ()构造函数
</li>
<li>X内定义 operator Y() {return Y;}函数
</li>
</ul>


<p>
   自定义的类型转换也可以被隐式调用，
   例如 Y实现了 friend ostream &amp; operator &lt;&lt;(ostream &amp;,const Y &amp;) 使Y可以通过 cout&lt;&lt;Y的
   形式调用，如果在Y或X中定义了X到Y的转换，则cout&lt;&lt;X时，X会被隐式的转换为Y并调用operator&lt;&lt;(cout,Y)
   另外，自定义的类型转换也是static<sub>cast能否成功的根据之一</sub>
</p></div>

</div>

<div id="outline-container-1-33" class="outline-3">
<h3 id="sec-1-33"><span class="section-number-3">1.33</span> cast</h3>
<div class="outline-text-3" id="text-1-33">

<ul>
<li>'reinterpret<sub>cast'</sub> 只能用于指针或引用'reinterpret<sub>cast'</sub> casts a pointer to
     any other type of pointer. It also allows casting from pointer to an
     integer type and vice versa. This operator can cast pointers between
     non-related classed. The operation results is a simple binary copy of the
     value from a pointer to the other. The content pointed does not pass any
     kind of check nor transformation between types. In the case that the copy
     is performed from a pointer to an integer, the interpretation of its
     content is system dependent and therefore any implementation is non
     portable. A pointer casted to an integer enough large to fully contain it
     can be casted back to a valid pointer.

<p>
     Code:
</p></li>
</ul>





<pre class="example">class A {};
class B {};

A * a = new A;
B * b = reinterpret_cast&lt;B *&gt;(a);
</pre>


<p>
     'reinterpret<sub>cast'</sub> treats all pointers exactly as traditional type-casting operators do.
</p>
<ul>
<li>'dynamic<sub>cast'</sub> 只能用于指针或引用

<p>
     'dynamic<sub>cast'</sub> is exclusively used with pointers and references to
     objects. It allows any type-casting that can be implicitly performed as
     well as the inverse one when used with polymorphic classes, however, unlike
     static<sub>cast</sub>, dynamic<sub>cast</sub> checks, in this last case, if the operation is
     valid. That is to say, it checks if the casting is going to return a valid
     complete object of the requested type. Checking is performed during
     run-time execution. If the pointer being casted is not a pointer to a valid
     complete object of the requested type, the value returned is a 'NULL'
     pointer.
</p>
<p>
     dynamic<sub>cast使用了RTTI来确定能否转换成功</sub>,而只有支持多态的类(有虚函数)才在
     vtbl中有相应的RTTI信息,所以:
</p></li>
</ul>




<pre class="example">class Base {

};
class Derived:public Base {

};

Base * b=new Derived();
dynamic_cast&lt;Derived *&gt;(b)不会成功,因为没有vtbl,即没有RTTI信息

</pre>


<p>
     Code:
</p>


<pre class="example">class Base { virtual dummy() {} };
class Derived : public Base {};

Base* b1 = new Derived;
Base* b2 = new Base;

Derived* d1 = dynamic_cast&lt;Derived *&gt;(b1);          // succeeds
Derived* d2 = dynamic_cast&lt;Derived *&gt;(b2);          // fails: returns 'NULL'
</pre>


<p>
     If the type-casting is performed to a reference type and this casting is not possible an exception of type 'bad<sub>cast'</sub> is thrown:
</p>
<p>
     Code:
</p>



<pre class="example">class Base { virtual dummy() {} };
class Derived : public Base { };

Base* b1 = new Derived;
Base* b2 = new Base;

Derived d1 = dynamic_cast&lt;Derived &amp;*&gt;(b1);          // succeeds
Derived d2 = dynamic_cast&lt;Derived &amp;*&gt;(b2);          // fails: exception thrown
</pre>


<ul>
<li>'static<sub>cast'</sub>

<p>
     'static<sub>cast'</sub> allows to perform any casting that can be implicitly
     performed as well as also the inverse cast (even if this is not allowed
     implicitly). Applied to pointers to classes, that is to say that it allows
     to cast a pointer of a derived class to its base class (this is a valid
     conversion that can be implicitly performed) and can also perform the
     inverse: cast a base class to its derivated class. In this last case the
     base class that is being casted is not checked to determine wether this is
     a complete class of the destination type or not. Code:
</p></li>
</ul>




<pre class="example">class Base {}; class
Derived : public Base {};

Base *a    = new Base;
Derived *b = static_cast&lt;Derived *&gt;(a);
'static_cast', aside from manipulating pointers to classes, can also be used to perform conversions explicitly defined in classes, as well as to perform standard conversions between fundamental types:
Code:
double d = 3.14159265;
int    i = static_cast&lt;int&gt;(d);
</pre>



<ul>
<li>'const<sub>cast'</sub>

<p>
     This type of casting manipulates the const attribute of the passed object, either to be set or removed:
</p>
<p>
     Code:
</p></li>
</ul>




<pre class="example">class C {};
const C *a = new C;
C *b = const_cast&lt;C *&gt;(a);

</pre>

<p>
     Neither of the other three new cast operators can modify the constness of an object.
     Notes:
     It is undefined behaviour if the pointer is used to write on an constant object (an object declared as 'const').
     The 'const<sub>cast'</sub> operator can also change the 'volatile' qualifier on a type.
</p>
<p>
     总结:
     reinterpret<sub>cast是不懂c</sub>++语法的,也不会使用rtti信息,这就决定了它不能解析c++的类结构,如多重继承,虚拟继承这些复杂的结构.
     指针的reinterpret<sub>cast的过程中</sub>,值是不会变的,改变的只是对这个值的处理方式(当作c的指针还是当作d的指针)
</p>
<p>
     static<sub>cast是懂c</sub>++的语法的,它能了解编译时的ctti信息,能够在处理多重继承,虚拟继承等复杂结构.
     B
     C1:virtual B
     C2:virtual B
     D:C1,C2
     D * d=new D()能成功static<sub>cast到B</sub>*,C1*或C2*,因为static<sub>cast了解继承的树</sub>
</p>
<p>
     static<sub>cast是编译时的行为</sub>,它不能正确处理的情况是:
     B
     C1:virtual B
     C2:virtual B
     D:C1,C2
     void foo(B * b) {
     D * d=static<sub>cast&lt</sub>;D *&gt;(b);
     }
     如果:
     B * b=new B();
     foo(b); 程序会出错,因为static<sub>cast不知道foo的参数b到底是不是真的D</sub>*,编译时的static<sub>cast只能假设它是了</sub>
</p>
<p>
     这时就需要dynamic<sub>cast了</sub>,dynamic<sub>cast的static</sub><sub>cast的功能基本相同</sub>,但它使用了
     rtti信息,可以正确处理从基类到派生类的转换,由于使用了rtti,只有有虚函数或虚基类的类才能使用.
</p>
<p>
     另外,c++中的(B *)d式的转换相当于编译器按
     const<sub>cast</sub>,static<sub>cast</sub>,dynamic<sub>cast</sub>,reinterpret<sub>cast的顺序挨个测试能否转换成</sub>
     功,reinterpret<sub>cast是最后的选择</sub>
</p>
</div>

</div>

<div id="outline-container-1-34" class="outline-3">
<h3 id="sec-1-34"><span class="section-number-3">1.34</span> RTTI与CTTI</h3>
<div class="outline-text-3" id="text-1-34">

<p>   RTTI是在多态类的vtbl中存储的类型信息,非多态类没有RTTI信息
   dynamic<sub>cast和typeid需要使用RTTI信息</sub>
   typeid可以得到类型信息,如typeid(1).name(),或typeid(myclass).name()
   但并非所有的typeid都是使用了RTTI,因为:
</p><ul>
<li>typeid是运算符,而不是函数,所以typeid的值可能在编译时就能确定
</li>
<li>对于非多态类型,如内置数据类型,或自定义的非多态的类,typeid使用的是CTTI,即编译时就确定类型
     而对于多态类型,typeid通过查询多态类的vtbl中的RTTI信息确定类型
</li>
</ul>

</div>

</div>

<div id="outline-container-1-35" class="outline-3">
<h3 id="sec-1-35"><span class="section-number-3">1.35</span> 重载 &lt;&lt;</h3>
<div class="outline-text-3" id="text-1-35">




<pre class="example">#include &lt;iostream&gt;
using std::cout;
using std::endl;

struct foo {
    short a;
    char  b;
    char  c;
    int   d;
};

int
main(int argc, char ** argv) {
    int c=('A' &lt;&lt; 16) + ('B' &lt;&lt; 8) + 'C';
    foo f = {1234, 'x', 'y', ('D' &lt;&lt; 24 )+('A' &lt;&lt; 16) + ('B' &lt;&lt; 8) + 'C'};
    cout&lt;&lt;&amp;f.b&lt;&lt;endl;
    return 0;
}


#include &lt;iostream&gt;
#include &lt;iostream&gt;
using namespace std;


class foo {
    short a;
    char  b;
    char  c;
    int   d;
public:
    foo (short a,char b,char c,int d):a (a),b (b),c (c),d (d) {}
    friend ostream&amp; operator&lt;&lt;(ostream&amp; output,const foo &amp; f);

};

ostream &amp; operator&lt;&lt;(ostream&amp; output,const foo &amp; f) {
    output&lt;&lt;f.a&lt;&lt;endl;
}
int
main(int argc, char ** argv) {
    int c=('A' &lt;&lt; 16) + ('B' &lt;&lt; 8) + 'C';
    foo f (1234, 'x', 'y', ('D' &lt;&lt; 24 )+('A' &lt;&lt; 16) + ('B' &lt;&lt; 8) + 'C');
    cout&lt;&lt;f;
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-36" class="outline-3">
<h3 id="sec-1-36"><span class="section-number-3">1.36</span> mask</h3>
<div class="outline-text-3" id="text-1-36">




<pre class="example">string mask (const string &amp; ip, const string &amp; mask) {
//{{{
struct sockaddr_in servaddr;
bzero (&amp;servaddr, sizeof (servaddr));
servaddr.sin_family = AF_INET;
inet_pton (AF_INET, ip.c_str (), &amp;servaddr.sin_addr);
in_addr_t ip_digit=servaddr.sin_addr.s_addr;
inet_pton (AF_INET, mask.c_str (), &amp;servaddr.sin_addr);
in_addr_t mask_digit=servaddr.sin_addr.s_addr;
in_addr_t tmp=ip_digit&amp;mask_digit;
servaddr.sin_addr.s_addr=tmp;
char * ret=(char *)malloc (20);
inet_ntop (AF_INET,&amp;servaddr.sin_addr,ret,20);
string rets=string (ret);
free (ret);
return rets;
}
//}}}
</pre>

</div>

</div>

<div id="outline-container-1-37" class="outline-3">
<h3 id="sec-1-37"><span class="section-number-3">1.37</span> copy构造函数与vtl</h3>
<div class="outline-text-3" id="text-1-37">





<pre class="example">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class A {
    int a;
public:
    A () {}
    A (const A &amp; a) {memcpy (this,&amp;a,sizeof(a));}
    virtual void fun () {cout&lt;&lt;"A"&lt;&lt;endl;}

};

class B:public A {
public:
    B (){}
    void fun () {cout&lt;&lt;"B"&lt;&lt;endl;}

};
int
main(int argc, char ** argv) {
    B b;
    A a=b;
    A * ptra=&amp;a;
    ptra-&gt;fun ();
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-38" class="outline-3">
<h3 id="sec-1-38"><span class="section-number-3">1.38</span> 类对象的几种声明方法：</h3>
<div class="outline-text-3" id="text-1-38">

<p>使用构造函数和copy构造函数（但copy构造函数的调用通常被编译器优化掉）
</p><ul>
<li>A a=A();
</li>
<li>A a=A(1);
</li>
</ul>

<p>没使用copy构造函数
</p><ul>
<li>A a;
</li>
<li>A a(1);
</li>
</ul>

<p>使用了copy构造函数但被优化掉和没使用copy构造函数的区别是：当copy构造函数为private时&hellip;.
</p>
<p>
指针形式
</p><ul>
<li>A * a=new A()
</li>
<li>A * a=new A(1)
</li>
</ul>


<p>
注意：
</p><ul>
<li>A a() 并不等同于 A a=A(),虽然它和A a(1)很像，实际上 A a()是一个函数声明&hellip;&hellip;a is a function returning A&hellip;&hellip;
</li>
</ul>


</div>

</div>

<div id="outline-container-1-39" class="outline-3">
<h3 id="sec-1-39"><span class="section-number-3">1.39</span> virtual函数,vptr例子</h3>
<div class="outline-text-3" id="text-1-39">





<pre class="example">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class A {

public:
    virtual void fun () {cout&lt;&lt;"A"&lt;&lt;endl;}
};
class B {

public:
    virtual void fun () {cout&lt;&lt;"B"&lt;&lt;endl;}
};

int
main(int argc, char ** argv) {
    A * a=new A;
    B * b=new B;
    void * ptra=reinterpret_cast&lt;void *&gt;(a);
    void * ptrb=reinterpret_cast&lt;void *&gt;(b);
    memcpy (ptrb,ptra,1);
    b-&gt;fun ();
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-40" class="outline-3">
<h3 id="sec-1-40"><span class="section-number-3">1.40</span> 成员函数的调用</h3>
<div class="outline-text-3" id="text-1-40">





<pre class="example">#include &lt;iostream&gt;
using namespace std;

class AA {
    static int foo;
public:
    void fun ();
};
class AAA:public AA {
public:
};
void AA::fun() {
    cout&lt;&lt;"AA"&lt;&lt;endl;
}

int
main(int argc, char ** argv) {
    AA a;
    AAA aa;
    void (* f)(AA *)=reinterpret_cast&lt;void (*)(AA *)&gt;(0x080486d8);
    f (&amp;a);
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-1-41" class="outline-3">
<h3 id="sec-1-41"><span class="section-number-3">1.41</span> virtual析构函数</h3>
<div class="outline-text-3" id="text-1-41">




<pre class="example">&lt;iostream&gt;
using std::cout;
using std::endl;

class Base{
public:
virtual ~Base(){cout&lt;&lt;"~B"&lt;&lt;endl;}
};

class Derived:public Base{
public:
virtual ~Derived(){cout&lt;&lt;"~D"&lt;&lt;endl;}
};

void main (){
Base *b=new Derived();
delete b;
}
</pre>

<p>
//执行结果
</p>


<pre class="example">~D
~B
</pre>

<p>
//解释
沿着程序执行流程，从main函数进入
首先，执行语句Base *b=new Derived();
结果是在堆中创建类Derived的一个对象，并且让类型为Base *的指针b指向这个对象；
其次，执行语句delete b;
运行结果是释放b指向对象的内存空间。按照C++的delete操作符的语义，编译器会指针b“对应类型”的对象的析构函数调用（你或许认为是Base::~Base()），但是由于类Base的析构函数声明为虚函数，因此实现方式具有多态特征（具体实现采用的技术请查看相关书籍，例如经典的Inside The C++ Object Model），因此运行时调用的析构函数是Derived::~Derived()。
第三，子类的析构函数Derived::~Derived()内部会调用父类的析构函数，因此执行结果如上！
</p>
<p>
基类中的虚析构函数使得派生类在使用多态性时也能被正确的析构。
</p></div>

</div>

<div id="outline-container-1-42" class="outline-3">
<h3 id="sec-1-42"><span class="section-number-3">1.42</span> <span class="done DONE">DONE</span> c++ string literal的类型是什么?</h3>
<div class="outline-text-3" id="text-1-42">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-10-07 二 15:23</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-10-07 二 15:23</span></span>
</li>
</ul>

<p>   "abc"的类型为const char <sup><a class="footref" name="fnr-.4" href="#fn-.4">4</a></sup>
</p>
</div>

</div>

<div id="outline-container-1-43" class="outline-3">
<h3 id="sec-1-43"><span class="section-number-3">1.43</span> <span class="done DONE">DONE</span> internal linkage , external linkage &amp; no linkage</h3>
<div class="outline-text-3" id="text-1-43">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-10-06 一 15:51</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-10-06 一 15:51</span></span>
     <a href="http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=41">http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=41</a>
</li>
</ul>

<p> 3.5 Program and linkage
</p>
<p>
 3 A name having namespace scope (3.3.5) has internal linkage
 if it is the name of
</p><ul>
<li>an object, reference, function or function template that
    is explicitly declared static or,
</li>
<li>an object or reference that is explicitly declared const
</li>
</ul>

<p> and neither explicitly declared extern nor previously
     declared to have external linkage; or
</p><ul>
<li>a data member of an anonymous union.

<p>
    4 A name having namespace scope has external linkage if it is
    the name of
</p></li>
<li>an object or reference, unless it has internal linkage; or
</li>
<li>a function, unless it has internal linkage; or
</li>
<li>a named class (clause 9), or an unnamed class defined in
     a typedef declaration in which the class has the
     typedef name for linkage purposes (7.1.3); or
</li>
<li>a named enumeration (7.2), or an unnamed enumeration defined
     in a typedef declaration in which the
     enumeration has the typedef name for linkage purposes
     (7.1.3); or
</li>
<li>an enumerator belonging to an enumeration with external
     linkage; or
</li>
<li>a template, unless it is a function template that has internal
     linkage (clause 14); or
</li>
<li>a namespace (7.3), unless it is declared within an unnamed
     namespace.
</li>
</ul>



<p>
     对不同linkage type的符号，ld需要做不同的处理：
</p><ol>
<li>external linkage
      1.c: extern int a;
      2.c: extern int a;
      1.c 2.c被编译成目标文件时，1.o, 2.o中对a的引用地址都为0,ld将1.o, 2.o链接以后才能确定a的实际地址
</li>
<li>internal linkage
      1.c: static int a;
      1.c被编译成1.o时，对a的引用地址是a在.data段是的偏移量，1.o被链接后a的实际地址是.data基址+a的偏移量
</li>
<li>no linkage
      1.c: main () {int a;a=1;}
      1.o中a=1中对a的引用地址即是a在.text段中的偏移量,即不需要链接
</li>
</ol>


<p>
1.c:
</p>


<pre class="example">static int a;
static int b;
int c;
int d;
int
main(int argc, char *argv[]) {
    a=a+1;
    b=b+2;
    c=c+3;
    d=d+4;
    int e;
    e=e+5;
    return 0;
}
</pre>


<p>
objdump -d 1.o:
</p>



<pre class="example">1.o:     file format elf32-i386

Disassembly of section .text:

00000000 &lt;main&gt;:
   0:   8d 4c 24 04             lea    0x4(%esp),%ecx
   4:   83 e4 f0                and    $0xfffffff0,%esp
   7:   ff 71 fc                pushl  -0x4(%ecx)
   a:   55                      push   %ebp
   b:   89 e5                   mov    %esp,%ebp
   d:   51                      push   %ecx
   e:   83 ec 10                sub    $0x10,%esp
  11:   a1 08 00 00 00          mov    0x8,%eax                 对a的引用地址是a在.data段的offset 0x8,internal linkage
  16:   83 c0 01                add    $0x1,%eax
  19:   a3 08 00 00 00          mov    %eax,0x8
  1e:   a1 0c 00 00 00          mov    0xc,%eax                 对b的引用地址是b在.data段的offset 0xc,internal linkage
  23:   83 c0 02                add    $0x2,%eax
  26:   a3 0c 00 00 00          mov    %eax,0xc
  2b:   a1 00 00 00 00          mov    0x0,%eax                 对c的引用地址是0x0,extern linkage
  30:   83 c0 03                add    $0x3,%eax
  33:   a3 00 00 00 00          mov    %eax,0x0
  38:   a1 00 00 00 00          mov    0x0,%eax                 对d的引用地址是0x0,extern linkage
  3d:   83 c0 04                add    $0x4,%eax
  40:   a3 00 00 00 00          mov    %eax,0x0
  45:   83 45 f8 05             addl   $0x5,-0x8(%ebp)          对e的引用地址是栈上的地址,no linkage
  49:   b8 00 00 00 00          mov    $0x0,%eax
  4e:   83 c4 10                add    $0x10,%esp
  51:   59                      pop    %ecx
  52:   5d                      pop    %ebp
  53:   8d 61 fc                lea    -0x4(%ecx),%esp
  56:   c3                      ret
</pre>


</div>

</div>

<div id="outline-container-1-44" class="outline-3">
<h3 id="sec-1-44"><span class="section-number-3">1.44</span> 临时对象(右值)可被修改?</h3>
<div class="outline-text-3" id="text-1-44">




<pre class="example">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;
class Test {
   char * p;
   int val;
public:
   Test (int val) {p=(char *)malloc (10);this-&gt;val=val;}
   ~Test () {free (p);p=0;cout&lt;&lt;"dtor called for "&lt;&lt;val&lt;&lt;endl;}
//    Test operator=(const Test &amp; t) {cout&lt;&lt;"calling ="&lt;&lt;endl;memcpy (this-&gt;p,t.p,10);cout&lt;&lt;"= done"&lt;&lt;endl;return *this;}
};

Test foo (int val) {return Test (val);}

int
main (int argc, char * argv[]) {
   Test t (1);
   foo (2)=t;
   std::cout&lt;&lt;"here"&lt;&lt;std::endl;
   return 0;
}
</pre>


<p>
 foo(2)返回一个Test()临时对象,是一个 右值,但它却是可以调用自己的成员而被修改! 这是C++中类对象做为右值时的特例,对于标准类型如int,C++还是与C兼容的.
 临时对象做为右值却可以通过自己的成员函数被修改,这主要是为了方便以下的应用:
 临时对象也可以调用成员函数,如 getClassA().getVal(),而不用写成 Class A a=getClassA(), a.getVal()
</p>
<p>
 另外,foo(2)=t时,foo(2)返回的临时对象直到这条语句执行完后才被析构.
 <a href="http://www.9php.com/FAQ/cxsjl/c/2007/11/925528897440.html">http://www.9php.com/FAQ/cxsjl/c/2007/11/925528897440.html</a>
</p></div>

</div>

<div id="outline-container-1-45" class="outline-3">
<h3 id="sec-1-45"><span class="section-number-3">1.45</span> <span class="done DONE">DONE</span> 左值与右值</h3>
<div class="outline-text-3" id="text-1-45">

<p>   <a href="#lval-rval">左值与右值</a>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-08-21 四 11:19</span></span>
</li>
</ul>


</div>

<div id="outline-container-1-45-1" class="outline-4">
<h4 id="sec-1-45-1"><span class="section-number-4">1.45.1</span> 函数返回引用</h4>
<div class="outline-text-4" id="text-1-45-1">

<p>    foo &amp; fun() 返回到foo的值用,是左值(当然决不能返回临时对象的引用)
    例如:
</p><ul>
<li><a href="#prefrer-i-to-i">prefer ++i to i++</a>
</li>
<li><a href="#sec-1-30">decorator pattern</a>
</li>
</ul>

</div>

</div>

<div id="outline-container-1-45-2" class="outline-4">
<h4 id="sec-1-45-2"><span class="section-number-4">1.45.2</span> <b>(void *</b>)(&amp;func<sub>pointer</sub>)=&hellip;</h4>
<div class="outline-text-4" id="text-1-45-2">





<pre class="example">void *dlsym(void *handle, const char *symbol);
int main(int argc, char **argv) {
void *handle;
double (*cosine)(double);
char *error;

handle = dlopen ("libm.so", RTLD_LAZY);
if (!handle) {
fprintf (stderr, "%s\n", dlerror());
exit(1);
}

dlerror();
//note the following line!
*(void **) (&amp;cosine) = dlsym(handle, "cos");
//it is equal to cosine=(double (*) (double))dlsym(handle,"cos");, using
//(void *)cosine=dlsym(..) is wrong, because (void *)cosine returns a rval
if ((error = dlerror()) != NULL)  {
fprintf (stderr, "%s\n", error);
exit(1);
}

printf ("%f\n", (*cosine)(2.0));
dlclose(handle);
return 0;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-46" class="outline-3">
<h3 id="sec-1-46"><span class="section-number-3">1.46</span> <span class="done DONE">DONE</span> when does cast alter the pointer's address</h3>
<div class="outline-text-3" id="text-1-46">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-12-15 一 17:35</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-12-15 一 17:35</span></span>
</li>
<li>多重继承时
</li>
</ul>




<pre class="example">class B1 {};
class B2 {};
class D:public B1,public B2 {};
D * pd=new D();
B1 * pb1=pd; //pb1=pd
B2 * pb2=pd; //pb2!=pd
</pre>


<p>
     图:
</p>


<pre class="example">+-----------------+
| B1 subclass  -  |&lt;-------pd,pb1 point to here
+-----------------+
| B2 subclass     |&lt;-------pb2 point to here
+-----------------+
| D subclass      |
+-----------------+
</pre>


<ul>
<li>virtual继承时
</li>
</ul>




<pre class="example">class B {};
class D:public virtual B {};
D * pd=new D();
B * pb=pd;  //即使是单继承,pb也不等于pd
</pre>


<pre class="example">                    +--pd point to here
图:                 |
                    |
+------------+      |
|D subclass  |&lt;-----+
|_vptr of D  |---------&gt;+---------------------+
+------------+          |offset to B subclasso|
|B subclass  |&lt;-----+   +---------------------+
+------------+      |   |RTTI and other virtua|
                    |   |l funcs              |
                    |   +---------+-----------+
                    |
                    +--pb point to here,pb equals to pd+_vptr[0]

</pre>

</div>

</div>

<div id="outline-container-1-47" class="outline-3">
<h3 id="sec-1-47"><span class="section-number-3">1.47</span> c++弱化了data段还是bss段?</h3>
<div class="outline-text-3" id="text-1-47">

<p>   和c一样,在c++里,main()之外的全局变量,函数中的static变量,类定义中的static变量都被自动初始化
   但与c不同的是,如果这些变量是类,会自动调用它们的ctor,看起来是bss被弱化了? 因为这些类不会被
   自动初始化为0
   实际上,是data被弱化了. 这些类被放在bss里,程序执行后,在main()之前,某些函数(如elf中的.init段)会调用
   它们的ctor来初始化这些类
</p></div>

</div>

<div id="outline-container-1-48" class="outline-3">
<h3 id="sec-1-48"><a name="6b44moj04he0-sunway-lab.bupt.edu.cn" id="6b44moj04he0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.48</span> 除了ctor,在一个类的所有成员函数中调用虚函数都是通过vptr机制 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-48">

<p>   因为:
</p><ol>
<li>test1的构造函数调用fun2时,test2还没建立起来,test1()首次将vptr指向自己的fun2,但test1()中对fun2的调用不通过vptr
</li>
<li>任何时候,通过test1的其他成员函数如fun1调用fun2时,都是通过vptr,因为本质上函数调用都是通过this指针
      test1 t; t.fun2() 时编译器可以知道t是确定的类,所以不使用vptr.但当程序进入fun1后,编译器已无法确定fun1(this)里的this到底
      是什么类型
</li>
</ol>

<p>   因为成员函数都是通过this指针调用,属于指针调用,所以在成员函数中对虚函数的调用都是通过vptr
</p>
</div>

</div>

<div id="outline-container-1-49" class="outline-3">
<h3 id="sec-1-49"><span class="section-number-3">1.49</span> <span class="done DONE">DONE</span> virtual inhereit in c++</h3>
<div class="outline-text-3" id="text-1-49">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-12-16 二 20:51</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-12-16 二 20:51</span></span>
</li>
</ul>




<pre class="example">class B {int a;};
class D1:public virtual B {}
class D2:public virtual B {}
class E:public D1,public D2 {}
</pre>

<ul>
<li>memory layout
</li>
</ul>




<pre class="example">D1:          +----------------+
+------+   /-+offset to B,ie,2|
| vptr |---  +----------------+
+------+     |RTTI info of D1 |
| int a|     +----------------|----------------------------+
+------+     |pointer to other virtual funcs if D1 has any |
             +---------------------------------------------+


E:
+------------+      +----------      --+
| D1 subclass|   /--+ offset to B,ie,3 |
| vptr       |---   |------------------+-----------+
+------------+      | RTTI and other virtual funcs |
| D2 subclass|      +------------------------------+
| vptr       |------ similar to vptr of D1, but offset to B is diff, ie,2
+------------+
| E subclass |
+------------+
| B subclass |
| int a      |
+------------+
</pre>


<ul>
<li>why a offset to base class is needed
     在D1,D2和E中,都需要在vptr里指定一个到B的offset,虽然B存储的位置就在d1,d2,e附近
     如果是通过B的派生类(而不是通过派生类指针)使用B的成员,不需要通过vptr指定的offset,因为对于确定的类型,如E,它的内存布局在编译时就确定了,
     B的成员在E中的位置编译时就已经确定,直接使用即可.
     而如果是通过派生类的指针使用B的成员,必须通过vptr指定的offset,例如:
     D1 * dp=new D1(), B紧接dp
     D1 * dp=new E(),B和dp之间还间隔了一个sizeof(D2)的距离
     D2 * dp2=new E(), B紧接dp2
     所以必须通过D1的vptr中指定的offset才能找到B

</li>
<li>difference when accessing base class member from pointer to derived class or from a derived class
     (something like access virtual function through pointer or not)
     <a href="http://www.phpcompiler.org/articles/virtualinheritance.html">http://www.phpcompiler.org/articles/virtualinheritance.html</a>
</li>
</ul>

</div>

</div>

<div id="outline-container-1-50" class="outline-3">
<h3 id="sec-1-50"><a name="41b8eg214he0-sunway-lab.bupt.edu.cn" id="41b8eg214he0-sunway-lab.bupt.edu.cn"></a><span class="section-number-3">1.50</span> <span class="done DONE">DONE</span> c++ pointer-to-member variable and functions &nbsp;&nbsp;&nbsp;<span class="tag"><span class="ATTACH">ATTACH</span></span></h3>
<div class="outline-text-3" id="text-1-50">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-12-17 三 17:07</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-12-17 三 17:07</span></span>
</li>
<li>what on earth a pointer-to-member pointer 'point' to?
<ol>
<li>到类的普通成员函数的指针是函数的真实物理地址
</li>
<li>到类的虚成员函数的指针是虚函数在vtbl中的偏移量
</li>
<li>到类的成员的指针是类成员在类中的偏移量
</li>
</ol>

</li>
</ul>

</div>

</div>

<div id="outline-container-1-51" class="outline-3">
<h3 id="sec-1-51"><span class="section-number-3">1.51</span> <span class="done DONE">DONE</span> c++ inline function</h3>
<div class="outline-text-3" id="text-1-51">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-12-23 二 10:23</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-12-23 二 10:23</span></span>
</li>
</ul>




<pre class="example">5.cpp
#include &lt;stdio.h&gt;
//typedef void (*fp) ();
inline void fun () {
   //fp tmp=fun;
   printf ("test\n");
}
void f () {
   fun ();
}

6.cpp
//typedef void (*fp) ();
inline void fun ();
int
main(int argc, char *argv[]) {
//    fp tmp=fun;
//    (*tmp)();
   fun ();
   return 0;
}
</pre>


<ul>
<li>gcc默认不会inline,除非指定-O或-finline
     g++ 5.cpp -c
     nm -a 5.o|grep fun 显示 00000000 W <sub>Z3funv</sub>
     g++ 5.cpp -c -O3 或 -finline
     nm -a 5.o|grep fun 无结果
</li>
<li>5.cpp中注释的两行(取inline函数的地址)会阻止compile inline
     取消注释后,
     g++ 5.cpp -c
     nm -a 5.o|grep fun 显示 00000000 W <sub>Z3funv</sub>
</li>
<li>inline函数和普通函数一样,具有external linkage
     如果inline函数通过取函数地址或不指定优化等手段使编译器不Inline它,则目标
     文件中包含这个函数,如W<sub>Z3funv</sub>,这个函数具有external linkage,且这个函数在目标文件中是
     一个<a href="#weak-symbol">weak symbol</a>
     g++ 5.cpp 6.cpp -O3时,link出错,找不到fun
     g++ 5.cpp 6.cpp 时,编译成功,main()中调用的是5.cpp中的fun
</li>
<li>标准规定,每一个translation unit都要有inline函数的定义

<p>
     总结:每个translation unit都应该有inline函数的定义,如将inline函数的定义放在头文件中
     若不符合这个标准,也有可能编译通过,如将inline函数的定义放在某一个cpp文件中
     因为inline函数如果没有被inline就和普通函数一样,具有external linkage
</p></li>
</ul>


</div>

</div>

<div id="outline-container-1-52" class="outline-3">
<h3 id="sec-1-52"><span class="section-number-3">1.52</span> <span class="done DONE">DONE</span> static<sub>cast&lt</sub>;Derived *&gt;(virtual base *) is not supported in C++</h3>
<div class="outline-text-3" id="text-1-52">

<p>    <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2008-12-29 一 09:18</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2008-12-29 一 09:18</span></span>
</li>
</ul>





<pre class="example">class A {};
class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
</pre>


<p>
   来看B是什么样子(A是virtual的，所以放在底部)：
</p>



<pre class="example">+-----+
| B   |
| vptr|
+-----+
| A   |
+--- -+
</pre>


<p>
     这里我们假设A和B相差4
</p>
<p>
     再来看D是什么样子(B,C是基类，所以在开头，A是virtual的，所以放在底部)：
</p>


<pre class="example">+------+
| B    |
| vptr |
+--- --+
| C    |
| vptr |
+------+
| D    |
+--- --+
| A    |
+------+
</pre>


<p>
     这里A和B就相差12了
</p>
<p>
     所以当compiler看到需要把一个A*转到B*的时候，她并不知道这个offset是4还是12，这个
     取决于你传过来的对象是B还是D。这就需要一些额外的runtime信息来做这件事。
</p>
<p>
     btw. reinterpret<sub>cast&lt</sub>;A*&gt;(B*)是允许的,它假设是第一种情况
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> DEFINITION NOT FOUND: 0
</p>

<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> William Strunk Jr. and E.B. White. The Elements of Style (MacMilla
n Publishing Co. Ltd,
1979).
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.3" href="#fnr-.3">3</a></sup> From Roedy Green's "How To Write Unmaintainable Code,"
<a href="http://mindprod.com/unmaindesign.html">http://mindprod.com/unmaindesign.html</a>. (Primarily aimed at Java prog
rammers, it still has
lots of relevance for C++ programmers.)
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.4" href="#fnr-.4">4</a></sup> DEFINITION NOT FOUND: 4
</p>

</div>
</div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-05-17T17:03+0800</p>
<p class="author">Author: sunway</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.1 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
