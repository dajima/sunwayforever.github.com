<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Android WindowManager</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Android WindowManager"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-05-17T17:00+0800"/>
<meta name="author" content="sunway"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>    <link rel="stylesheet" type="text/css" href="stylesheets/main.css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Android WindowManager</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 WindowManager</a>
<ul>
<li><a href="#sec-1-1">1.1 addView</a></li>
<li><a href="#sec-1-2">1.2 Event dispatch</a></li>
<li><a href="#sec-1-3">1.3 View</a></li>
<li><a href="#sec-1-4">1.4 ViewRoot, View (DecorView) and Window</a></li>
<li><a href="#sec-1-5">1.5 Window</a></li>
<li><a href="#sec-1-6">1.6 ViewRoot</a></li>
<li><a href="#sec-1-7">1.7 WindowManagerImpl</a></li>
<li><a href="#sec-1-8">1.8 WindowManagerPolicy</a></li>
<li><a href="#sec-1-9">1.9 WindowManagerService</a></li>
<li><a href="#sec-1-10">1.10 Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析</a></li>
<li><a href="#sec-1-11">1.11 Application Transition</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> WindowManager</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> addView</h3>
<div class="outline-text-3" id="text-1-1">

<p>2010-11-16
window.addView() will firstly gen (viewRoot,view,layout<sub>param</sub>) tuple, then call ViewRoot.setView() to ask WMS to add the view.
since ViewRoot has an IWindowSession, and it will send IWindow to WMS (as mClient), it can communicate with WMS back and forth.
</p>
<p>
2010-11-15
window.addView() will add [new viewroot,decorView] tuple to
WindowManagerImpl, when WMS want to dispatch event to window, e.g. key event, it will
call mClient.dispatchKey() to viewRoot, viewRoot, as a handler, will then dispatch key event to it's looper
</p>
<p>
Activity and Dialog will generate decorView automatically, then call
WM.addView(decorView) to window.  but PopupWindow will not generate
decorView since PopupWindow need not to be `decorated`.
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Event dispatch</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> KeyEvent dispatch</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>     11/17/10 11:12 am WMS first found the focused WindowState, then dispatch
     event to WindowState.mClient (this is a IWindow), IWindow , as an AIDL
     register by viewRoot, will call viewRoot's dispatch() directory
</p>
<p>
     2010-11-14
</p>


<pre class="example">WMS get mClient, and call mClient.dispatch() through binder
  ViewRoot.dispatchKey()
    ViewRoot.sendEmptyMessage(DISPATCH_KEY)
      message handler: ViewRoot.deliverKeyEvent()
        ViewRoot.deliverKeyEventToViewHierarchy()
          Decorview.dispatchKeyEvent() ;; mView is the decorView
            if (is volume key)
              adjust volume
            if (has Window.Callback) ;; Activity, Dialog implents Window.Callback
              callback.dispatchKeyEvent()
                DecorView.superDispatchKeyEvent()
                  ViewGroup.dispatchKeyEvent() ;; dispatch key event to view hierachy
                    Travers the focus path, call every ViewGroup's dispatchKeyEvent, then finally,calls:
                    focusView.dispatchKeyEvent()
                      mOnKeyListener.onKey()
                      if (not handled)
                        event.dispatch(view) ;; view also implents Event.Callback
                if (not handled)
                    event.dispatch(activity) ;; Activity implents Event.Callback, which implents onKeyUp, onKeyDown ...
            else
              super.dispatchKeyEvent() ;; view.dispatchKeyEvent, PopupWindow falls into this condition, since PopupWindow
                                       ;; does not implents Window.Callback
            if (still not handled):
              Window.onKeyDown() or onKeyUp()
                // cope with MENU,CAMERA,VOLUME,MEDIA,CALL,SEARCH...
          if (not handled)
            changeFocus()
            if not (focus changed)
              playSoundEffect
          sWindowSession.finishKey(mWindow) to tell AMS that key
</pre>


<p>
    note that:
    Activity and Dialog implements Window.Callback and KeyEvent.Callback, so you can override Activity or Dialog's dispatchKeyEvent (implemented in
    Window.Callback), and you can override onKeyUp, onKeyDown &hellip;( implemented in KeyEvent.Callback)
    But PopupWindow implements neither Window.Callback nor KeyEvent.Callback.
</p>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> <span class="done DONE">DONE</span> TouchEvent dispatch</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>      <span class="timestamp-wrapper"><span class="timestamp-kwd">SCHEDULED: </span> <span class="timestamp">2011-01-27 Thu</span></span>  <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2011-01-27 Thu 11:35</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2011-01-27 Thu 11:35</span></span>
</li>
</ul>





<pre class="example">ViewRoot.dispatchPointer()
  decorView.dispatchTouchEvent() ;; mView is typically a DecorView
    if DecorView has callbacks like Activity or Dialog
      activity.dispatchTouchEvent()
        mDecor.superDispatchTouchEvent()
        .... ;; same as the `else` branch
        activity.onTouchEvent() if not handled before
    else
      mDecor.superDispatchTouchEvent()
        ViewGroup.dispatchTouchEvent() ; DecorView is a FrameLayout
          if (action == MotionEvent.ACTION_DOWN):
            if (disallowIntercept || !onInterceptTouchEvent(Ev)):
              foreach mView of ViewGroup: ;; for each child of the ViewGroup whose rect contains pointer(x,y), note that view's rect is set during view.layout()
                if (mView.dispatchTouchEvent()):
                  mMotionTarget=mView;
                  return true;
          if mMotionTarget==null: // DOWN is not handled by any child; or event is up/move, but there is no mMotionTarget,
                                  // which means last DOWN is handled by ourselves.
            return super.dispatchTouchEvent()
              mView.onTouchListener().on Touch()
              mView.onTouchEvent() ;; if not handled before
                mView.onClickListener()
          // ACTION is up/move, and mMotionTarget is not null, which means we should delegate the up/move to the mMotionTarget,
          // There is no need to go through child hierarchy to handle it.
          if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)): // touchEvent is intercepted
            ev.setAction(MotionEvent.ACTION_CANCEL);
            mMotionTarget.dispatchTouchEvent(ev)
            return true;
          // touchEvent is not intercepted
          return mMotionTarget.dispatchTouchEvent(ev);
</pre>

<p>
     To summarize:
</p><ol>
<li>TouchEvent dispatching 的过程和 KeyEvent <b>相反</b>:
<ul>
<li>KeyEvent: 先调用 ViewGroup.superDispatchKeyEvent(), 若没处理,再调用 mFocused.dispatchKeyEvent()
</li>
<li>TouchEvent: 先调用 child.dispatchTouchEvent(),若没处理, 再调用 super.dispatchTouchEvent()
</li>
</ul>

</li>
<li>dispatchTouchEvent -&gt; onTouchListener -&gt; onTouchEvent -&gt; onClickListener
</li>
<li>onInterceptTouchEvent and mMotionTarget and requestDisallowInterceptTouchEvent
</li>
</ol>


</div>

<div id="outline-container-1-2-2-1" class="outline-5">
<h5 id="sec-1-2-2-1"><span class="section-number-5">1.2.2.1</span> <span class="done DONE">DONE</span> ListView TouchEvent dispatch</h5>
<div class="outline-text-5" id="text-1-2-2-1">

<p>       <span class="timestamp-wrapper"><span class="timestamp-kwd">SCHEDULED: </span> <span class="timestamp">2011-02-16 Wed</span></span>  <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2011-02-16 Wed 15:04</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2011-02-16 Wed 15:04</span></span>
</li>
</ul>

<p>      ListView 首先是一个 ViewGroup, 它使用了
</p>


<pre class="example">ViewGroup.dispatchTouchEvent()
  ask_child_to_handle_it()
  if not handled:
    super(view).dispatchTouchEvent()
      AbsListView.onTouchEvent()
        if child(list item).hasFocusable(): ;; if the liste_item have any view that is focusable
          do_nothing;
        else:
          onItemClickedListener();
</pre>


<p>
      To summarize:
      ListView is just like a common ViewGroup, but:
</p><ol>
<li>ListView's onTouchEvent will not invoke `onClickListener`, but `onItemClickedListener`
</li>
<li>before invoke onItemClickedListener, onTouchEvent will make sure that child.hasFocusable() is false
</li>
</ol>


</div>

</div>

<div id="outline-container-1-2-2-2" class="outline-5">
<h5 id="sec-1-2-2-2"><span class="section-number-5">1.2.2.2</span> <span class="done DONE">DONE</span> ViewGroup.onInterceptTouchEvent &amp; mMotionTarget &amp; requestDisallowInterceptTouchEvent</h5>
<div class="outline-text-5" id="text-1-2-2-2">

<p>       <span class="timestamp-wrapper"><span class="timestamp-kwd">SCHEDULED: </span> <span class="timestamp">2011-07-19 Tue</span></span>  <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2011-07-19 Tue 16:55</span></span><br/>
</p><ul>
<li>State "DONE"       from "DOING" <span class="timestamp-wrapper"> <span class="timestamp">2011-07-19 Tue 16:55</span></span>
</li>
</ul>

</div>
</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> View</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> View life cycle</h4>
<div class="outline-text-4" id="text-1-3-1">


</div>

<div id="outline-container-requestLayout" class="outline-5">
<h5 id="requestLayout"><a name="sec-1-3-1-1" id="sec-1-3-1-1"></a><span class="section-number-5">1.3.1.1</span> <span class="done DONE">DONE</span> requestLayout</h5>
<div class="outline-text-5" id="text-requestLayout">

<p>       <span class="timestamp-wrapper"><span class="timestamp-kwd">SCHEDULED: </span> <span class="timestamp">2011-01-27 Thu</span></span>  <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2011-01-26 Wed 17:22</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2011-01-26 Wed 17:22</span></span>
</li>
</ul>

<p>      see <a href="#onMeasure">@onMeasure</a> <a href="#onLayout">@onLayout</a>
      requestLayout() is actually implemented in ViewRoot
      View defined it's own requestLayout by:
</p>


<pre class="example">View.requestLayout()
  mParent.requestLayout() ;; for a view, mParent is the upper ViewGroup
    mParent.requestLayout() ;; ViewGroup implements View, thus recursive again to the parent
      ...
        top_view.requestLayout()
          ViewRoot.requestLayout() ;; top view's mParent is the ViewRoot
</pre>


<p>
    Call stack:
</p>


<pre class="example">ViewRoot.requestLayout()
  ViewRoot.scheduleTraversals()
    ViewRoot.performTraversals() handles the msg
      mView.dispatchAttachedToWindow() ;; mView is the ViewRoot's top view
        ViewGroup.dispatchAttachedToWindow()
          view.dispatchAttachedToWindow() for every child view of the ViewGroup
            view.onAttachedToWindow() ;;  see [[onAttachedToWindow][onAttachedToWindow]]
      mView.measure()
        mView.onMeasure()
          layout.onMeasure() ;; e.g. LinearLayout, FrameLayout
            view.measure() ;; for every child view of the layout, including margin
              view.onMeasure() ;; see [[onMeasure][onMeasure]]
      mView.layout()
        layout.layout() ;; e.g. LinearLayout
          view.layout() ;; it seems that view.layout &amp;&amp; view.onLayout doesn't do something meaningful?  it mainly stores the child's x,y,width,height
                        ;; so that we can, when touch the screen, tell which view is touched
            view.onLayout() ;; see [[onLayout][onLayout]],
</pre>


</div>

</div>

<div id="outline-container-1-3-1-2" class="outline-5">
<h5 id="sec-1-3-1-2"><span class="section-number-5">1.3.1.2</span> addView</h5>
<div class="outline-text-5" id="text-1-3-1-2">

</div>

</div>

<div id="outline-container-1-3-1-3" class="outline-5">
<h5 id="sec-1-3-1-3"><span class="section-number-5">1.3.1.3</span> removeView</h5>
<div class="outline-text-5" id="text-1-3-1-3">

</div>

</div>

<div id="outline-container-1-3-1-4" class="outline-5">
<h5 id="sec-1-3-1-4"><span class="section-number-5">1.3.1.4</span> onAttachedToWindow</h5>
<div class="outline-text-5" id="text-1-3-1-4">

<p>      see <a href="#requestLayout">@requestLayout</a>
</p></div>

</div>

<div id="outline-container-1-3-1-5" class="outline-5">
<h5 id="sec-1-3-1-5"><span class="section-number-5">1.3.1.5</span> onDetachedFromWindow</h5>
<div class="outline-text-5" id="text-1-3-1-5">

</div>

</div>

<div id="outline-container-onLayout" class="outline-5">
<h5 id="onLayout"><a name="sec-1-3-1-6" id="sec-1-3-1-6"></a><span class="section-number-5">1.3.1.6</span> <span class="done DONE">DONE</span> onLayout</h5>
<div class="outline-text-5" id="text-onLayout">

<p>       <span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED: </span> <span class="timestamp">2011-03-15 Tue 16:50</span></span><br/>
</p><ul>
<li>State "DONE" <span class="timestamp-wrapper"> <span class="timestamp">2011-03-15 Tue 16:50</span></span>
</li>
</ul>

<p>      see <a href="#requestLayout">@requestLayout</a>
</p><ul>
<li id="sec-1-3-1-6-1">android:layout<sub>gravity</sub> &amp; android:gravity<br/>
       during onMeasure, view's size is fixed, after-wards, ViewGroup.onLayout will re-position children views and invoke child.onLayout to notify children
       for their position.

<ul>
<li>similar with android:height, only a few views or ViewGroup has the android:gravity property.
         e.g. TextView has the android:gravity property, so that the inner text can be positioned to top/bottom/left/right
         LinearLayout also has the android:gravity, which control Linear Layout's children's gravity as a whole.
</li>
</ul>

<ul>
<li id="sec-1-3-1-6-1-1">How does LinearLayout make use of gravity.<br/>
<ul>
<li>for <b>Vertical</b> LinearLayout with layout<sub>height</sub>= <b>fill<sub>parent</sub></b> :
          vertical LinearLayout can only set it's android:gravity to `top,bottom,center<sub>vertical`</sub>, which can move the children as a whole in
          vertical direction.
          vertical LinearLayout's child can set their android:layout<sub>gravity</sub> to `left,right,center<sub>horizontal`</sub>,which can move a single child view
          in the horizontal direction.

<p>
          that is, if u want to position a view in vertical LinearLayout to right-bottom, u can:
</p><ul>
<li>set LinearLayout.android:gravity to bottom
</li>
<li>set view.android:layout<sub>gravity</sub> to right
</li>
</ul>

</li>
</ul>





<pre class="example"> vertical LinearLayout                     set android:gravity to bottom             &amp; set view1.layout_gravity to right
-+-----------------------+                -+-----------------------+                -+--------------------------+
 |-+-------------+       |                 |                       |                 |                          |
 | |  view1      |       |                 |                       |                 |                          |
 | |             |       |                 |                       |                 |                          |
 |-+-------------+       |                 |                       |                 |                          |
 | |  view2      |       |                 |                       |                 |                          |
 | |             |       |                 |                       |                 |                          |
 |-+-------------+       |                 |-+--------------+      |                 |           -+-----------+ |
 |                       |                 | |  view1       |      |                 |            |  view1    | |
 |                       |                 | |              |      |                 |            |           | |
 |                       |                 |-+--------------+      |                 | -+---------+--+--------+ |
 |                       |                 | |  view2       |      |                 |  |  view2     |          |
 |                       |                 | |              |      |                 |  |            |          |
 |                       |                 |-+--------------+      |                 | -+------------+          |
-+-----------------------+                -+-----------------------+                -+--------------------------+
</pre>


<ul>
<li>for horizontal LinearLayout:
          vice-versa
</li>
</ul>


</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-3-1-7" class="outline-5">
<h5 id="sec-1-3-1-7"><span class="section-number-5">1.3.1.7</span> invalidate</h5>
<div class="outline-text-5" id="text-1-3-1-7">

</div>
</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> view padding and margin</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>     padding = 内边距
     margin =  外边距
     内,外是相对于容器(盒子)的边界而言, 以Button为例,Button可以看作一个盒子,设置button.padding会影响Button里的文字或图片与Button边界的距离,例如:
</p>
<p>
     Button
</p>


<pre class="example">-+---------------+
 |[padding] click|
-+---------------+
</pre>


<p>
     而button.margin会影响button与其更外层盒子(如layout)的边界
</p>
<p>
     LinearLayout
</p>


<pre class="example">-+-------------------+
 | [top margin]      |
 |+-------------+    |
 || button      |    |
 |+-------------+    |
-+-------------------+
</pre>


<p>
   需要注意的一点是,android中view是没有margin属性的,只有 ViewGroup 才有margin属性, 所以,如果想达到上图的效果,不可能直接设置button的margin,而是需在将button
   放在一个 ViewGroup 中,然后设置该 ViewGroup 的margin.
</p>
</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> DecorView</h4>
<div class="outline-text-4" id="text-1-3-3">

</div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> findViewById</h4>
<div class="outline-text-4" id="text-1-3-4">

</div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> Switch focus</h4>
<div class="outline-text-4" id="text-1-3-5">

<p>     11/17/10 9:41 am
     Q:when press 'left' key, how the focus is changed?
     A:
</p><ol>
<li>when viewRoot got the key event, it will firstly call 'dispatchKeyEventToViewHierachy' to dispatch the key event to it's correspondingg top level viw (i.e. DecorView)
</li>
<li>If the key event is not handled by the view hierachy, viewRoot will call 'findFocus' to find next focus in 'handleFinishedEvent'

</li>
<li>If the current focused view has set 'focus:right&hellip;' properties, viewRoot will call view.findViewById to find the next focus, or find the nearest focusable view in a specified rectangle area.
</li>
</ol>


</div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> getDrawingCache</h4>
<div class="outline-text-4" id="text-1-3-6">

</div>

</div>

<div id="outline-container-1-3-7" class="outline-4">
<h4 id="sec-1-3-7"><span class="section-number-4">1.3.7</span> ViewGroup</h4>
<div class="outline-text-4" id="text-1-3-7">

</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> ViewRoot, View (DecorView) and Window</h3>
<div class="outline-text-3" id="text-1-4">

<ul>
<li>与WMS直接打交道的是ViewRoot,WMS能直接看到的只有ViewRoot (通过ViewRoot注册到WMS的IWindow mClient)

</li>
<li>ViewRoot直接管理其顶层View (对于Actity,Dialog, 即DecorView. 对于

<p>
  PopupWindow及手动通过WindowManagerImpl.addView添加的view, 其顶层view只是普
  通的view), 所以一个进程可以有多个ViewRoot
</p>
</li>
<li>Window是和DecorView一一对应的. 

<p>
  因为Activity, Dialog项层view是DecorView, 所以有window的概念, 可以通
  过Window来控制ContextMenu, 调用Window.Callback等;
</p>
</li>
<li>Window与Activity,Dialog对应

<p>    
  通过Window.Callback, 可以和Activity和Dialog联系起来,因为它们都实际了
  Window.Callback接口.而PopupWindow顶层只是普通view,所以没有Window的概念
</p></li>
</ul>


<p>
综上:
</p><ul>
<li>WMS&lt;&ndash;&gt;ViewRoot
</li>
<li>ViewRoot&lt;&ndash;&gt;DecorView
</li>
<li>DecorView&lt;&ndash;&gt;Window&lt;&ndash;&gt;Activity,Dialog
</li>
</ul>

</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Window</h3>
<div class="outline-text-3" id="text-1-5">

<p>对于ViewRoot来说,顶层的`Window`就是一个普通的View, 但有些和`Window`有关的操
作,如:
</p><ul>
<li>如何处理一些通用的按键事件, 如Volume, ContextMenu,Camera,Call,Search&hellip;,
</li>
<li>如何在顶层View之上再显示一个ContextMenu
</li>
<li>从WMS来的一些事件如何通知给Activity,Dialog, 例如onBackPressed()
</li>
</ul>

<p>因为, 提供了一个Window类, 用来处理这些和`Window`有关的操作, 但从WMS及
ViewRoot的角度看,并没有`Window`的概念. 
</p>
<p>
只有DecorView能和Window关联,来处理`Window`相关操作 (因为DecorView是Window的
inner class), 所以只有Activity,Dialog有window的概念
</p>
</div>

<div id="outline-container-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> PhoneWindow</h4>
<div class="outline-text-4" id="text-1-5-1">

</div>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> ViewRoot</h3>
<div class="outline-text-3" id="text-1-6">

<p>ViewRoot is the bridge between WMS and View, It is basically a handler of
activityThread's mainLooper.  So WMS can use this handler to dispatch event to
top view of the activity or dialog.  What more, viewRoot is also equiped with an
IWindowSession, through which can communicate with WMS, e.g, tell WMS to add
view in ViewRoot.setView()
</p>
</div>

<div id="outline-container-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> IWindowSession: the sWindowSession</h4>
<div class="outline-text-4" id="text-1-6-1">

<p>when viewRoot is constructred, it will open session to WMS (IWindowSession) to communicate with WMS (e.g. For add, remove view)
</p></div>

</div>

<div id="outline-container-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> IWindow: the mWindow</h4>
<div class="outline-text-4" id="text-1-6-2">

<p>when viewRoot is constructed, it will create IWindow, and register the AIDL
interface to WMS, WMS will save the IWindow as 'mClient' in WindowState arrays,
through which WMS can communite with ViewRoot for event
dispatching. IWindow.dispatch() will call viewRoot.dispatch() directly.
</p></div>

</div>

<div id="outline-container-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> AttachInfo: the mAttachInfo</h4>
<div class="outline-text-4" id="text-1-6-3">

</div>

</div>

<div id="outline-container-1-6-4" class="outline-4">
<h4 id="sec-1-6-4"><span class="section-number-4">1.6.4</span> InputChannel: the mInputChannel</h4>
<div class="outline-text-4" id="text-1-6-4">

</div>

</div>

<div id="outline-container-1-6-5" class="outline-4">
<h4 id="sec-1-6-5"><span class="section-number-4">1.6.5</span> Rect: the mWinFrame</h4>
<div class="outline-text-4" id="text-1-6-5">

</div>

</div>

<div id="outline-container-1-6-6" class="outline-4">
<h4 id="sec-1-6-6"><span class="section-number-4">1.6.6</span> Rect: the mPendingContentInsets and mPendingVisibleInsets</h4>
<div class="outline-text-4" id="text-1-6-6">


</div>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> WindowManagerImpl</h3>
<div class="outline-text-3" id="text-1-7">

</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> WindowManagerPolicy</h3>
<div class="outline-text-3" id="text-1-8">


</div>

<div id="outline-container-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> PhoneWindowManager</h4>
<div class="outline-text-4" id="text-1-8-1">

</div>
</div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> WindowManagerService</h3>
<div class="outline-text-3" id="text-1-9">


</div>

<div id="outline-container-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> WindowState</h4>
<div class="outline-text-4" id="text-1-9-1">


</div>

<div id="outline-container-1-9-1-1" class="outline-5">
<h5 id="sec-1-9-1-1"><span class="section-number-5">1.9.1.1</span> mClient</h5>
<div class="outline-text-5" id="text-1-9-1-1">

<p>IWindow as the mClient
</p></div>
</div>

</div>

<div id="outline-container-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> WindowToken</h4>
<div class="outline-text-4" id="text-1-9-2">

</div>

</div>

<div id="outline-container-1-9-3" class="outline-4">
<h4 id="sec-1-9-3"><span class="section-number-4">1.9.3</span> AppWindowToken</h4>
<div class="outline-text-4" id="text-1-9-3">

</div>
</div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析</h3>
<div class="outline-text-3" id="text-1-10">

<blockquote>

<p>Location: <a href="http://blog.csdn.net/luoshengyang/article/details/8479101">http://blog.csdn.net/luoshengyang/article/details/8479101</a>
</p>
<p>
Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析
</p>
<p>
        在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其
装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘
制。本文将详细分析WindowManagerService服务计算Activity窗口大小的过程。
</p>
<p>
        一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下
Activity窗口的区域是如何划分的。
</p>
<p>
        我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图1所示。
</p>
<p>
[1357577722<sub>3792]</sub>                                                            
</p>
<p>
图1 Activity窗口的Content区域示意图
</p>
<p>
       从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是
用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，
得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的
内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、
content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。
</p>
<p>
       我们还知道，Activity窗口有时候需要显示输入法窗口，如图2所示。
</p>
<p>
[1357578477<sub>7744]</sub>                                                            
</p>
<p>
图2 Activity窗口的Visible区域示意图
</p>
<p>
        这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设Activity窗口的内容区
域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和
输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周
都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所
组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, visible-top, 
visible-right, visible-bottom）来描述，其中，visible-left、visible-right、visible-top、visible-bottom分别用来描述可见区
域与窗口区域的左右上下边界距离。
</p>
<p>
        在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰
区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口
的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里
面的UI元素进行测量、布局以及绘制等操作了。
</p>
<p>
        从前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文可以知道，应用程序进程是从ViewRoot
类的成员函数performTraversals开始，向WindowManagerService服务请求计算一个Activity窗口的大小的，因此，接下来我们就从
ViewRoot类的成员函数performTraversals开始分析一个Activity窗口大小的计算过程，如图3所示。
</p>
<p>
[1357660841<sub>4551]</sub>                                                            
</p>
<p>
图3 Activity窗口大小的计算过程
</p>
<p>
         这个过程可以分为11个步骤，接下来我们就详细分析每一个步骤。
</p>
<p>
         Step 1. ViewRoot.performTraversals
</p>
<p>
         这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中，它的实现很复杂，一共有600-行，不过大
部分代码都是用来计算Activity窗口的大小的，我们分段来阅读：
</p>
<p>
public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    &hellip;&hellip;
</p>
<p>     
    private void performTraversals() {
        &hellip;&hellip;
</p>
<p>
        final View host = mView;
        &hellip;&hellip;
</p>
<p> 
        int desiredWindowWidth;
        int desiredWindowHeight;
        int childWidthMeasureSpec;
        int childHeightMeasureSpec;
        &hellip;&hellip;
</p>
<p>
        Rect frame = mWinFrame;
        if (mFirst) {
            &hellip;&hellip;
</p>
<p> 
            DisplayMetrics packageMetrics =
                 mView.getContext().getResources().getDisplayMetrics();
            desiredWindowWidth = packageMetrics.widthPixels;
            desiredWindowHeight = packageMetrics.heightPixels;
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
            if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
                &hellip;&hellip;
                windowResizesToFitContent = true;
            }
        }
</p>
<p>
        这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。
</p>
<p>
        注意，Activity窗口当前的宽度和高度是保存ViewRoot类的成员变量mWinFrame中的。ViewRoot类的另外两个成员变量mWidth和
mHeight也是用来描述Activity窗口当前的宽度和高度的，但是它们的值是由应用程序进程上一次主动请求WindowManagerService服务计
算得到的，并且会一直保持不变到应用程序进程下一次再请求WindowManagerService服务来重新计算为止。Activity窗口的当前宽度和
高度有时候是被WindowManagerService服务主动请求应用程序进程修改的，修改后的值就会保存在ViewRoot类的成员变量mWinFrame中，
它们可能会与ViewRoot类的成员变量mWidth和mHeight的值不同。
</p>
<p>
        如果Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么它的当前
宽度desiredWindowWidth和当前高度desiredWindowHeight就等于屏幕的宽度和高度，否则的话，它的当前宽度desiredWindowWidth和当
前高度desiredWindowHeight就等于保存在ViewRoot类的成员变量mWinFrame中的宽度和高度值。
</p>
<p>
        如果Activity窗口不是第一次被请求执行测量、布局和绘制操作，并且Activity窗口主动上一次请求WindowManagerService服
务计算得到的宽度mWidth和高度mHeight不等于Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight，那么就
说明Activity窗口的大小发生了变化，这时候变量windowResizesToFitContent的值就会被标记为true，以便接下来可以对Activity窗口
的大小变化进行处理。
</p>
<p>
        我们继续往下阅读代码：
</p>
<p>
        boolean insetsChanged = false;
</p>
<p> 
        if (mLayoutRequested) {
            &hellip;&hellip;
</p>
<p> 
            if (mFirst) {
                host.fitSystemWindows(mAttachInfo.mContentInsets);
                &hellip;&hellip;
            } else {
                if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
                    mAttachInfo.mContentInsets.set(mPendingContentInsets);
                    host.fitSystemWindows(mAttachInfo.mContentInsets);
                    insetsChanged = true;
                    &hellip;&hellip;
                }
                if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
                    &hellip;&hellip;
                }
                if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">lp.height == ViewGroup.LayoutParams.WRAP<sub>CONTENT</sub>) {</td></tr>
</tbody>
</table>

                    windowResizesToFitContent = true;

<p> 
                    DisplayMetrics packageMetrics =
                        mView.getContext().getResources().getDisplayMetrics();
                    desiredWindowWidth = packageMetrics.widthPixels;
                    desiredWindowHeight = packageMetrics.heightPixels;
                }
            }
</p>
<p>
            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); 
            &hellip;&hellip;
</p>
<p>
            host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
</p>
<p> 
            &hellip;&hellip;
        }
</p>
<p>
        这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。
</p>
<p>
        在分析这段代码之前，我们首先解释一下ViewRoot类的成员变量mAttachInfo和mPendingContentInsets、
mPendingVisibleInsets。ViewRoot类的成员变量mAttachInfo指向的一个AttachInfo对象，这个AttachInfo对象用来描述Activity窗口
的属性，例如，这个AttachInfo对象的成员变量mContentInsets和mVisibleInsets分别用来描述Activity窗口上一次主动请求
WindowManagerService服务计算得到的内容边衬大小和可见边衬大小，即Activity窗口的当前内容边衬大小和可见边衬大小。ViewRoot
类的成员变量mPendingContentInsets和mPendingVisibleInsets也是用来描述Activity窗口的内容边衬大小和可见边衬大小的，不过它
们是由WindowManagerService服务主动请求Activity窗口设置的，但是尚未生效。
</p>
<p>
        我们分两种情况来分析这段代码。
</p>
<p>
        第一种情况是Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么
这段代码在测量Activity窗口的顶层视图host的大小之前，首先会调用这个顶层视图host的成员函数fitSystemWindows来设置它的四个
内边距（mPaddingLeft，mPaddingTop，mPaddingRight，mPaddingBottom）的大小设置为Activity窗口的初始化内容边衬大小。这样做
的目的是可以在Activity窗口的四周留下足够的区域来放置可能会出现的系统窗口，也就是状态栏和输入法窗口。
</p>
<p>
        第二种情况是Activity窗口不是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于false，那
么这段代码就会检查Activity窗口是否被WindowManagerService服务主动请求设置了一个新的内容边衬大小mPendingContentInsets和一
个新的可见边衬大小mPendingVisibleInsets。如果是的话，那么就会分别将它们保存在ViewRoot类的成员变量mAttachInfo所指向的一
个AttachInfo对象的成员变量mContentInsets和成员变量mVisibleInsets中。注意，如果Activity窗口被WindowManagerService服务主
动请求设置了一个新的内容边衬大小mPendingContentInsets，那么这段代码同时还需要同步调用Activity窗口的顶层视图host的成员函
数fitSystemWindows来将它的四个内边距（mPaddingLeft，mPaddingTop，mPaddingRight，mPaddingBottom）的大小设置为新的内容边
衬大小，并且将变量insetsChanged的值设置为true，表明Activity窗口的内容边衬大小发生了变化。
</p>
<p>
        在第二种情况下，如果Activity窗口的宽度被设置为ViewGroup.LayoutParams.WRAP<sub>CONTENT或者高度被设置为</sub>
ViewGroup.LayoutParams.WRAP<sub>CONTENT，那么就意味着Activity窗口的大小要等于内容区域的大小。但是由于Activity窗口的大小是需</sub>
要覆盖整个屏幕的，因此，这时候就会Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight设置为屏幕的宽度
和高度。也就是说，如果我们将Activity窗口的宽度和高度设置为ViewGroup.LayoutParams.WRAP<sub>CONTENT，实际上就意味着它的宽度和</sub>
高度等于屏幕的宽度和高度。这种情况也意味着Acitivity窗口的大小发生了变化，因此，就将变量windowResizesToFitContent的值设
置为true。
</p>
<p>
        经过上面的一系列处理之后，这段代码就会调用ViewRoot类的成员函数getRootMeasureSpec来根据Activity窗口的当前宽度和
宽度测量规范以及高度和高度测量规范来计算得到它的顶层视图host的宽度测量规范childWidthMeasureSpec和高度测量规范
childHeightMeasureSpec。有了这两个规范之后，就可以调用Activity窗口的顶层视图host的成员函数measure来执行大小测量的工作了
。这个大小测量的过程可以参考前面Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析
一文。
</p>
<p>
       我们继续往下阅读代码：
</p>
<p>
        boolean windowShouldResize = mLayoutRequested &amp;&amp; windowResizesToFitContent
            &amp;&amp; ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight)
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">(lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</td></tr>
</tbody>
</table>

                        frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">(lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</td></tr>
</tbody>
</table>

                        frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));

<p>
        final boolean computesInternalInsets =
                attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
</p>
<p>
       这段代码主要是做两件事情。
</p>
<p>
       第一件事情是检查是否需要处理Activity窗口的大小变化事件。如果满足以下条件，那么就需要处理，即将变量
windowShouldResize的值设置为true：
</p>
<ol>
<li>ViewRoot类的成员变量mLayoutRequest的值等于true，这说明应用程序进程正在请求对Activity窗口执行一次测量、布局和
</li>
</ol>

<p>绘制操作；
</p>
<ol>
<li>变量windowResizesToFitContent的值等于true，这说明前面检测到了Activity窗口的大小发生了变化；

</li>
<li>前面我们已经Activity窗口的顶层视图host的大小重新进行了测量。如果测量出来的宽度host.mMeasuredWidth和高度
</li>
</ol>

<p>host.mMeasuredHeight和Activity窗口的当前宽度mWidth和高度mHeight一样，那么即使条件1和条件2能满足，那么也是可以认为是
Activity窗口的大小是没有发生变化的。换句话说，只有当测量出来的大小和当前大小不一致时，才认为Activity窗口大小发生了变化
。另一方面，如果测量出来的大小和当前大小一致，但是Activity窗口的大小被要求设置成WRAP<sub>CONTENT，即设置成和屏幕的宽度</sub>
desiredWindowWidth和高度desiredWindowHeight一致，但是WindowManagerService服务请求Activity窗口设置的宽度frame.width()和
高度frame.height()与它们不一致，而且与Activity窗口上一次请求WindowManagerService服务计算的宽度mWidth和高度mHeight也不一
致，那么也是认为Activity窗口大小发生了变化的。
</p>
<p>
        第二件事情是检查Activity窗口是否需要指定有额外的内容边衬区域和可见边衬区域。如果有的话，那么变量attachInfo所指
向的一个AttachInfo对象的成员变量mTreeObserver所描述的一个TreeObserver对象的成员函数hasComputeInternalInsetsListerner的
返回值ComputeInternalInsets就会等于true。Activity窗口指定额外的内容边衬区域和可见边衬区域是为了放置一些额外的东西。
</p>
<p>
        我们继续往下阅读代码：
</p>
<p>
        if (mFirst || windowShouldResize || insetsChanged
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">viewVisibilityChanged</td><td class="left"></td><td class="left">params != null) {</td></tr>
</tbody>
</table>


<p>
            if (viewVisibility == View.VISIBLE) {
                // If this window is giving internal insets to the window
                // manager, and it is being added or changing its visibility,
                // then we want to first give the window manager "fake"
                // insets to cause it to effectively ignore the content of
                // the window during layout.  This avoids it briefly causing
                // other windows to resize/move based on the raw frame of the
                // window, waiting until we can finish laying out this window
                // and get back to the window manager with the ultimately
                // computed insets.
                insetsPending = computesInternalInsets
                        &amp;&amp; (mFirst || viewVisibilityChanged);
</p>
<p>
                &hellip;&hellip;
            }
</p>
<p>
        这段代码以及接下来的两段代码都是在满足下面的条件之一的情况下执行的：
</p>
<ol>
<li>Activity窗口是第一次执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true。

</li>
<li>前面得到的变量windowShouldResize的值等于true，即Activity窗口的大小的确是发生了变化。

</li>
<li>前面得到的变量insetsChanged的值等于true，即Activity窗口的内容区域边衬发生了变化。

</li>
<li>Activity窗口的可见性发生了变化，即变量viewVisibilityChanged的值等于true。

</li>
<li>Activity窗口的属性发生了变化，即变量params指向了一个WindowManager.LayoutParams对象。
</li>
</ol>


<p>
        在满足上述条件之一，并且Activity窗口处于可见状态，即变量viewVisibility的值等于View.VISIBLE，那么就需要检查接下
来请求WindowManagerService服务计算大小时，是否要告诉WindowManagerService服务它指定了额外的内容区域边衬和可见区域边衬，
但是这些额外的内容区域边衬和可见区域边衬又还有确定。这种情况发生在Activity窗口第一次执行测量、布局和绘制操作或者由不可
见变化可见时。因此，当前面得到的变量computesInternalInsets等于true时，即Activity窗口指定了额外的内容区域边衬和可见区域
边衬，那么就需要检查ViewRoot类的成员变量mFirst或者变量viewVisibilityChanged的值是否等于true。如果这些条件能满足，那么变
量insetsPending的值就会等于true，表示Activity窗口有额外的内容区域边衬和可见区域边衬等待指定。
</p>
<p>
        我们继续往下阅读代码：
</p>
<p>
            boolean contentInsetsChanged = false;
            boolean visibleInsetsChanged;
            &hellip;&hellip;
            try {
                &hellip;&hellip;
                relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
</p>
<p>
                contentInsetsChanged = !mPendingContentInsets.equals(
                        mAttachInfo.mContentInsets);
                visibleInsetsChanged = !mPendingVisibleInsets.equals(
                        mAttachInfo.mVisibleInsets);
                if (contentInsetsChanged) {
                    mAttachInfo.mContentInsets.set(mPendingContentInsets);
                    host.fitSystemWindows(mAttachInfo.mContentInsets);
                    &hellip;&hellip;
                }
                if (visibleInsetsChanged) {
                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
                    &hellip;&hellip;
                }
</p>
<p>                    
                &hellip;&hellip;
            } catch (RemoteException e) {
            }
</p>
<p>
            &hellip;&hellip;
</p>
<p>
            attachInfo.mWindowLeft = frame.left;
            attachInfo.mWindowTop = frame.top;
</p>
<p>
            // !!FIXME!! This next section handles the case where we did not get the
            // window size we asked for. We should avoid this by getting a maximum size from
            // the window session beforehand.
            mWidth = frame.width();
            mHeight = frame.height();
</p>
<p>
        这段代码主要就是调用ViewRoot类的另外一个成员函数relayoutWindow来请求WindowManagerService服务计算Activity窗口的
大小以及内容区域边衬大小和可见区域边衬大小。计算完毕之后，Activity窗口的大小就会保存在ViewRoot类的成员变量mWinFrame中，
而Activity窗口的内容区域边衬大小和可见区域边衬大小分别保存在ViewRoot类的成员变量mPendingContentInsets和
mPendingVisibleInsets中。
</p>
<p>
        如果这次计算得到的Activity窗口的内容区域边衬大小mPendingContentInsets和可见区域边衬大小mPendingVisibleInsets与
上一次计算得到的不一致，即与ViewRoot类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mContentInsets和
mVisibleInsets所描述的大小不一致，那么变量contentInsetsChanged和visibleInsetsChanged的值就会等于true，表示Activity窗口
的内容区域边衬大小和可见区域边衬大小发生了变化。
</p>
<p>
        由于变量frame和ViewRoot类的成员变量mWinFrame引用的是同一个Rect对象，因此，这时候变量frame描述的也是Activity窗口
请求WindowManagerService服务计算之后得到的大小。这段代码分别将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所
指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop中，并且将计算得到的Activity窗口的宽度和高度保存在ViewRoot类的
成员变量mWidth和mHeight中。
</p>
<p>
        我们继续往下阅读代码：
</p>
<p>
            boolean focusChangedDueToTouchMode = ensureTouchModeLocally(
                    (relayoutResult&amp;WindowManagerImpl.RELAYOUT<sub>IN</sub><sub>TOUCH</sub><sub>MODE</sub>) != 0);
            if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">mHeight != host.mMeasuredHeight</td><td class="left"></td><td class="left">contentInsetsChanged) {</td></tr>
</tbody>
</table>

                childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
                &hellip;&hellip;

<p>
                // Ask host how big it wants to be
                host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
</p>
<p>        
                // Implementation of weights from WindowManager.LayoutParams
                // We just grow the dimensions as needed and re-measure if
                // needs be
                int width = host.mMeasuredWidth;
                int height = host.mMeasuredHeight;
                boolean measureAgain = false;
</p>
<p>
                if (lp.horizontalWeight &gt; 0.0f) {
                    width += (int) ((mWidth - width) * lp.horizontalWeight);
                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,
                            MeasureSpec.EXACTLY);
                    measureAgain = true;
                }
                if (lp.verticalWeight &gt; 0.0f) {
                    height += (int) ((mHeight - height) * lp.verticalWeight);
                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,
                            MeasureSpec.EXACTLY);
                    measureAgain = true;
                }
</p>
<p>
                if (measureAgain) {
                    &hellip;&hellip;
                    host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }
</p>
<p>
                mLayoutRequested = true;
            }
        }
</p>
<p>
        这段代码用来检查是否需要重新测量Activity窗口的大小。如果满足以下条件之一，那么就需要重新测量：
</p>
<ol>
<li>Activity窗口的触摸模式发生了变化，并且由此引发了Activity窗口当前获得焦点的控件发生了变化，即变量
</li>
</ol>

<p>focusChangedDueToTouchMode的值等于true。这个检查是通过调用ViewRoot类的成员函数ensureTouchModeLocally来实现的。
</p>
<ol>
<li>Activity窗口前面测量出来的宽度host.mMeasuredWidth和高度host.mMeasuredHeight不等于WindowManagerService服务计
</li>
</ol>

<p>算出来的宽度mWidth和高度mHeight。
</p>
<ol>
<li>Activity窗口的内容区域边衬大小和可见区域边衬大小发生了变化，即前面得到的变量contentInsetsChanged的值等于true
</li>
</ol>

<p>。
</p>
<p>
        重新计算了一次之后，如果Activity窗口的属性lp表明需要对测量出来的宽度width和高度height进行扩展，即变量lp所指向的
一个WindowManager.LayoutParams对象的成员变量horizontalWeight和verticalWeight的值大于0.0，那么就需要对Activity窗口的顶层
视图host的最大可用空间进行扩展后再进行一次测量工作。
</p>
<p>
        我们继续往下阅读最后一段代码：
</p>
<p>
        final boolean didLayout = mLayoutRequested;
        &hellip;&hellip;
        if (didLayout) {
            &hellip;&hellip;
            host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);
            &hellip;&hellip;
        }
</p>
<p>
        if (computesInternalInsets) {
            ViewTreeObserver.InternalInsetsInfo insets = attachInfo.mGivenInternalInsets;
            final Rect givenContent = attachInfo.mGivenInternalInsets.contentInsets;
            final Rect givenVisible = attachInfo.mGivenInternalInsets.visibleInsets;
            givenContent.left = givenContent.top = givenContent.right
                    = givenContent.bottom = givenVisible.left = givenVisible.top
                    = givenVisible.right = givenVisible.bottom = 0;
            attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
            Rect contentInsets = insets.contentInsets;
            Rect visibleInsets = insets.visibleInsets;
            if (mTranslator != null) {
                contentInsets = mTranslator.getTranslatedContentInsets(contentInsets);
                visibleInsets = mTranslator.getTranslatedVisbileInsets(visibleInsets);
            }
            if (insetsPending || !mLastGivenInsets.equals(insets)) {
                mLastGivenInsets.set(insets);
                try {
                    sWindowSession.setInsets(mWindow, insets.mTouchableInsets,
                            contentInsets, visibleInsets);
                } catch (RemoteException e) {
                }
            }
        }
</p>
<p>          
        &hellip;&hellip;
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局了，前提
是ViewRoot类的成员变量mLayoutRequest的值等于true。对Activity窗口的内容进行布局是通过调用它的顶层视图host的成员函数
layout来实现的，这个过程可以参考前面Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程
分析一文。
</p>
<p>
        从前面的描述可以知道，当变量computesInternalInsets的值等于true时，就表示Activity窗口指定有额外的内容区域边衬和
可见区域边衬，这时候就是时候把它们告诉给WindowManagerService服务了，以便WindowManagerService服务下次可以知道Activity窗
口的真实布局。Activity窗口额外指定的内容区域边衬大小和可见区域边衬大小是通过调用变量attachInfo所指向的一个AttachInfo对
象的成员变量mTreeObserver所描述的一个TreeObserver对象的成员函数dispatchOnComputeInternalInsets来计算的。计算完成之后，
就会保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mGivenInternalInsets中，并且会通过ViewRoot类的静态成员变量
sWindowSession所指向一个Binder代理对象来设置到WindowManagerService服务中去。
</p>
<p>
        注意，如果ViewRoot类的成员变量mTranslator指向了一个Translator对象，那么就说明Activity窗口是运行兼容模式中，这时
候就需要将前面计算得到的内容区域边衬大小和可见区域边衬大小转化到兼容模式下，然后才可以保存在变量attachInfo所指向的一个
AttachInfo对象的成员变量mGivenInternalInsets中，以及设置到WindowManagerService服务中去。
</p>
<p>
        另外，只有前面得到的变量insetsPending的值等于true，即Activity窗口正在等待告诉WindowManagerService服务它有额外指
定的内容区域边衬和可见区域边衬，或者Activty窗口额外指定的内容区域边衬和可见区域边衬发生了变化，即Activty窗口上一次额外
指定的内容区域边衬和可见区域边衬mLastGivenInsets不等于当前这次指定的内容区域边衬和可见区域边衬insets，Activity窗口额外
指定的内容区域边衬和可见区域边衬才会被设置到WindowManagerService服务中去。
</p>
<p>
        ViewRoot类的成员函数再接下来的工作就是绘制Activity窗口的UI了，这个过程同样可以参考前面Android应用程序窗口（
Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析一文。
</p>
<p>
        接下来，我们继续分析ViewRoot类的成员函数relayoutWindow的实现，以便可以了解它是如何请求WindowManagerService服务
计算Activity窗口的大小的。
</p>
<p>
        Step 2. ViewRoot.relayoutWindow
</p>
<p>
public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    &hellip;&hellip;
</p>
<p>     
    private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {
</p>
<p>
        float appScale = mAttachInfo.mApplicationScale;
        &hellip;&hellip;
</p>
<p>
        int relayoutResult = sWindowSession.relayout(
                mWindow, params,
                (int) (mView.mMeasuredWidth * appScale + 0.5f),
                (int) (mView.mMeasuredHeight * appScale + 0.5f),
                viewVisibility, insetsPending, mWinFrame,
                mPendingContentInsets, mPendingVisibleInsets,
                mPendingConfiguration, mSurface);
        &hellip;&hellip;
</p>
<p>        
        if (mTranslator != null) {
            mTranslator.translateRectInScreenToAppWinFrame(mWinFrame);
            mTranslator.translateRectInScreenToAppWindow(mPendingContentInsets);
            mTranslator.translateRectInScreenToAppWindow(mPendingVisibleInsets);
        }
        return relayoutResult;
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
       这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。
</p>
<p>
       从前面Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析一文可以知道，ViewRoot类的静态成员
变量sWindowSession是一个Binder代理对象，它引用了运行在WindowManagerService服务这一侧的一个Session对象，ViewRoot类的成员
函数relayoutWindow通过调用这个Session对象的成员函数relayout来请求WindowManagerService服务计算Activity窗口的大小，其中，
传递给WindowManagerService服务的参数包括：
</p>
<ol>
<li>ViewRoot类的成员变量mWindow，用来标志要计算的是哪一个Activity窗口的大小。

</li>
<li>Activity窗口的顶层视图经过测量后得到的宽度和高度。注意，传递给WindowManagerService服务的宽度和高度是已经考虑
</li>
</ol>

<p>了Activity窗口所设置的缩放因子了的。
</p>
<ol>
<li>Activity窗口的可见状态，即参数viewVisibility。

</li>
<li>Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending。

</li>
<li>ViewRoot类的成员变量mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大
</li>
</ol>

<p>小。
</p>
<ol>
<li>ViewRoot类的成员变量mPendingContentInsets，这是一个输出参数，用来保存WindowManagerService服务计算后得到的
</li>
</ol>

<p>Activity窗口的内容区域边衬大小。
</p>
<ol>
<li>ViewRoot类的成员变量mPendingVisibleInsets，这是一个输出参数，用来保存WindowManagerService服务计算后得到的
</li>
</ol>

<p>Activity窗口的可见区域边衬大小。
</p>
<ol>
<li>ViewRoot类的成员变量mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity
</li>
</ol>

<p>窗口的配置信息。
</p>
<ol>
<li>ViewRoot类的成员变量mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表
</li>
</ol>

<p>面。
</p>
<p>
       得到了Activity窗口的大小以及内容区域边衬大小和可见区域边衬大小之后，如果Activity窗口是运行在兼容模式中，即
ViewRoot类的成员变量mTranslator指向了一个Translator对象，那么就需要调用它的成员函数translateRectInScreenToAppWindow来对
它们进行转换。
</p>
<p>
       接下来，我们继续分析Session类的成员函数relayout，以便可以了解WindowManagerService服务是如何计算一个Activity窗口
的大小的。
</p>
<p>
       Step 3. Session.relayout
</p>
<p>
public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    &hellip;&hellip;
</p>
<p>
    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        &hellip;&hellip;
</p>
<p>
        public int relayout(IWindow window, WindowManager.LayoutParams attrs,
                int requestedWidth, int requestedHeight, int viewFlags,
                boolean insetsPending, Rect outFrame, Rect outContentInsets,
                Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
            //Log.d(TAG, "&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from " + Binder.getCallingPid());
            int res = relayoutWindow(this, window, attrs,
                    requestedWidth, requestedHeight, viewFlags, insetsPending,
                    outFrame, outContentInsets, outVisibleInsets, outConfig, outSurface);
            //Log.d(TAG, "&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to " + Binder.getCallingPid());
            return res;
        }
</p>
<p>
        &hellip;&hellip;
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。
</p>
<p>
        Session类的成员函数relayout的实现很简单，它只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算
参数window所描述的一个Activity窗品的大小，接下来我们就继续分析WindowManagerService类的成员函数relayoutWindow的实现。
</p>
<p>
        Step 4. WindowManagerService.relayoutWindow
</p>
<p>
public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    &hellip;&hellip;
</p>
<p>
    public int relayoutWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, boolean insetsPending,
            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
            Configuration outConfig, Surface outSurface) {
        &hellip;&hellip;
</p>
<p> 
        synchronized(mWindowMap) {
            WindowState win = windowForClientLocked(session, client, false);
            &hellip;&hellip;
</p>
<p>
            win.mRequestedWidth = requestedWidth;
            win.mRequestedHeight = requestedHeight;
            &hellip;&hellip;
</p>
<p>
            final boolean scaledWindow =
                ((win.mAttrs.flags &amp; WindowManager.LayoutParams.FLAG<sub>SCALED</sub>) != 0);
</p>
<p>
            if (scaledWindow) {
                // requested{Width|Height} Surface's physical size
                // attrs.{width|height} Size on screen
                win.mHScale = (attrs.width  != requestedWidth)  ?
                        (attrs.width  / (float)requestedWidth) : 1.0f;
                win.mVScale = (attrs.height != requestedHeight) ?
                        (attrs.height / (float)requestedHeight) : 1.0f;
            } else {
                win.mHScale = win.mVScale = 1;
            }
</p>
<p>
            &hellip;&hellip;
</p>
<p>
            win.mGivenInsetsPending = insetsPending;
</p>
<p>
            &hellip;&hellip;
</p>
<p>
            performLayoutAndPlaceSurfacesLocked();
</p>
<p>
            &hellip;&hellip;
</p>
<p>
            outFrame.set(win.mFrame);
            outContentInsets.set(win.mContentInsets);
            outVisibleInsets.set(win.mVisibleInsets);
</p>
<p> 
            &hellip;&hellip;
        }
</p>
<p>
        return (inTouchMode ? WindowManagerImpl.RELAYOUT<sub>IN</sub><sub>TOUCH</sub><sub>MODE</sub> : 0)
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">(displayed ? WindowManagerImpl.RELAYOUT<sub>FIRST</sub><sub>TIME</sub> : 0);</td></tr>
</tbody>
</table>

    }

<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。
</p>
<p>
        参数client是一个Binder代理对象，它引用了运行在应用程序进程这一侧中的一个W对象，用来标志一个Activity窗口。从前面
Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析一文可以知道，在应用程序进程这一侧的每一个W对象
，在WindowManagerService服务这一侧都有一个对应的WindowState对象，用来描述一个Activity窗口的状态。因此，
WindowManagerService类的成员函数relayoutWindow首先通过调用另外一个成员函数windowForClientLocked来获得与参数client所对应
的一个WindowState对象win，以便接下来可以对它进行操作。
</p>
<p>
        本文我们只关注WindowManagerService类的成员函数relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示：
</p>
<ol>
<li>参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在
</li>
</ol>

<p>WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中。
</p>
<ol>
<li>WindowState对象win的成员变量mAttr，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局
</li>
</ol>

<p>参数。其中，这个WindowManager.LayoutParams对象的成员变量width和height是用来描述Activity窗口的宽度和高度的。当这个
WindowManager.LayoutParams对象的成员变量flags的WindowManager.LayoutParams.FLAG<sub>SCALED位不等于0的时候，就说明需要给</sub>
Activity窗口的大小设置缩放因子。缩放因子分为两个维度，分别是宽度缩放因子和高度缩放因子，保存在WindowState对象win的成员
变量HScale和VScale中，计算方法分别是用应用程序进程请求设置Activity窗口中的宽度和高度除以Activity窗口在布局参数中所设置
的宽度和高度。
</p>
<ol>
<li>参数insetsPending用来描述Activity窗口是否有额外的内容区域边衬和可见区域边衬未设置，它被记录在WindowState对象
</li>
</ol>

<p>win的成员变量mGivenInsetsPending中。
</p>
<ol>
<li>调用WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked来计算Activity窗口的大小。计算完成之
</li>
</ol>

<p>后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变
量mFrame、mContentInsets和mVisibleInsets中。
</p>
<ol>
<li>将WindowState对象win的成员变量mFrame、mContentInsets和mVisibleInsets的值分别拷贝到参数出数outFrame、
</li>
</ol>

<p>outContentInsets和outVisibleInsets中，以便可以返回给应用程序进程。
</p>
<p>
        经过上述五个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowManagerService类的成员函数
performLayoutAndPlaceSurfacesLocked的实现，以便可以详细了解Activity窗口的大小计算过程。
</p>
<p>
        Step 5. WindowManagerService.performLayoutAndPlaceSurfacesLocked
</p>
<p>
public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    &hellip;&hellip;
</p>
<p>
    private final void performLayoutAndPlaceSurfacesLocked() {
        if (mInLayout) {
            &hellip;&hellip;
            return;
        }
</p>
<p>
        &hellip;&hellip;
</p>
<p>
        boolean recoveringMemory = false;
        if (mForceRemoves != null) {
            recoveringMemory = true;
            // Wait a little it for things to settle down, and off we go.
            for (int i=0; i&lt;mForceRemoves.size(); i++) {
                WindowState ws = mForceRemoves.get(i);
                Slog.i(TAG, "Force removing: " + ws);
                removeWindowInnerLocked(ws.mSession, ws);
            }
            mForceRemoves = null;
            &hellip;&hellip;
        }
</p>
<p>
        mInLayout = true;
        try {
            performLayoutAndPlaceSurfacesLockedInner(recoveringMemory);
</p>
<p>
            int i = mPendingRemove.size()-1;
            if (i &gt;= 0) {
                while (i &gt;= 0) {
                    WindowState w = mPendingRemove.get(i);
                    removeWindowInnerLocked(w.mSession, w);
                    i&ndash;;
                }
                mPendingRemove.clear();
</p>
<p>
                mInLayout = false;
                assignLayersLocked();
                mLayoutNeeded = true;
                performLayoutAndPlaceSurfacesLocked();
</p>
<p>
            } else {
                mInLayout = false;
                &hellip;&hellip;
            }
            &hellip;&hellip;
        } catch (RuntimeException e) {
            mInLayout = false;
            &hellip;&hellip;
        }
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
       这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。
</p>
<p>
       从WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked的名称可以推断出，它执行的操作绝非是计算窗
口大小这么简单。计算窗口大小只是其中的一个小小功能点，它主要的功能是用来刷新系统的UI。在我们这个情景中，为什么需要刷新
系统的UI呢？Activity窗口在其属性发生了变化，例如，可见性、大小发生了变化，又或者它新增、删除了子视图，都需要重新计算大
小，而这些变化都是要求WindowManagerService服务重新刷新系统的UI的。事实上，刷新系统的UI是WindowManagerService服务的主要
任务，在新增和删除了窗口、窗口动画显示过程、窗口切换过程中，WindowManagerService服务都需要不断地刷新系统的UI。
</p>
<p>
       WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked主要是通过调用另外一个成员函数
performLayoutAndPlaceSurfacesLockedInner来刷新系统的UI的，而在刷新的过程中，就会对系统中的各个窗口的大小进行计算。
</p>
<p>
       在调用成员函数performLayoutAndPlaceSurfacesLockedInner来刷新系统UI的前后，WindowManagerService类的成员函数
performLayoutAndPlaceSurfacesLocked还会执行以下两个操作：
</p>
<ol>
<li>调用前，检查系统中是否存在强制删除的窗口。有内存不足的情况下，有一些窗口就会被回收，即要从系统中删除，这些窗
</li>
</ol>

<p>口会保存在WindowManagerService类的成员变量mForceRemoves所描述的一个ArrayList中。如果存在这些窗口，那么
WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就会调用另外一个成员函数removeWindowInnerLocked来删
除它们，以便可以回收它们所占用的内存。
</p>
<ol>
<li>调用后，检查系统中是否有窗口需要移除。如果有的话，那么WindowManagerService类的成员变量mPendingRemove所描述的
</li>
</ol>

<p>一个ArrayList的大小就会大于0。这种情况下，WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就会调用另
外一个成员函数removeWindowInnerLocked来移除这些窗口。注意，WindowManagerService类的成员函数removeWindowInnerLocked只是
用来移除窗口，但是并没有回收这些窗口所占用的内存。等到合适的时候，例如，内存不足时，才会考虑回收这些窗口所占用的内存。
移除一个窗口的操作也是很复杂的，除了要将窗口从WindowManagerService类的相关成员变量中移除之外，还要考虑重新调整输入法窗
口和壁纸窗口，因为被移除的窗口可能要求显示壁纸和输入法窗口，当它被移除之后，就要将壁纸窗口和输入法窗口调整到合适的Z轴位
置上去，以便可以交给下一个需要显示壁纸和输入法窗口的窗口使用。此外，在移除了窗口之后，WindowManagerService服务还需要重
新计算现存的其它窗口的Z轴位置，以便可以正确地反映系统当前的UI状态，这是通过调用WindowManagerService类的成员函数
assignLayersLocked来实现的。重新计算了现存的其它窗口的Z轴位置之后，又需要再次刷新系统的UI，即要对WindowManagerService类
的成员函数performLayoutAndPlaceSurfacesLocked进行递归调用，并且在调用前，将WindowManagerService类的成员变量
mLayoutNeeded的值设置为true。由此就可见，系统UI的刷新过程是非常复杂的。
</p>
<p>
       注意，为了防止在刷新系统UI的过程中被重复调用，WindowManagerService类的成员函数
performLayoutAndPlaceSurfacesLocked在刷新系统UI之前，即调用成员函数performLayoutAndPlaceSurfacesLockedInner之前，会将
WindowManagerService类的成员变量mInLayout的值设置为true，并且在调用之后，重新将这个成员变量的值设置为false。这样，
WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就可以在一开始的时候检查成员变量mInLayout的值是否等
于true，如果等于的话，那么就说明WindowManagerService服务正在刷新系统UI的过程中，于是就不用往下执行了。
</p>
<p>
       接下来，我们就继续分析WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner的实现，以便可以了
解Activity窗口的大小计算过程。
</p>
<p>
       Step 6. WindowManagerService.performLayoutAndPlaceSurfacesLockedInner
</p>
<p>
public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    &hellip;&hellip;
</p>
<p>
    private final void performLayoutAndPlaceSurfacesLockedInner(
            boolean recoveringMemory) {
        &hellip;&hellip;
</p>
<p>
        Surface.openTransaction();
        &hellip;&hellip;
</p>
<p>
        try {
            &hellip;&hellip;
            int repeats = 0;
            int changes = 0;
</p>
<p>            
            do {
                repeats++;
                if (repeats &gt; 6) {
                    &hellip;&hellip;
                    break;
                }
</p>
<p>
                // FIRST LOOP: Perform a layout, if needed.
                if (repeats &lt; 4) {
                    changes = performLayoutLockedInner();
                    if (changes != 0) {
                        continue;
                    }
                } else {
                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
                    changes = 0;
                }
</p>
<p>
                // SECOND LOOP: Execute animations and update visibility of windows.
                &hellip;&hellip;
</p>
<p>                
            } while (changes != 0);
</p>
<p>
            // THIRD LOOP: Update the surfaces of all windows.
</p>
<p>                
            &hellip;&hellip;
        } catch (RuntimeException e) {
            &hellip;&hellip;
        }
</p>
<p>
        &hellip;&hellip;
</p>
<p>
        Surface.closeTransaction();
</p>
<p>
        &hellip;&hellip;
</p>
<p>
        // Destroy the surface of any windows that are no longer visible.
        &hellip;&hellip;
</p>
<p>
        // Time to remove any exiting tokens?
        &hellip;&hellip;
</p>
<p>
        // Time to remove any exiting applications?
        &hellip;&hellip;
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。
</p>
<p>
        WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner是一个巨无霸的函数，它一共有1200+行代码
，承载了WindowManagerService服务的核心功能。对于这样一个巨无霸函数，要逐行地分析它的实现是很困难的，因为要理解各种上下
文信息，才可以清楚地知道它的执行过程。这里我们就大概地分析它的实现框架，以后再逐步地分析它的具体实现：
</p>
<ol>
<li>在一个最多执行7次的while循环中，做两件事情：第一件事情是计算各个窗品的大小，这是通过调用另外一个成员函数
</li>
</ol>

<p>performLayoutLockedInner来实现的；第二件事情是执行窗口的动画，主要是处理窗口的启动窗口显示动画和窗口切换过程中的动画，
以及更新各个窗口的可见性。注意，每一次while循环执行之后，如果发现系统中的各个窗口的相应布局属性不再发生变化，那么就不行
执行下一次的while循环了，即该while循环可能不用执行7次就结束了。窗口的动画显示过程和窗口的可见性更新过程是相当复杂的，它
们也是WindowManagerService服务最为核的地方，在后面的文章中，我们再详细分析。
</p>
<ol>
<li>经过第1点的操作之后，接下来就可以将各个窗口的属性，例如，大小、位置等属性，通知SurfaceFlinger服务了，也就是
</li>
</ol>

<p>让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲
区中去。SurfaceFlinger服务计算系统中各个窗口，即各个Layer的可见性，以便将它们合成、渲染到硬件帧缓冲区的过程可以参考前面
Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析一文。注意，各个窗口的属性更新操作是被包含在
SurfaceFlinger服务的一个事务中的，即一个Transaction中，这样做是为了避免每更新一个窗口的一个属性就触发SurfaceFlinger服务
重新计算各个Layer的可见性，以及对各个Layer进行合并和渲染的操作。启动SurfaceFlinger服务的一个事务可以通过调用Surface类的
静态成员函数openTransaction来实现，而关闭SurfaceFlinger服务的一个事务可以通过调用Surface类的静态成员函数
closeTransaction来实现。
</p>
<ol>
<li>经过第1点和第2点的操作之后，一次系统UI的刷新过程就完成了，这时候就会将系统中的那些不会再显示的窗口的绘图表面
</li>
</ol>

<p>销毁掉，并且将那些已经完成退出了的窗口令牌，即将我们在前面Android应用程序窗口（Activity）与WindowManagerService服务的连
接过程分析一文中所提到的WindowToken移除掉，以及将那些已经退出了的Activity窗口令牌，即将我们在前面Android应用程序窗口（
Activity）与WindowManagerService服务的连接过程分析一文中所提到的AppWindowToken也移除掉。这一步实际执行的是窗口清理操作
。
</p>
<p>
       上述三个操作是WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner的实现关键所在，理解了这三
个操作，基本也就可以理解WindowManagerService服务刷新系统UI的过程了。
</p>
<p>
       接下来，我们继续分析WindowManagerService类的成员函数performLayoutLockedInner的实现，以便可以继续了解Activity窗口
的大小计算过程。
</p>
<p>
       Step 7. WindowManagerService.performLayoutLockedInner
</p>
<p>
public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    &hellip;&hellip;
</p>
<p>
    final WindowManagerPolicy mPolicy = PolicyManager.makeNewWindowManager();
    &hellip;&hellip;
</p>
<p>
    /**
</p><ul>
<li>Z-ordered (bottom-most first) list of all Window objects.
</li>
</ul>

<p>     */
    final ArrayList&lt;WindowState&gt; mWindows = new ArrayList&lt;WindowState&gt;();
    &hellip;&hellip;
</p>
<p>
    private final int performLayoutLockedInner() {
        &hellip;&hellip;
</p>
<p>
        final int dw = mDisplay.getWidth();
        final int dh = mDisplay.getHeight();
</p>
<p>
        final int N = mWindows.size();
        int i;
</p>
<p>
        &hellip;&hellip;
</p>
<p>
        mPolicy.beginLayoutLw(dw, dh);
</p>
<p>
        int seq = mLayoutSeq+1;
        if (seq &lt; 0) seq = 0;
        mLayoutSeq = seq;
</p>
<p>
        // First perform layout of any root windows (not attached
        // to another window).
        int topAttached = -1;
        for (i = N-1; i &gt;= 0; i&ndash;) {
            WindowState win = mWindows.get(i);
            &hellip;&hellip;
</p>
<p>
            final AppWindowToken atoken = win.mAppToken;
            final boolean gone = win.mViewVisibility == View.GONE
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">!win.mRelayoutCalled</td></tr>
<tr><td class="left"></td><td class="left">win.mRootToken.hidden</td></tr>
<tr><td class="left"></td><td class="left">(atoken != null &amp;&amp; atoken.hiddenRequested)</td></tr>
<tr><td class="left"></td><td class="left">win.mAttachedHidden</td></tr>
<tr><td class="left"></td><td class="left">win.mExiting</td><td class="left"></td><td class="left">win.mDestroying;</td></tr>
</tbody>
</table>

            &hellip;&hellip;

<p>
            if (!gone || !win.mHaveFrame) {
                if (!win.mLayoutAttached) {
                    mPolicy.layoutWindowLw(win, win.mAttrs, null);
                    win.mLayoutSeq = seq;
                    &hellip;&hellip;
                } else {
                    if (topAttached &lt; 0) topAttached = i;
                }
            }
        }
        &hellip;&hellip;
</p>
<p>
        for (i = topAttached; i &gt;= 0; i&ndash;) {
            WindowState win = mWindows.get(i);
</p>
<p>
            // If this view is GONE, then skip it &ndash; keep the current
            // frame, and let the caller know so they can ignore it
            // if they want.  (We do the normal layout for INVISIBLE
            // windows, since that means "perform layout as normal,
            // just don't display").
            if (win.mLayoutAttached) {
                &hellip;&hellip;
</p>
<p>
                if ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled)
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"></td><td class="left">!win.mHaveFrame) {</td></tr>
</tbody>
</table>

                    mPolicy.layoutWindowLw(win, win.mAttrs, win.mAttachedWindow);
                    win.mLayoutSeq = seq;
                    &hellip;&hellip;
                }
            }
        }

<p>
        &hellip;&hellip;
</p>
<p>
        return mPolicy.finishLayoutLw();
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。
</p>
<p>
        在分析WindowManagerService类的成员函数performLayoutLockedInner的实现之前，我们首先介绍WindowManagerService类的
两个成员变量mPolicy和mWindows：
</p>
<ol>
<li>mPolicy指向的是一个窗口管理策略类，它是通过调用PolicyManager类的静态成员函数makeNewWindowManager来初始化的，
</li>
</ol>

<p>在Phone平台中，它指向的是便是一个PhoneWindowManager对象，主要是用来制定窗口的大小计算策略。
</p>
<ol>
<li>mWindows指向的是一个类型为WindowState的ArrayList，它里面保存的就是系统中的所有窗口，这些窗口是按照Z轴位置从
</li>
</ol>

<p>小到大的顺序保存在这个ArrayList中的，也就是说，第i个窗口位于第i-1个窗口的上面，其中，i &gt; 0。
</p>
<p>
        理解了这两个成员变量的含义之后，我们就分析WindowManagerService类的成员函数performLayoutLockedInner的执行过程，
主要是分三个阶段：
</p>
<ol>
<li>准备阶段：调用PhoneWindowManager类的成员函数beginLayoutLw来设置屏幕的大小。屏幕的大小可以通过调用
</li>
</ol>

<p>WindowManagerService类的成员变量mDisplay所描述的一个Display对象的成员函数getWidth和getHeight来获得。
</p>
<ol>
<li>计算阶段：调用PhoneWindowManager类的成员函数layoutWindowLw来计算各个窗口的大小、内容区域边衬大小以及可见区域
</li>
</ol>

<p>边衬大小。
</p>
<ol>
<li>结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw来执行一些清理工作。
</li>
</ol>


<p>
        按照父子关系来划分，系统中的窗口可以分为父窗口和子窗口两种。如果一个WindowState对象的成员变量mLayoutAttached的
值等于false，那么它所描述的窗口就可以作为一个父窗口，否则的话，它所描述的窗口就是一个子窗口。由于子窗口的大小计算是依赖
于其父窗口的，因此，在计算各个窗口的大小的过程中，即在上述的第2阶段中，按照以下方式来进行：
</p>
<ol>
<li>先计算父窗口的大小。一般来说，能够作为父窗口的，是那些Activity窗口。从前面Android应用程序窗口（Activity）与
</li>
</ol>

<p>WindowManagerService服务的连接过程分析一文可以知道，如果一个窗口是Activity窗口，那么用来描述它的一个WindowState对象的成
员变量mAppToken就不等于null，并且指向的是一个AppWindowToken对象。这个AppWindowToken对象主要是用来描述一个Activity，即与
ActivityManagerService服务中的一个ActivityRecord对象对应。一个Activity窗口只有在两种情况下才会被计算大小：第一种情况是
窗口不是处于不可见状态的；第二种情况是窗口从来还没有被计算过大小，即用来描述该Activity窗口的WindowState对象的成员变量
mHaveFrame的值等于false，这种情况一般发生在窗口刚刚被添加到WindowManagerService的过程中。一个Activity窗口的不可见状态由
它本身的状态、它所在的窗口结构树状态以及它所属的Activity的状态有关，也就是说，如果一个Activity窗口本身是可见的，但是由
于它的父窗口、它所在的窗口组的根窗口或者它所属的Activity是不可见的，那么该Activity窗口也是不可见的。一个Activity窗口的
不可见状态由以下因素决定：
</p>
<p>
        1). 它本身处于不可见状态，即对应的WindowState对象的成员变量mViewVisibility的值等于View.GONE；
</p>
<p>
        2). 它本身处于正在退出的状态，即对应的WindowState对象的成员变量mExiting的值等于true；
</p>
<p>
        3). 它本身处于正在销毁的状态，即对应的WindowState对象的成员变量mDestroying的值等于true；
</p>
<p>
        4). 它的父窗口处于不可见状态，即对应的WindowState对象的成员变量mAttachedHidden的值等于true；
</p>
<p>
        5). 它所在窗口结构树中的根窗口处于不可见状态，即对应的WindowState对象的成员变量mRootToken所描述的一个
WindowToken对象的成员变量hidden的值等于true；
</p>
<p>
        6). 它所属的Activity处于不可见状态，即对应的WindowState对象的成员变量mAppToken所描述的一个AppWindowToken对象的
成员变量hiddenRequested的值等于true。
</p>
<p>
        除了上述六个因素之外，如果一个Activity窗口没有被它所运行在的应用程序进程主动请求WindowManagerService服务对它进
行布局，即对应的WindowState对象的成员变量mRelayoutCalled的值等于false，那么此时也是不需要计算Activity窗口的大小的。
</p>
<p>
       一个Activity窗口的大小一旦确定是需要计算大小之后，PhoneWindowManager类的成员函数layoutWindowLw就被调用来计算它的
大小。
</p>
<ol>
<li>接着计算子窗口的大小。前面在计算父窗口的大小过程中，会记录位于系统最上面的一个子窗口在mWindows所描述的一个
</li>
</ol>

<p>ArrayList的位置topAttached，接下来就可以从这个位置开始向下计算每一个子窗口的大小。一个子窗口在以下两种情况下，才会被计
算大小：
</p>
<p>
       1). 它本身处于可见状态，即对应的WindowState对象的成员变量mViewVisibility的值不等于View.GONE，并且它所运行在的应
用程序进程主动请求WindowManagerService服务对它进行布局，即对应的WindowState对象的成员变量mRelayoutCalled的值等于true。
</p>
<p>
       2). 它从来还没有被计算过大小，即用来描述该子窗口的WindowState对象的成员变量mHaveFrame的值等于false，这种情况一般
发生在子窗口刚刚被添加到WindowManagerService的过程中。
</p>
<p>
       接下来，我们就分别分析PhoneWindowManager类的成员函数beginLayoutLw、layoutWindowLw和finishLayoutLw的实现，以便可
以了解Activity窗口的大小计算过程。
</p>
<p>
       Step 8. PhoneWindowManager.beginLayoutLw
</p>
<p>
public class PhoneWindowManager implements WindowManagerPolicy {
    &hellip;&hellip;
</p>
<p>
    WindowState mStatusBar = null;
    &hellip;&hellip;
</p>
<p>
    // The current size of the screen.
    int mW, mH;
    // During layout, the current screen borders with all outer decoration
    // (status bar, input method dock) accounted for.
    int mCurLeft, mCurTop, mCurRight, mCurBottom;
    // During layout, the frame in which content should be displayed
    // to the user, accounting for all screen decoration except for any
    // space they deem as available for other content.  This is usually
    // the same as mCur*, but may be larger if the screen decor has supplied
    // content insets.
    int mContentLeft, mContentTop, mContentRight, mContentBottom;
    // During layout, the current screen borders along with input method
    // windows are placed.
    int mDockLeft, mDockTop, mDockRight, mDockBottom;
    // During layout, the layer at which the doc window is placed.
    int mDockLayer;
</p>
<p>    
    static final Rect mTmpParentFrame = new Rect();
    static final Rect mTmpDisplayFrame = new Rect();
    static final Rect mTmpContentFrame = new Rect();
    static final Rect mTmpVisibleFrame = new Rect();
    &hellip;&hellip;
</p>
<p>
    public void beginLayoutLw(int displayWidth, int displayHeight) {
        mW = displayWidth;
        mH = displayHeight;
        mDockLeft = mContentLeft = mCurLeft = 0;
        mDockTop = mContentTop = mCurTop = 0;
        mDockRight = mContentRight = mCurRight = displayWidth;
        mDockBottom = mContentBottom = mCurBottom = displayHeight;
        mDockLayer = 0x10000000;
</p>
<p>
        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            final Rect pf = mTmpParentFrame;
            final Rect df = mTmpDisplayFrame;
            final Rect vf = mTmpVisibleFrame;
            pf.left = df.left = vf.left = 0;
            pf.top = df.top = vf.top = 0;
            pf.right = df.right = vf.right = displayWidth;
            pf.bottom = df.bottom = vf.bottom = displayHeight;
</p>
<p>
            mStatusBar.computeFrameLw(pf, df, vf, vf);
            if (mStatusBar.isVisibleLw()) {
                // If the status bar is hidden, we don't want to cause
                // windows behind it to scroll.
                mDockTop = mContentTop = mCurTop = mStatusBar.getFrameLw().bottom;
                &hellip;&hellip;
            }
        }
    }
</p>
<p> 
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。
</p>
<p>
        在分析PhoneWindowManager类的成员函数beginLayoutLw的实现之前，我们首先介绍PhoneWindowManager类的五组成员变量。
</p>
<p>
        第一组成员变量是mW和mH，它们分别用来描述当前这轮窗口大小计算过程的屏幕宽度和高度。
</p>
<p>
        第二组成员变量是mCurLeft、mCurTop、mCurRight和mCurBottom，它们组成一个四元组（mCurLeft, mCurTop, mCurRight,
mCurBottom），用来描述当前这轮窗口大小计算过程的屏幕装饰区，它对应于前面所提到的Activity窗口的可见区域边衬。
</p>
<p>
        第三组成员变量是mContentLeft、mContentTop、mContentRight和mContentBottom，它们组成一个四元组（mContentLeft,
mContentTop, mContentRight, mContentBottom），也是用来描述当前这轮窗口大小计算过程的屏幕装饰区，不过它对应的是前面所提
到的Activity窗口的内容区域边衬。
</p>
<p>
        第四组成员变量是mDockLeft、mDockTop、mDockRight、mDockBottom和mDockLayer，其中，前四个成员变量组成一个四元组（
mDockLeft, mDockTop, mDockRight, mDockBottom），用来描述当前这轮窗口大小计算过程中的输入法窗口所占据的位置，后一个成员
变量mDockLayer用来描述输入法窗品的Z轴位置。
</p>
<p>
        第五组成员变量是mTmpParentFrame、mTmpDisplayFrame、mTmpContentFrame和mTmpVisibleFrame，它们是一组临时Rect区域，
用来作为参数传递给具体的窗口计算大小的，避免每次都创建一组新的Rect区域来作来参数传递窗口。
</p>
<p>
        除了这五组成员变量之外，PhoneWindowManager类还有一个成员变量mStatusBar，它的类型为WindowState，用来描述系统的状
态栏。
</p>
<p>
        理解了这些成员变量的含义之后，PhoneWindowManager类的成员函数beginLayoutLw的实现就容易理解了，它主要做了以下两件
事情：
</p>
<ol>
<li>初始化前面所提到的四组成员变量，其中，mW和mH设置为参数displayWidth和displayHeight所指定的屏幕宽度和高度，并
</li>
</ol>

<p>且使得（mCurLeft, mCurTop, mCurRight, mCurBottom）、（mContentLeft, mContentTop, mContentRight, mContentBottom）和（
mDockLeft, mDockTop, mDockRight, mDockBottom）这三个区域的大小等于屏幕的大小。
</p>
<ol>
<li>计算状态栏的大小。状态栏的大小一经确定，并且它是可见的，那么就会修改成员变量mCurLeft、mContentLeft和
</li>
</ol>

<p>mDockLeft的值为状态栏的所占据的区域的下边界位置，这样就可以将（mCurLeft, mCurTop, mCurRight, mCurBottom）、（
mContentLeft, mContentTop, mContentRight, mContentBottom）和（mDockLeft, mDockTop, mDockRight, mDockBottom）这三个区域
限制为剔除状态栏区域之后所得到的屏幕区域。
</p>
<p>
        还有另外一个地方需要注意的是，输入法窗口的Z轴被初始化为0x10000000，这个值是相当大的了，可以保证输入法窗口作为顶
层窗口出现。
</p>
<p>
        这一步执行完成之后，返回到前面的Step 7中，即WindowManagerService类的成员函数performLayoutLockedInner，接下来就
会调用PhoneWindowManager类的成员函数layoutWindowLw来计算系统中各个可见窗口的大小。
</p>
<p>
        Step 9. PhoneWindowManager.layoutWindowLw
</p>
<p>
public class PhoneWindowManager implements WindowManagerPolicy {
    &hellip;&hellip;
</p>
<p>
    public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
            WindowState attached) {
        // we've already done the status bar
        if (win == mStatusBar) {
            return;
        }
        &hellip;&hellip;
</p>
<p>
        final int fl = attrs.flags;
        final int sim = attrs.softInputMode;
</p>
<p>
        final Rect pf = mTmpParentFrame;
        final Rect df = mTmpDisplayFrame;
        final Rect cf = mTmpContentFrame;
        final Rect vf = mTmpVisibleFrame;
</p>
<p>
        if (attrs.type == TYPE<sub>INPUT</sub><sub>METHOD</sub>) {
            pf.left = df.left = cf.left = vf.left = mDockLeft;
            pf.top = df.top = cf.top = vf.top = mDockTop;
            pf.right = df.right = cf.right = vf.right = mDockRight;
            pf.bottom = df.bottom = cf.bottom = vf.bottom = mDockBottom;
            // IM dock windows always go to the bottom of the screen.
            attrs.gravity = Gravity.BOTTOM;
            mDockLayer = win.getSurfaceLayer();
        } else {
            if ((fl &amp;
                    (FLAG<sub>LAYOUT</sub><sub>IN</sub><sub>SCREEN</sub> | FLAG<sub>FULLSCREEN</sub> | FLAG<sub>LAYOUT</sub><sub>INSET</sub><sub>DECOR</sub>))
                    == (FLAG<sub>LAYOUT</sub><sub>IN</sub><sub>SCREEN</sub> | FLAG<sub>LAYOUT</sub><sub>INSET</sub><sub>DECOR</sub>)) {
                // This is the case for a normal activity window: we want it
                // to cover all of the screen space, and it can take care of
                // moving its contents to account for screen decorations that
                // intrude into that space.
                if (attached != null) {
                    // If this window is attached to another, our display
                    // frame is the same as the one we are attached to.
                    setAttachedWindowFrames(win, fl, sim, attached, true, pf, df, cf, vf);
                } else {
                    pf.left = df.left = 0;
                    pf.top = df.top = 0;
                    pf.right = df.right = mW;
                    pf.bottom = df.bottom = mH;
                    if ((sim &amp; SOFT<sub>INPUT</sub><sub>MASK</sub><sub>ADJUST</sub>) != SOFT<sub>INPUT</sub><sub>ADJUST</sub><sub>RESIZE</sub>) {
                        cf.left = mDockLeft;
                        cf.top = mDockTop;
                        cf.right = mDockRight;
                        cf.bottom = mDockBottom;
                    } else {
                        cf.left = mContentLeft;
                        cf.top = mContentTop;
                        cf.right = mContentRight;
                        cf.bottom = mContentBottom;
                    }
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                }
            }
</p>
<p>
            &hellip;&hellip;
        }
</p>
<p>
        win.computeFrameLw(pf, df, cf, vf);
</p>
<p>
        // Dock windows carve out the bottom of the screen, so normal windows
        // can't appear underneath them.
        if (attrs.type == TYPE<sub>INPUT</sub><sub>METHOD</sub> &amp;&amp; !win.getGivenInsetsPendingLw()) {
            int top = win.getContentFrameLw().top;
            top += win.getGivenContentInsetsLw().top;
            if (mContentBottom &gt; top) {
                mContentBottom = top;
            }
            top = win.getVisibleFrameLw().top;
            top += win.getGivenVisibleInsetsLw().top;
            if (mCurBottom &gt; top) {
                mCurBottom = top;
            }
            &hellip;&hellip;
        }
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。
</p>
<p>
        第一个参数win描述的是当前要计算大小的窗口，第二个参数attrs描述的是窗口win的布局参数，第三个参数attached描述的是
窗口win的父窗口，如果它的值等于null，就表示窗口win没有父窗口。
</p>
<p>
        PhoneWindowManager类的成员函数layoutWindowLw会根据窗口win的是子窗口还是全屏窗口及其软键盘显示模式来决定它的大小
如何计算。这里我们只关注输入法窗口和非全屏的Activity窗口的大小计算方式，其它类型的窗口大小计算方式是差不多的。
</p>
<p>
        从前面的Step 8可以知道，系统的状态栏大小已经计算过了，因此，PhoneWindowManager类的成员函数layoutWindowLw如果发
现参数win描述的正好是状态栏的话，它就什么也不做就返回了。
</p>
<p>
        在计算一个窗口的大小的时候，我们需要四个参数。第一个参数是父窗口的大小pf，第二个参数是屏幕的大小df，第三个参数
是内容区域边衬大小cf，第四个参数是可见区域边衬大小vf。 
</p>
<p>
        如果参数win描述的是输入法窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于
TYPE<sub>INPUT</sub><sub>METHOD，那么上述四个用来计算窗口大小的区域pf、df、cf和vf就等于PhoneWindowManager类的成员变量mDockLeft、</sub>
mDockTop、mDockRight和mDockBottom所组成的区域的大小。
</p>
<p>
        如果参数win描述的是一个非全屏的Activity窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量
flags的FLAG<sub>LAYOUT</sub><sub>IN</sub><sub>SCREEN位和FLAG</sub><sub>LAYOUT</sub><sub>INSET</sub><sub>DECOR位等于1，那么PhoneWindowManager类的成员函数layoutWindowLw就会继</sub>
续检查参数attached的值是否不等于null。如果不等于null的话，那么就说明参数win所描述的一个非全屏的Activity窗口附加在其它窗
口上，即它具有一个父窗口，这时候就会调用另外一个成员函数setAttachedWindowFrames来计算它的大小。 
</p>
<p>
        接下来我们就只关注参数win描述的是一个非全屏的、并且没有附加到其它窗口的Activity窗口的大小计算过程。
</p>
<p>
        首先，父窗口大小pf和屏幕大小df都会被设置为整个屏幕区域的大小。
</p>
<p>
        其次，可见区域边衬大小vf被设置为PhoneWindowManager类的成员变量mCurLeft、mCurTop、mCurRight和mCurBottom所组成的
区域的大小。
</p>
<p>
        第三，内容区域边衬大小cf的计算相对复杂一些，需要考虑窗口win的软键盘显示模式sim的值。如果变量sim的
SOFT<sub>INPUT</sub><sub>ADJUST</sub><sub>RESIZE位等于1，那么就意味着窗口win在出向输入法窗口的时候，它的内容要重新进行排布，避免被输入法窗口挡</sub>
住，因此，这时候窗口win的内容区域大小就会等于PhoneWindowManager类的成员变量mContentLeft、mContentTop、mContentRight和
mContentBottom所组成的区域的大小。另一方面，如果变量sim的SOFT<sub>INPUT</sub><sub>ADJUST</sub><sub>RESIZE位等于0，那么就意味着窗口win在出向输入</sub>
法窗口的时候，它的内容不需要重新进行排布，这时候它的内容区域大小就会等于PhoneWindowManager类的成员变量mDockLeft、
mDockTop、mDockRight和mDockBottom所组成的区域的大小。注意，PhoneWindowManager类的成员变量mDockLeft、mDockTop、
mDockRight和mDockBottom所组成的区域的大小并不是等于输入法窗口的大小的，而是包含了输入法窗口所占据的区域的大小，这就意味
着输入法窗口与窗口win会有重叠的部分，或者说输入法窗口覆盖了窗口win的一部分。
</p>
<p>
        得到了用来计算窗口win四个参数pf、 df、cf和vf之后，就可以调用参数win所描述的一个WindowState对象的成员函数
computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。
注意，窗口经过计算后得到的内容区域边衬大小和可见区域边衬大小并不一定是等于参数cf和vf所指定的大小的。
</p>
<p>
        计算完成窗口win的大小之后，PhoneWindowManager类的成员函数layoutWindowLw还会检查窗口win是否是一个输入法窗口，并
且它是否指定了额外的内容区域边衬和可见区域边衬。如果这两个条件都成立的话，那么就需要相应地调整PhoneWindowManager类的成
员变量mContentBottom和mCurBottom的值，以便使得PhoneWindowManager类的成员变量是mContentLeft、mContentTop、mContentRight
和mContentBottom所围成的内容区域和成员变量mCurLeft、mCurTop、mCurRight和mCurBottom所围成的可见区域不会覆盖到输入法窗口
额外指定的内容区域边衬和可见区域边衬。
</p>
<p>
        接下来，我们就继续分析WindowState类的成员函数computeFrameLw的实现，以便可以了解Activity窗口的大小计算的具体过程
。
</p>
<p>
        Step 10. WindowState.computeFrameLw
</p>
<p>
public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    &hellip;&hellip;
</p>
<p>
    private final class WindowState implements WindowManagerPolicy.WindowState {
        &hellip;&hellip;
</p>
<p>
        boolean mHaveFrame;
        &hellip;&hellip;
</p>
<p>
        // "Real" frame that the application sees.
        final Rect mFrame = new Rect();
        &hellip;&hellip;
</p>
<p>
        final Rect mContainingFrame = new Rect();
        final Rect mDisplayFrame = new Rect();
        final Rect mContentFrame = new Rect();
        final Rect mVisibleFrame = new Rect();
</p>
<p>
        public void computeFrameLw(Rect pf, Rect df, Rect cf, Rect vf) {
            mHaveFrame = true;
</p>
<p>
            final Rect container = mContainingFrame;
            container.set(pf);
</p>
<p>
            final Rect display = mDisplayFrame;
            display.set(df);
</p>
<p>
            if ((mAttrs.flags &amp; FLAG<sub>COMPATIBLE</sub><sub>WINDOW</sub>) != 0) {
                container.intersect(mCompatibleScreenFrame);
                if ((mAttrs.flags &amp; FLAG<sub>LAYOUT</sub><sub>NO</sub><sub>LIMITS</sub>) == 0) {
                    display.intersect(mCompatibleScreenFrame);
                }
            }
</p>
<p>
            final int pw = container.right - container.left;
            final int ph = container.bottom - container.top;
</p>
<p>
            int w,h;
            if ((mAttrs.flags &amp; mAttrs.FLAG<sub>SCALED</sub>) != 0) {
                w = mAttrs.width &lt; 0 ? pw : mAttrs.width;
                h = mAttrs.height&lt; 0 ? ph : mAttrs.height;
            } else {
                w = mAttrs.width == mAttrs.MATCH_PARENT ? pw : mRequestedWidth;
                h = mAttrs.height== mAttrs.MATCH<sub>PARENT</sub> ? ph : mRequestedHeight;
            }
</p>
<p>
            final Rect content = mContentFrame;
            content.set(cf);
</p>
<p>
            final Rect visible = mVisibleFrame;
            visible.set(vf);
</p>
<p>
            final Rect frame = mFrame;
            final int fw = frame.width();
            final int fh = frame.height();
</p>
<p>
            &hellip;&hellip;
</p>
<p>
            Gravity.apply(mAttrs.gravity, w, h, container,
                    (int) (mAttrs.x + mAttrs.horizontalMargin * pw),
                    (int) (mAttrs.y + mAttrs.verticalMargin * ph), frame);
</p>
<p>
            &hellip;&hellip;
</p>
<p>
            // Now make sure the window fits in the overall display.
            Gravity.applyDisplay(mAttrs.gravity, df, frame);
</p>
<p>
            // Make sure the content and visible frames are inside of the
            // final window frame.
            if (content.left &lt; frame.left) content.left = frame.left;
            if (content.top &lt; frame.top) content.top = frame.top;
            if (content.right &gt; frame.right) content.right = frame.right;
            if (content.bottom &gt; frame.bottom) content.bottom = frame.bottom;
            if (visible.left &lt; frame.left) visible.left = frame.left;
            if (visible.top &lt; frame.top) visible.top = frame.top;
            if (visible.right &gt; frame.right) visible.right = frame.right;
            if (visible.bottom &gt; frame.bottom) visible.bottom = frame.bottom;
</p>
<p>
            final Rect contentInsets = mContentInsets;
            contentInsets.left = content.left-frame.left;
            contentInsets.top = content.top-frame.top;
            contentInsets.right = frame.right-content.right;
            contentInsets.bottom = frame.bottom-content.bottom;
</p>
<p>
            final Rect visibleInsets = mVisibleInsets;
            visibleInsets.left = visible.left-frame.left;
            visibleInsets.top = visible.top-frame.top;
            visibleInsets.right = frame.right-visible.right;
            visibleInsets.bottom = frame.bottom-visible.bottom;
</p>
<p>
            if (mIsWallpaper &amp;&amp; (fw != frame.width() || fh != frame.height())) {
                updateWallpaperOffsetLocked(this, mDisplay.getWidth(),
                        mDisplay.getHeight(), false);
            }
</p>
<p>
            &hellip;&hellip;
        }
</p>
<p>
        &hellip;&hellip;
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。
</p>
<p>
        WindowState类的成员变量mHaveFrame用来描述一个窗口的大小是否计算过了。当WindowState类的成员函数computeFrameLw被
调用的时候，就说明一个相应的窗口的大小得到计算了，因此，WindowState类的成员函数computeFrameLw一开始就会将成员变量
mHaveFrame的值设置为true。
</p>
<p>
        回忆一下，在前面的Step 9中提到，参数pf描述的是父窗口的大小，参数df描述的是屏幕的大小，参数cf描述的内容区域大小
，参数vf描述的是可见区域大小，接下来我们就分析WindowState类的成员函数computeFrameLw是如何利用这些参数来计算一个窗口的大
小的。
</p>
<p>
        WindowState类的成员变量mContainingFrame和mDisplayFrame描述的是当前正在处理的窗口的父窗口和屏幕的大小，它们刚好
就分别等于参数pf和df的大小，因此，函数就直接将参数pf和df的值分别保存在WindowState类的成员变量mContainingFrame和
mDisplayFrame中。如果当前正在处理的窗口运行在兼容模式，即WindowState类的成员变量mAttrs所指向的一个
WindowManager.LayoutParams对象的成员变量flags的FLAG<sub>COMPATIBLE</sub><sub>WINDOW位等于1，那么就需要将其父窗口的大小限制</sub>
mContainingFrame在兼容模式下的屏幕区域中。兼容模式下的屏幕区域保存在WindowManagerService类的成员变量
mCompatibleScreenFrame中，将父窗口的大小mContainingFrame与它执行一个相交操作，就可以将父窗品的大小限制兼容模式下的屏幕
区域中。在当前正在处理的窗口运行在兼容模式的情况下，如果它的大小被限制在了兼容模式下的屏幕区域之中，即WindowState类的成
员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量flags的FLAG<sub>LAYOUT</sub><sub>NO</sub><sub>LIMITS位等于0，那么同样需要将屏幕</sub>
大小mDisplayFrame限制在兼容模式下的屏幕区域mCompatibleScreenFrame，这也是通过执行一个相交操作来完成的。
</p>
<p>
        WindowState类的成员变量mContentFrame和mVisibleFrame描述的是当前正在处理的窗口的内容区域和可见区域大小，它们刚好
就分别等于参数cf和vf的大小，因此，函数就直接将参数cf和vf的值分别保存在WindowState类的成员变量mContainingFrame和
mDisplayFrame中。现在，就剩下窗口的大小还没有计算。一旦窗口大小确定下来之后，就可以继续计算窗口的内容区域边衬和可见区域
边衬大小了。接下来我们就继续分析窗口大小的计算过程。
</p>
<p>
         WindowState类的成员变量mFrame描述的就是当前正在处理的窗品的大小，我们的目标就是计算它的值。一个窗口的大小是受
以下因素影响的：
</p>
<ol>
<li>是否指定了缩放因子。如果一个窗口的大小被指定了缩放因子，即WindowState类的成员变量mAttrs所指向的一个
</li>
</ol>

<p>WindowManager.LayoutParams对象的成员变量flags的FLAG<sub>SCALED位等于1，那么该窗口的大小就是在它的布局参数中指定的，即是由</sub>
WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量width和height所指定的。但是，如果在布
局参数中指定的窗口宽度或者高度小于0，那么就会使用其父窗口的大小来作为当前窗口的大小。当前窗口的父窗口的宽度和高度分别保
存在变量pw和ph中。
</p>
<ol>
<li>是否指定了等于父窗口的大小。如果一个窗口的大小被指定为其父窗口的大小，即WindowState类的成员变量mAttrs所指向
</li>
</ol>

<p>的一个WindowManager.LayoutParams对象的成员变量width和height的值等于mAttrs.MATCH<sub>PARENT，那么该窗口的大小就会等于其父窗</sub>
口的大小，即等于变量pw和ph所描述的宽度和高度。另一方面，如果一个窗口的大小没有指定为其父窗口的大小的话，那么它的大小就
会等于应用程序进程请求WindowManagerService所设置的大小，即等于WindowState类的成员变量mRequestedWidth和mRequestedHeight
所描述的宽度和高度。
</p>
<p>
         经过上述2个操作之后，我们就初步地得到了窗口的宽度w和高度h，但是，它们还不是最终的窗口大小，还要进一步地根据窗
口的Gravity属性来作调整，这个调整分两步进行：
</p>
<ol>
<li>根据窗口的Gravity值，以及位置、初始大小和父窗口大小，来计算窗口的大小，并且保存在变量frame中，即保存在
</li>
</ol>

<p>WindowState类的成员变量mFrame中，这是通过调用Gravity类的静态成员函数apply来实现的。其中，窗口的初始大小保存在变量w和h中
，父窗口大小保存在变量container中，即WindowState类的成员变量mContainingFrame中，位置保存在WindowState类的成员变量mAttrs
所指向的一个WindowManager.LayoutParams对象的成员变量x和y中。注意，如果窗口指定了相对父窗口的margin值，那么还需要相应的
调整其位置值，即要在指定的位置值的基础上，再加上相对父窗口的margin值。一个窗口相对父窗口的margion是通过一个百分比来表示
的，用这个百分比乘以父窗口的大小就可以得到绝对值。这个百分比又分为在水平方向和垂直方向两个值，分别保存在WindowState类的
成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量horizontalMargin和verticalMargin中。
</p>
<ol>
<li>前面计算得到的窗口大小没有考虑在屏幕的大小，因此，接下来还需要继续调用Gravity类的静态成员函数applyDisplay来
</li>
</ol>

<p>将前面计算得到的窗口大小限制在屏幕区域df中，即限制在WindowState类的成员变量mDisplayFrame所描述的区域中。
</p>
<p>
        经过上述2个操作之后，窗口的最终大小就保存在变量frame中了，即WindowState类的成员变量mFrame中，接下来就可以计算窗
品的内容区域边衬和可见区域边衬大小了。
</p>
<p>
        内容区域边衬和可见区域边衬大小的计算很简单的，只要将窗口的大小frame，即WindowState类的成员变量mFrame所描述的区
域，分别减去变量content和visible，即WindowState类的成员变量mContentFrame和mVisibleFrame所描述的区域，就可以得到窗口的内
容区域边衬和可见区域边衬大小，它们分别保存在WindowState类的成员变量mContentInsets和mVisibleInsets中。注意，在计算窗口的
内容区域边衬和可见区域边衬大小之前，首先要保证窗口的内容区域和可见区域包含在整个窗口区域中，这一点是由中间的8个if语句来
保证的。
</p>
<p>
        窗口上一次的大小保存在变量fw和fh中。如果当前正在处理的窗口是一个壁纸窗口，即WindowState类的成员变量mIsWallpaper
的值等于true，并且该窗口的大小发生了变化，即变量fw和fh的所描述的窗口大小不等于变量frame描述的窗口大小，那么就需要调用
WindowManagerService类的成员函数updateWallpaperOffsetLocked来更新壁纸的位置。在后面的文章中，我们再详细描述系统的壁纸窗
口的位置是如何计算的。
</p>
<p>
        这一步执行完成之后，一个窗口的大小就计算完成了。从计算的过程可以知道，整个窗口大小保存在WindowState类的成员变量
mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中。这
些值最终会通过前面的Step 4返回给应用程序进程。
</p>
<p>
        返回到前面的Step 7中，即WindowManagerService类的成员函数performLayoutLockedInner，接下来就会调用
PhoneWindowManager类的成员函数finishLayoutLw来结束当前这轮窗口大小的计算工作。
</p>
<p>
        Step 11. PhoneWindowManager.finishLayoutLw
</p>
<p>
public class PhoneWindowManager implements WindowManagerPolicy {
    &hellip;&hellip;
</p>
<p>
    public int finishLayoutLw() {
        return 0;
    }
</p>
<p>
    &hellip;&hellip;
}
</p>
<p>
        这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。
</p>
<p>
        PhoneWindowManager类的成员函数finishLayoutLw是设计来结束一轮窗口大小的计算过程中，不过目前它什么也不做，只是一
个空实现。
</p>
<p>
        至此，我们就分析完成Activity窗口的大小计算过程了。从这个计算过程中，我们就可以知道一个Activity窗口除了有一个整
体大小之外，还有一个内容区域边衬大小和一个可见区域边衬大小。此外，我们还知道，一个Activity窗口的内容区域边衬大小和可见
区域边衬大小是可能会受到与其所关联的输入法窗口的影响的，因为输入法窗口会叠加在该Activity窗口上面，这就涉及到了系统中的
窗口的组织方式。在接下来的一篇文章中，我们就将继续分析WindowManagerService服务是如何组织系统中的窗口的。敬请关注！
</p>
</blockquote>


</div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Application Transition</h3>
<div class="outline-text-3" id="text-1-11">


</div>

<div id="outline-container-1-11-1" class="outline-4">
<h4 id="sec-1-11-1"><span class="section-number-4">1.11.1</span> overridePendingTransition</h4>
<div class="outline-text-4" id="text-1-11-1">

</div>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-05-17T17:00+0800</p>
<p class="author">Author: sunway</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.1 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
